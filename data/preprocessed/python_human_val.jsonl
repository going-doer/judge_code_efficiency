{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=[int(j) for j in input().split()]\n\nmod=10**9+7\n\nm=len(bin(max(a)))-2\n\nl=[[0,0] for i in range(m)]\n\nfor i in a:\n\n    b=bin(i)[2:].rjust(m,\"0\")[::-1]\n\n    for j in range(m):\n\n        if b[j]==\"0\":\n\n            l[j][0]+=1\n\n        else:\n\n            l[j][1]+=1\n\n\n\nans=0\n\nfor i in range(m):\n\n    ans+=l[i][0]*l[i][1]*pow(2,i,mod)\n\n    ans=ans%mod\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n \nB. import sys\n\ninput=sys.stdin.readline\n\nimport numpy as np\n\nn=int(eval(input()))\n\na=np.array([int(j) for j in input().split()],dtype=np.int64)\n\nans=0\n\nmod=10**9+7\n\nfor i in range(61):\n\n    b=(a>>i)&1\n\n    c=np.count_nonzero(b)\n\n    ans+=(2**i)*c*(n-c)\n\n    ans%=mod\n\nprint(ans)", "output": "A", "improve_diff": 11.1347555383, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    dic = {}\n\n    for i in range(1, N+1):\n\n        tmp = str(i)\n\n        s, e = int(tmp[0]), int(tmp[-1])\n\n        if (s, e) in dic:\n\n            dic[(s, e)] += 1\n\n        else:\n\n            dic[(s, e)] = 1\n\n    \n\n    ans = 0\n\n    for (i, j), count in list(dic.items()):\n\n        tmp = 0\n\n        if i == j:\n\n            tmp = count**2\n\n        else:\n\n            if (j, i) in dic:\n\n                tmp = count * dic[(j, i)]\n\n        ans += tmp\n\n        # print(i, j, count)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    dic = {}\n\n    for i in range(10):\n\n        for j in range(10):\n\n            dic[(i, j)] = 0\n\n    for i in range(1, N+1):\n\n        tmp = str(i)\n\n        s, e = int(tmp[0]), int(tmp[-1])\n\n        dic[(s, e)] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dic[(i, j)] * dic[(j, i)]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.1065239981, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nn = int(eval(input()))\n\n\n\nfor i in range(n, 0, -1):\n\n    if math.sqrt(i).is_integer():\n\n        print(i)\n\n        break\n \nB. n = int(eval(input()))\n\n\n\nfor i in reversed(list(range(1, int(n**0.5)+1))):\n\n    if i**2 <= n:\n\n        print((i**2))\n\n        break\n", "output": "B", "improve_diff": 1.3542255097, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n \n\nimport numpy as np\n\n \n\nN = int(readline())\n\nXY = np.array(read().split(),np.int64)\n\n \n\nX = XY[::2]; Y = XY[1::2]\n\n \n\ndx = X[:,None] - X[None,:]\n\ndy = Y[:,None] - Y[None,:]\n\n \n\ndist_mat = (dx * dx + dy * dy) ** .5\n\n \n\nanswer = dist_mat.sum() / N\n\nprint(answer) \nB. import math\n\nimport itertools\n\n\n\nN = int(eval(input()))\n\n\n\nlst = []\n\nfor i in range(N):\n\n    lst.append(list(map(int, input().split())))\n\n\n\nroutes = list(itertools.permutations(lst))\n\n\n\ndef distance(a, b):\n\n    return (((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)) ** 0.5\n\n\n\nroutes = [i for i in routes]\n\ndistancies = []\n\nfor i, r in enumerate(routes):\n\n    for j, a in enumerate(r):\n\n        if j >= len(r) - 1: break\n\n        b = r[j + 1]\n\n        ab_dist = distance(a, b)\n\n        distancies.append(ab_dist)\n\n\n\nprint((sum(distancies) / len(routes)))", "output": "B", "improve_diff": 8.2302518139, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nimport math\n\ndef dis(X,Y):\n\n    return ((X[0]-Y[0])**2+(X[1]-Y[1])**2)**.5\n\ndef main():\n\n    n=int(eval(input()))\n\n    L=[list(map(int,input().split())) for _ in range(n)]\n\n    S=itertools.permutations([i for i in range(1,n+1)])\n\n    ans=0\n\n    for s in S:\n\n        for i in range(n-1):\n\n            a = s[i] - 1\n\n            b = s[i+1] - 1\n\n            ans += dis(L[a],L[b])\n\n    ans /= math.factorial(n)\n\n    print(ans)\n\nmain() \nB. n = int(eval(input()))\n\nL = [list(map(int, input().split())) for _ in range(n)]\n\nans = 0\n\n# (edges)/(edge)*(1pathedges)\n\n# = (edges)/ (n*(n-1)) * (n-1)\n\nfor x1, y1 in L:\n\n    for x2, y2 in L:\n\n        ans += ((x1 - x2)**2 + (y1 - y2)**2)**.5\n\nprint((ans/n))", "output": "B", "improve_diff": 1.2440061276, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\ni = 1\n\nwhile i * i <= N:\n\n    i += 1\n\n\n\nprint(((i - 1) ** 2))\n \nB. N = int(eval(input()))\n\n\n\nfor i in range(N, 0, -1):\n\n    if i ** 0.5 == int(i ** 0.5):\n\n        print(i)\n\n        exit()\n", "output": "A", "improve_diff": 1.1804842245, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b, c = list(map(int, input().split()))\n\nfor i in range(1, 100):\n\n    if a*i % b == c:\n\n        print(\"YES\")\n\n        exit()\n\nprint(\"NO\") \nB. a, b, c = list(map(int, input().split()))\n\nfor i in range(1, 100000):\n\n    if a*i % b == c:\n\n        print(\"YES\")\n\n        exit()\n\nprint(\"NO\")", "output": "A", "improve_diff": 1.3560985103, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    stick = list(map(int, input().split()))\n\n\n\n    total = sum(stick)\n\n    mid = total // 2\n\n\n\n    cum = 0\n\n    midi = 0\n\n    for i, block in enumerate(stick):\n\n        cum += block\n\n        if cum >= mid:\n\n            midi = i\n\n            break\n\n\n\n    l1 = sum(stick[:midi])\n\n    r1 = sum(stick[midi:])\n\n    diff1 = abs(l1 - r1)\n\n    \n\n    l2 = l1 + stick[midi]\n\n    r2 = r1 - stick[midi]\n\n    diff2 = abs(l2 - r2)\n\n    \n\n    print((min(diff1, diff2)))\n\n\n\nmain() \nB. n = int(eval(input()))\n\n\n\nstick = list(map(int, input().split()))\n\n\n\ntotal = sum(stick)\n\nmid = total // 2\n\n\n\ncum = 0\n\nmidi = 0\n\nfor i, block in enumerate(stick):\n\n    cum += block\n\n    if cum >= mid:\n\n        midi = i\n\n        break\n\n\n\nl1 = sum(stick[:midi])\n\nr1 = sum(stick[midi:])\n\ndiff1 = abs(l1 - r1)\n\n \n\nl2 = l1 + stick[midi]\n\nr2 = r1 - stick[midi]\n\ndiff2 = abs(l2 - r2)\n\n \n\nprint((min(diff1, diff2)))", "output": "B", "improve_diff": 1.018781164, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nacc = [0] * (n + 1)\n\nfor i in range(n):\n\n    acc[i + 1] = acc[i] + A[i]\n\n\n\nfrom collections import Counter\n\n\n\ncnt = 0\n\ncacc = Counter(acc)\n\nfor k, v in list(cacc.items()):\n\n    if v > 1:\n\n        cnt += v * (v - 1) // 2\n\nprint(cnt) \nB. n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nacc = [0] * (n + 1)\n\nfor i in range(n):\n\n    acc[i + 1] = acc[i] + A[i]\n\n\n\nacc.sort()\n\n\n\nfrom collections import Counter\n\n\n\ncnt = 0\n\ncacc = Counter(acc)\n\nfor k, v in list(cacc.items()):\n\n    if v > 1:\n\n        cnt += v * (v - 1) // 2\n\nprint(cnt)", "output": "B", "improve_diff": 1.0212656634, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\n\n\nclass SegmentTree:\n\n    def __init__(self, N, func, I):\n\n        self.func = func\n\n        self.I = I\n\n        self.N = N\n\n        self.sz = 2**(N-1).bit_length()\n\n        self.seg = [I] * (self.sz * 2)\n\n \n\n    def assign(self, k, x):\n\n        self.seg[k + self.sz] = x\n\n \n\n    def build(self):\n\n        for i in reversed(list(range(1,self.sz))):\n\n            self.seg[i] = self.func(self.seg[2 * i], self.seg[2 * i + 1])\n\n \n\n    def update(self, k, x):\n\n        k += self.sz\n\n        self.seg[k] = x\n\n        while k > 1:\n\n            k >>= 1\n\n            self.seg[k] = self.func(self.seg[2 * k], self.seg[2 * k + 1])\n\n\n\n    def query(self, a, b):\n\n        L = self.I\n\n        R = self.I\n\n        a += self.sz\n\n        b += self.sz\n\n        while a < b:\n\n            if a & 1:\n\n                L = self.func(L, self.seg[a])\n\n                a += 1\n\n            if b & 1:\n\n                b -= 1\n\n                R = self.func(self.seg[b], R)\n\n            a >>= 1\n\n            b >>= 1\n\n        return self.func(L, R)\n\n\n\ndef main():\n\n    def gcd(a, b):\n\n        while b:\n\n            a, b = b, a % b\n\n        return a\n\n    N = int(readline())\n\n    L = list(map(int,readline().split()))\n\n    seg = SegmentTree(N , gcd , 0)\n\n    for i,n in enumerate(L):\n\n        seg.assign(i , n)\n\n    seg.build()\n\n    ans = 1\n\n    for i in range(N):\n\n        ans = max(ans,gcd(seg.query(0,i) , seg.query(i+1,N)))\n\n    print(ans)\n\n\n\nmain()\n \nB. import sys\n\nreadline = sys.stdin.buffer.readline\n\n\n\n\n\nclass SegmentTree:\n\n    def __init__(self, N, func, I):\n\n        self.N = N\n\n        self.sz = 2**(N-1).bit_length()\n\n        self.func = func\n\n        self.I = I\n\n        self.seg = [I] * (self.sz * 2)\n\n\n\n    def assign(self, k, x):\n\n        self.seg[k + self.sz] = x\n\n\n\n    def build(self):\n\n        for i in reversed(list(range(1, self.sz))):\n\n            self.seg[i] = self.func(self.seg[2 * i], self.seg[2 * i + 1])\n\n\n\n    def update(self, k, x):\n\n        k += self.sz\n\n        self.seg[k] = x\n\n        while k > 1:\n\n            k >>= 1\n\n            self.seg[k] = self.func(self.seg[2 * k], self.seg[2 * k + 1])\n\n\n\n    def query(self, a, b):\n\n        L = self.I\n\n        R = self.I\n\n        a += self.sz\n\n        if b == self.N:\n\n            b = self.sz\n\n        b += self.sz\n\n        while a < b:\n\n            if a & 1:\n\n                L = self.func(L, self.seg[a])\n\n                a += 1\n\n            if b & 1:\n\n                b -= 1\n\n                R = self.func(self.seg[b], R)\n\n            a >>= 1\n\n            b >>= 1\n\n        return self.func(L, R)\n\n\n\n\n\ndef main():\n\n    def gcd(a, b):\n\n        while b:\n\n            a, b = b, a % b\n\n        return a\n\n    N = int(readline())\n\n    L = list(map(int, readline().split()))\n\n    seg = SegmentTree(N, gcd, 0)\n\n    for i, n in enumerate(L):\n\n        seg.assign(i, n)\n\n    seg.build()\n\n    ans = 1\n\n    for i in range(N):\n\n        ans = max(ans, gcd(seg.query(0, i), seg.query(i+1, N)))\n\n    print(ans)\n\n\n\n\n\nmain()", "output": "A", "improve_diff": 1.0288976712, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom numpy import *\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\na = int_(bincount(a, [1] * n, n))\n\nprint((pow(2, n // 2, 10 ** 9 + 7) if not a[0] > (n & 1) and all([x == 2 or x == 0 for x in a[1:]]) else 0))\n \nB. mod = int(1e9) + 7\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nlis = [0] * n\n\nfor i in a:\n\n    lis[i] += 1\n\nfor i in range(1,n):\n\n    if lis[i] % 2 == 1:\n\n        print((0))\n\n        exit()\n\n\n\nprint((pow(2, n//2, mod))) \n", "output": "B", "improve_diff": 11.2237412365, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K, S = list(map(int, input().split()))\n\nX = (S + 2) * (S + 1)\n\nif S - K - 1 >= 0:\n\n  X -= 3 * (S - K + 1) * (S - K)\n\nif S - 2 * K - 2 >= 0:\n\n  X += 3 * (S - 2 * K) * (S - 2 * K - 1)\n\n\n\nprint((X // 2)) \nB. K, S = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(K+1):\n\n  for j in range(i, K+1):\n\n    if 0 <= S - i - j <= K:\n\n      if i == j:\n\n        cnt += 1\n\n      else:\n\n        cnt += 2\n\nprint(cnt)", "output": "A", "improve_diff": 1.0397162693, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    LR = [[int(i) for i in input().split()] for _ in range(N)]\n\n\n\n    # \n\n    LR = sorted([(x-l, x+l) for x,l in LR],key=lambda x: x[1])\n\n\n\n    ans = 0\n\n    # \n\n    cur_R = -float(\"inf\")\n\n\n\n    for i in range(N):\n\n        # \n\n        if cur_R > LR[i][0]:\n\n            continue\n\n        ans += 1\n\n        cur_R = LR[i][1]\n\n\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. N = int(eval(input()))\n\nLR = [[int(i) for i in input().split()] for _ in range(N)]\n\n\n\n# \n\nLR = sorted([(x-l, x+l) for x,l in LR],key=lambda x: x[1])\n\n\n\nans = 0\n\n# \n\ncur_R = -float(\"inf\")\n\n\n\nfor i in range(N):\n\n    # \n\n    if cur_R > LR[i][0]:\n\n        continue\n\n    ans += 1\n\n    cur_R = LR[i][1]\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.027941486, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. L,R=list(map(int,input().split()))\n\nr=2018\n\nfor i in range(L,min(R,L+2019)):\n\n    for j in range(L+1,min(R+1,L+2020)):\n\n        r=min(r,(i*j)%2019)\n\nprint(r) \nB. L,R=list(map(int,input().split()))\n\nif R-L>2018:\n\n    print((0))\n\nelse:\n\n    r=2018\n\n    for i in range(L,min(R,L+2019)):\n\n        for j in range(i+1,min(R+1,L+2020)):\n\n            r=min(r,(i*j)%2019)\n\n    print(r)", "output": "A", "improve_diff": 1.0264850273, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\"\"\"\n\nD - Cake 123\n\nhttps://atcoder.jp/contests/abc123/tasks/abc123_d\n\nAC\n\n\"\"\"\n\nimport sys\n\n\n\n\n\nfrom itertools import product\n\n\n\ndef solve(X, Y, Z, K, A, B, C):\n\n    # #2\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n    res = []\n\n    for i, a in enumerate(A, start=1):\n\n        for j, b in enumerate(B, start=1):\n\n            for k, c in enumerate(C, start=1):\n\n                if i*j*k > K:\n\n                    break\n\n                res.append(a+b+c)\n\n    return sorted(res, reverse=True)[:K]\n\n\n\n\n\ndef main(args):\n\n    X, Y, Z, K = map(int, input().split())\n\n    A = [int(a) for a in input().split()]\n\n    B = [int(b) for b in input().split()]\n\n    C = [int(c) for c in input().split()]\n\n    ans = solve(X, Y, Z, K, A, B, C)\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])\n \nB. # -*- coding: utf-8 -*-\n\n\"\"\"\n\nD - Cake 123\n\nhttps://atcoder.jp/contests/abc123/tasks/abc123_d\n\n\n\n\"\"\"\n\nimport sys\n\n\n\n\n\nfrom itertools import product\n\n\n\ndef solve(X, Y, Z, K, A, B, C):\n\n    # TLE\n\n    res_AB = sorted([sum(p) for p in product(A, B)], reverse=True)[:K]\n\n    return sorted([sum(p) for p in product(res_AB, C)], reverse=True)[:K]\n\n\n\n\n\ndef main(args):\n\n    X, Y, Z, K = map(int, input().split())\n\n    A = [int(a) for a in input().split()]\n\n    B = [int(b) for b in input().split()]\n\n    C = [int(c) for c in input().split()]\n\n    ans = solve(X, Y, Z, K, A, B, C)\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])\n", "output": "B", "improve_diff": 1.1875074435, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \"\"\"\n\nauthor : halo2halo\n\ndate : 29, Jan, 2020\n\n\"\"\"\n\n\n\nimport sys\n\n\n\n# import itertools\n\n# import numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\ndef Hershad(n):\n\n    if n == 0:\n\n        return 0\n\n    return n % 10 + Hershad(n // 10)\n\n\n\n\n\nN = int(readline())\n\nprint(('Yes' if N % Hershad(N) == 0 else 'No'))\n \nB. \"\"\"\n\nauthor : halo2halo\n\ndate : 29, Jan, 2020\n\n\"\"\"\n\n\n\nimport sys\n\n\n\n# import itertools\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\ndef Hershad(n):\n\n    if n == 0:\n\n        return 0\n\n    return n % 10 + Hershad(n // 10)\n\n\n\n\n\nN = int(readline())\n\nprint(('Yes' if N % Hershad(N) == 0 else 'No'))\n", "output": "A", "improve_diff": 10.3241020797, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    # divisors.sort()\n\n    return divisors\n\n\n\nn = int(eval(input()))\n\nout = make_divisors(n)\n\nans = []\n\nfor i in out:\n\n    if i == 1:\n\n        continue\n\n    m = n\n\n    while m % i == 0:\n\n        m //= i\n\n    if m == 1 or m % i == 1:\n\n        ans.append(i)\n\nans += make_divisors(n - 1)\n\n# print(set(out))\n\nprint((len(set(ans)) - 1)) \nB. def make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n\n\n    # divisors.sort()\n\n    return divisors\n\n\n\nn = int(eval(input()))\n\ni = 2\n\ncnt = 1\n\ncheck = 0\n\n\n\n# for i in range(2, n + 1):\n\n#     m = n\n\n#     while m % i == 0:\n\n#         m //= i\n\n#     m %= i\n\n#     if m == 1:\n\n#         print(i)\n\n#         cnt += 1\n\n# print(cnt)\n\n# print()\n\n# print()\n\n\n\nout = [n]\n\nwhile i < n: #\n\n    m = n\n\n    if i - m / i > 2:\n\n        break\n\n    while m % i == 0:\n\n        check = 1\n\n        m //= i\n\n\n\n    if (m % i == 1 and check):\n\n        out.append(i)\n\n        cnt += 1\n\n    i += 1\n\n\n\ni = 2\n\nwhile i * i <= n: #\n\n    m = n\n\n    while m % i == 0:\n\n        m //= i\n\n    if m == 1:\n\n        out.append(i)\n\n    i += 1\n\n\n\nout += make_divisors(n - 1)\n\nprint((len(set(out)) - 1))", "output": "A", "improve_diff": 3.3621606287, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. heights = sorted([int(eval(input())) for n in range(10)])\n\nfor idx in range(-1, -4, -1):\n\n    print(heights[idx]) \nB. l = sorted([eval(input()) for x in range(10)], reverse=True)\n\nfor h in l[:3]:\n\n    print(h)", "output": "B", "improve_diff": 1.2021405647, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\n#n,p=map(int,input().split())\n\nhl=list(map(int,input().split()))\n\n#l=[list(map(int,input().split())) for i in range(n)]\n\n#2\n\nmx=hl[0]\n\nans=\"Yes\"\n\nfor i in range(n):\n\n    mx=max(mx,hl[i])\n\n    if hl[i]>=mx-1:\n\n        pass\n\n    else:\n\n        ans=\"No\"\n\n        break\n\nprint(ans)\n \nB. n=int(eval(input()))\n\n#n,m=map(int,input().split())\n\n#t=int(input())\n\nhl=list(map(int,input().split()))\n\n#l=[list(map(int,input().split())) for i in range(n)]\n\n\n\nflag=\"Yes\"\n\n\n\nfor i in range(n-2,-1,-1):\n\n    righth=hl[i+1]\n\n    cur=hl[i]\n\n    if cur<=righth:\n\n        pass\n\n    elif cur==righth+1:\n\n        hl[i]=cur-1\n\n    else:\n\n        flag=\"No\"\n\n        break\n\n\n\nprint(flag)\n\n\n\n\n", "output": "A", "improve_diff": 1.0746124814, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import collections\n\nimport itertools as it\n\nimport math\n\n#import numpy as np\n\n \n\n#  = input()\n\n#  = int(input())\n\nh, a  = list(map(int, input().split()))\n\n#  = list(map(int, input().split()))\n\n#  = [int(input()) for i in range(N)]\n\n#\n\n# c = collections.Counter()\n\nif h%a==0:\n\n\tprint((int(h/a)))\n\nelse:\n\n  \tprint((h//a+1)) \nB. #import collections\n\n#import itertools as it\n\n#import math\n\n#import numpy as np\n\n#import sys \n\n#sys.exit()\n\n\n\n#  = input()\n\n#  = int(input())\n\nh, a  = list(map(int, input().split()))\n\n'''\n\n#  = list(map(int, input().split()))\n\n'''\n\n'''\n\nn = input()\n\na = [int(input()) for i in range(n)]\n\n'''\n\n'''\n\nn,m = map(int, input().split())\n\na = [list(map(int, input().split())) for _ in range(m)]\n\n'''\n\n# c = collections.Counter()\n\n#-------------------------------#\n\n\n\nif h%a==0:\n\n\tprint((int(h/a)))\n\nelse:\n\n  \tprint((h//a+1))", "output": "B", "improve_diff": 1.5448151666, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nn, G = list(map(int, sys.stdin.readline().split()))\n\nG //= 100\n\np = []\n\nt = []\n\nfor i in range(1, n+1):\n\n    pi, ci = list(map(int, sys.stdin.readline().split()))\n\n    p.append(pi)\n\n    t.append(i * pi + ci // 100)\n\n\n\ndef main():\n\n    res = sum(p)\n\n    for i in range(2 ** n - 1):\n\n        s = 0\n\n        cnt = 0\n\n        for j in range(n):\n\n            if i >> j & 1:\n\n                s += t[j]\n\n                cnt += p[j]\n\n            else:\n\n                m = j + 1\n\n        if s < G:\n\n            tmp = (G - s + m - 1) // m\n\n            if tmp < p[m-1]:\n\n                cnt += tmp\n\n            else:\n\n                continue\n\n        res = min(res, cnt)\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans) \nB. import sys\n\nimport numpy as np\n\n\n\nI = np.array(sys.stdin.read().split(), dtype=np.int64)\n\nn, G = I[:2]\n\nG //= 100\n\np, c = I[2:].reshape(-1, 2).T\n\nc //= 100\n\n\n\ndef main():\n\n    v = np.arange(1, n+1)\n\n    t = v * p + c\n\n    combs = np.arange(2 ** n - 1)[:, None] >> np.arange(n) & 1\n\n    res = p.sum()\n\n    for comb in combs:\n\n        s = t[comb == 1].sum()\n\n        cnt = p[comb == 1].sum()\n\n        if s - G < 0:\n\n            m = np.amax(v[comb == 0])\n\n            tmp = (G - s + m - 1) // m\n\n            if tmp < p[m-1]:\n\n                cnt += tmp\n\n            else:\n\n                continue\n\n        res = min(res, cnt)\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "output": "A", "improve_diff": 10.8250490928, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b=list(map(str,input().split()))\n\na=int(a)\n\nb=int(float(b)*1000)\n\nprint((a*b//1000)) \nB. from decimal import Decimal\n\nimport math\n\n\n\na,b=list(map(str,input().split()))\n\na=int(a)\n\nb=Decimal(b)\n\nx = math.floor(a*b)\n\nprint((int(x)))", "output": "A", "improve_diff": 2.2449463856, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. mod = 10 ** 9 + 7\n\n\n\nN, *X = list(map(int, open(0).read().split()))\n\n\n\nstack = []\n\nans = 1\n\nfor x in X:\n\n    stack.append(x)\n\n    if x < 2 * len(stack) - 1:\n\n        ans = (ans * len(stack)) % mod\n\n        stack.pop()\n\n    else:\n\n        ans = (ans * len(stack)) % mod\n\n\n\nprint(ans)\n \nB. mod = 10 ** 9 + 7\n\n\n\nN, *X = list(map(int, open(0).read().split()))\n\n\n\ns = 0\n\nans = 1\n\nfor x in X:\n\n    if x < 2 * s + 1:\n\n        ans *= (s + 1)\n\n    else:\n\n        s += 1\n\n        ans *= s\n\n    ans %= mod\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.0385745316, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def bubble_sort(A):\n\n    count = 0\n\n    for i in reversed(list(range(len(A)))):\n\n        for j in range(i):\n\n            if A[j] > A[j+1]:\n\n                temp = A[j]\n\n                A[j] = A[j+1]\n\n                A[j+1] = temp\n\n                count += 1\n\n    return count\n\n\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\ncount = bubble_sort(A)\n\nprint((\" \".join(map(str,A))))\n\nprint(count) \nB. def bubble_sort(A, N):\n\n\tcount = 0\n\n\tflag = 1\n\n\twhile flag:\n\n\t\tflag = 0\n\n\t\tfor i in range(N-1, 0, -1):\n\n\t\t\tif A[i] < A[i-1]:\n\n\t\t\t\ttemp = A[i]\n\n\t\t\t\tA[i] = A[i-1]\n\n\t\t\t\tA[i-1] = temp\n\n\t\t\t\tcount += 1\n\n\t\t\t\tflag = 1\n\n\n\n\treturn A, count\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA, count = bubble_sort(A, N)\n\nprint((' '.join(map(str, A))))\n\nprint(count)\n", "output": "A", "improve_diff": 1.0687710249, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # D - 2017-like Number\n\nfrom itertools import accumulate\n\nfrom math import sqrt\n\n\n\n\n\ndef get_primes(n: int) -> set:\n\n    \"\"\"Return a list of prime numbers < n in O(N).\"\"\"\n\n    if n < 2:\n\n        return set()\n\n\n\n    sieve = [1] * n\n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n\n        if sieve[i]:\n\n            sieve[i * i:: 2 * i] = [0] * ((n - i ** 2 - 1) // (2 * i) + 1)\n\n    return {2} | {i for i in range(3, n, 2) if sieve[i]}\n\n\n\n\n\ndef main():\n\n    Q, *LR = list(map(int, open(0).read().split()))\n\n    primes = get_primes(10 ** 5 + 1)\n\n    is_2017_like = [1 if i in primes and (i + 1) // 2 in primes else 0 for i in range(10 ** 5 + 1)]\n\n    cumsum = tuple(accumulate(is_2017_like))\n\n    ans = []\n\n    for l, r in zip(*[iter(LR)] * 2):\n\n        ans.append(cumsum[r] - cumsum[l - 1])\n\n    print((\"\\n\".join(map(str, ans))))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. # ABC084D - 2017-like Number\n\nfrom bisect import bisect_left as bsl, bisect_right as bsr\n\n\n\n\n\ndef get_primes(n: int) -> list:\n\n    # return a list of primes <= n\n\n    sieve = [1] * n\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n\n        if sieve[i]:\n\n            sieve[i * i :: 2 * i] = [0] * ((n - i * i - 1) // (2 * i) + 1)\n\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\n\n\n\n\ndef main():\n\n    Q, *LR = map(int, open(0).read().split())\n\n    P = get_primes(10 ** 5 + 1)\n\n    S = set(P)\n\n    sel = [p for p in P if (p + 1) // 2 in S]  # 2017-like primes (selected P)\n\n    # the number of 2017-like primes b/w l, r -> bisect[r] - bisect[l]\n\n    ans = [bsr(sel, r) - bsl(sel, l) for l, r in zip(*[iter(LR)] * 2)]\n\n    print(*ans, sep=\"\\n\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "B", "improve_diff": 1.3986376706, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn,m,x=list(map(int,input().split()))\n\nca=[list(map(int,input().split())) for _ in range(n)]\n\na=[np.array(i[1:]) for i in ca]\n\nc=[i[0] for i in ca]\n\nxx=np.array([x]*m)\n\nans=pow(10,9)\n\n\n\nfor i in range(2**n):\n\n  count=0\n\n  aa=np.array([0]*m)\n\n  for j in range(n):\n\n    if ((i >> j) & 1):\n\n      aa+=a[j]\n\n      count+=c[j]  \n\n    if all(i>=x for i in aa):\n\n      ans=min(ans,count)\n\nprint((ans if ans<pow(10,9) else -1)) \nB. from itertools import product\n\nimport numpy as np\n\nn,m,x=list(map(int,input().split()))\n\nca=[list(map(int,input().split())) for _ in range(n)]\n\na,c=np.array([i[1:] for i in ca]).T,np.array([i[0] for i in ca])\n\nans=pow(10,9)\n\nfor i in product([0,1],repeat=n):\n\n  i=np.array(i)\n\n  if all(np.dot(a,i)>=x):\n\n    s=np.dot(i,c)\n\n    ans=s if s<ans else ans\n\nprint((ans if ans<pow(10,9) else -1))", "output": "B", "improve_diff": 1.2691632346, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X, Y = list(map(int, input().split()))\n\nt = X\n\nans = 0\n\nwhile t <= Y:\n\n    t *= 2\n\n    ans += 1\n\nprint(ans) \nB. X, Y = list(map(int,input().split()))\n\n\n\nans = 0\n\nwhile X <= Y:\n\n    X *= 2\n\n    ans += 1\n\nprint(ans)\n", "output": "B", "improve_diff": 1.5188536317, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def calc_median(X):\n\n    #\n\n    Xl = len(X)\n\n    if Xl % 2:\n\n        ret = X[(Xl + 1) // 2 - 1]\n\n    else:\n\n        ret = (X[Xl // 2 - 1] + X[Xl // 2]) / 2\n\n\n\n    return ret\n\n\n\n\n\nN = int(eval(input()))\n\nAB = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nA = [AB[i][0] for i in range(N)]\n\nB = [AB[i][1] for i in range(N)]\n\n\n\nA.sort()\n\nB.sort()\n\n\n\nAM = calc_median(A)\n\nBM = calc_median(B)\n\n\n\nif N % 2:\n\n    ans = BM - AM + 1\n\nelse:\n\n    ans = int((BM - AM) * 2 + 1)\n\n\n\nprint(ans)\n \nB. def calc_median(X):\n\n    #\n\n    Xl = len(X)\n\n    if Xl % 2:\n\n        ret = X[(Xl + 1) // 2 - 1]\n\n    else:\n\n        ret = (X[Xl // 2 - 1] + X[Xl // 2]) / 2\n\n\n\n    return ret\n\n\n\n\n\nN, *AB = list(map(int, open(0).read().split()))\n\n\n\nA = sorted(AB[::2])\n\nB = sorted(AB[1::2])\n\n\n\nAM = calc_median(A)\n\nBM = calc_median(B)\n\n\n\nif N % 2:\n\n    ans = BM - AM + 1\n\nelse:\n\n    ans = int((BM - AM) * 2 + 1)\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 1.3136610443, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from operator import itemgetter\n\n\n\nn, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\n\n\nab.sort(key=itemgetter(0))\n\n\n\nresult = 0\n\nfor e in ab:\n\n  count = min(m, e[1])\n\n  result += e[0] * count\n\n  m = max(m-count, 0)\n\nprint(result) \nB. n, m = [int(x) for x in input().split()]\n\n\n\na = sorted([[int(x) for x in input().split()] for _ in range(n)], key=lambda x: x[0])\n\n\n\nresult = 0\n\nfor x in a:\n\n  cnt = min(m, x[1])\n\n  result += x[0] * cnt\n\n  m -= cnt\n\nprint(result)", "output": "B", "improve_diff": 1.1649689275, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. max_n500 = int(eval(input()))\n\nmax_n100 = int(eval(input()))\n\nmax_n50 = int(eval(input()))\n\namount = int(eval(input()))\n\n\n\ncount = 0\n\nfor n500 in range(max_n500 + 1):\n\n    for n100 in range(max_n100 + 1):\n\n        for n50 in range(max_n50 + 1):\n\n            if n500 * 500 + n100 * 100 + n50 * 50 == amount:\n\n                count += 1\n\nprint(count)\n \nB. max_n500 = int(eval(input()))\n\nmax_n100 = int(eval(input()))\n\nmax_n50 = int(eval(input()))\n\ntarget_amount = int(eval(input()))\n\n\n\ncount = 0\n\nfor n500 in range(max_n500 + 1):\n\n    amount_500 = n500 * 500\n\n    if amount_500 > target_amount:\n\n        break\n\n    for n100 in range(max_n100 + 1):\n\n        amount_100 = n100 * 100\n\n        amount_500_100 = amount_500 + amount_100\n\n        if amount_500_100 > target_amount:\n\n            break\n\n        for n50 in range(max_n50 + 1):\n\n            amount_50 = n50 * 50\n\n            current_amount = amount_500_100 + amount_50\n\n            if current_amount == target_amount:\n\n                count += 1\n\nprint(count)\n", "output": "B", "improve_diff": 1.1832908452, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def getN():\n\n    return int(eval(input()))\n\n\n\n\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef getList():\n\n    return list(map(int, input().split()))\n\n\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nimport math\n\nimport copy\n\nfrom bisect import bisect_left, bisect_right\n\nfrom heapq import *\n\nimport sys\n\n\n\n# sys.setrecursionlimit(1000000)\n\nINF = 10 ** 17\n\nMOD = 1000000007\n\n\n\nfrom fractions import *\n\n\n\n\n\ndef inverse(f):\n\n    # return Fraction(f.denominator,f.numerator)\n\n    return 1 / f\n\n\n\n\n\ndef combmod(n, k, mod=MOD):\n\n    ret = 1\n\n    for i in range(n - k + 1, n + 1):\n\n        ret *= i\n\n        ret %= mod\n\n\n\n    for i in range(1, k + 1):\n\n        ret *= pow(i, mod - 2, mod)\n\n        ret %= mod\n\n\n\n    return ret\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef yaku(n):\n\n    res = []\n\n    for i in range(2, int(math.sqrt(n)) + 2):\n\n        tmp = 0\n\n        while(True):\n\n            if n % i == 0:\n\n                tmp += 1\n\n                n //= i\n\n            else:\n\n                break\n\n        if tmp != 0:\n\n            res.append((tmp, i))\n\n    if n != 1:\n\n        res.append((1, n))\n\n    return res\n\n\n\ndef solve():\n\n    n = getN()\n\n    acc = [0]\n\n    tmp = 0\n\n    for i in range(1, 10**6):\n\n        tmp += i\n\n        acc.append(tmp)\n\n\n\n    res = yaku(n)\n\n    ans = 0\n\n    for y in res:\n\n        ans += bisect_right(acc, y[0]) - 1\n\n    # print(res)\n\n    print(ans)\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\n\n\nfrom collections import defaultdict, deque\n\nfrom sys import exit\n\nimport math\n\nimport copy\n\nfrom bisect import bisect_left, bisect_right\n\nfrom heapq import *\n\nimport sys\n\n# sys.setrecursionlimit(1000000)\n\nINF = 10 ** 17\n\nMOD = 1000000007\n\n\n\nfrom fractions import *\n\ndef inverse(f):\n\n    # return Fraction(f.denominator,f.numerator)\n\n    return 1/f\n\n\n\n\n\ndef combmod(n, k, mod=MOD):\n\n    ret = 1\n\n    for i in range(n - k + 1, n + 1):\n\n        ret *= i\n\n        ret %= mod\n\n\n\n    for i in range(1, k + 1):\n\n        ret *= pow(i, mod - 2, mod)\n\n        ret %= mod\n\n\n\n    return ret\n\ndef bunsu(n):\n\n    ret = []\n\n    for i in range(2, int(math.sqrt(n)) + 1):\n\n        if n % i == 0:\n\n            tmp = 0\n\n            while(True):\n\n                if n % i == 0:\n\n                    tmp += 1\n\n                    n //= i\n\n                else:\n\n                    break\n\n            ret.append((i, tmp))\n\n\n\n    ret.append((n, 1))\n\n    return ret\n\n\n\ndef solve():\n\n    n = getN()\n\n    bun = bunsu(n)\n\n    # print(bun)\n\n    acc = []\n\n    tmp = 0\n\n    for i in range(10000):\n\n        tmp += i\n\n        acc.append(tmp)\n\n    ans = 0\n\n    for b, cnt in bun:\n\n        if b == 1:\n\n            continue\n\n        ans += bisect_right(acc, cnt) - 1\n\n    print(ans)\n\ndef main():\n\n    # n = getN()\n\n    # for _ in range(n):\n\n    solve()\n\nif __name__ == \"__main__\":\n\n    solve()\n", "output": "B", "improve_diff": 2.9629080231, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A,B = input().split()\n\nA = int(A)\n\nB1,B2 = list(map(int,B.split('.')))\n\nans = A*(B1*100+B2)\n\nprint((int(ans//100))) \nB. import math\n\nfrom decimal import Decimal\n\nA,B = list(map(Decimal,input().split()))\n\nprint((math.floor(A*B)))", "output": "A", "improve_diff": 1.7811127517, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. q = int(eval(input()))\n\nQ = 10**5+1\n\nis_prime = [1] * (Q+1)\n\nis_prime[0],is_prime[1] = 0,0\n\nfor i in range(2,int(Q*0.5)+1):\n\n    if is_prime[i]:\n\n        product = i*2\n\n        while product <= Q:\n\n            is_prime[product] = 0\n\n            product += i\n\nis_2017_like = [0] * (Q+1)\n\nis_2017_like_csum = [0] * (Q+1)\n\nnow = 0\n\nfor i in range(2,Q+1):\n\n    if is_prime[i] and is_prime[(i+1)//2]:\n\n        is_2017_like[i] = 1\n\n        now += 1\n\n    is_2017_like_csum[i] = now\n\nans_ls = [0] * q\n\nfor i in range(q):\n\n    l,r = list(map(int,input().split()))\n\n    if l >= 1:\n\n        ans_ls[i] = is_2017_like_csum[r] - is_2017_like_csum[l-1]\n\n    else:\n\n        ans_ls[i] = is_2017_like_csum[r]\n\nfor i in range(q):\n\n    print((ans_ls[i]))\n \nB. q = int(eval(input()))\n\n\n\ndef primes(n):\n\n    is_prime = [True] * (n+1)\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n    for i in range(2,int(n**0.5) + 1):\n\n        # false\n\n        if not is_prime[i]:\n\n            continue\n\n        for j in range(i*2, n+1, i):\n\n            is_prime[j] = False\n\n    return is_prime\n\nprime_ls = primes(10**5)\n\n\n\ncsum = [0] * (10**5)\n\nfor i in range(1,10**5):\n\n    if prime_ls[i]:\n\n        if prime_ls[(i+1) // 2]:\n\n            csum[i] = csum[i-1] + 1\n\n        else:\n\n            csum[i] = csum[i-1]\n\n    else:\n\n        csum[i] = csum[i-1]\n\n\n\nans_ls = [0] * q\n\nfor i in range(q):\n\n    l,r = list(map(int,input().split()))\n\n    ans_ls[i] = csum[r] - csum[l-1]\n\nfor ans in ans_ls:\n\n    print(ans)", "output": "B", "improve_diff": 1.979991686, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. lista=[3,5,7]\n\ncount=0\n\nlim=int(eval(input()))\n\nwhile True:\n\n    t=lista.pop(0)\n\n    if t>lim:\n\n        break\n\n    c=list(str(t))\n\n    if c.count(\"3\") and c.count(\"5\") and c.count(\"7\"):\n\n        count+=1\n\n    lista.append(10*t+3)\n\n    lista.append(10*t+5)\n\n    lista.append(10*t+7)\n\nprint(count) \nB. from collections import deque\n\nlista=deque([3,5,7])\n\ncount=0\n\nlim=int(eval(input()))\n\nwhile True:\n\n    t=lista.popleft()\n\n    if t>lim:\n\n        break\n\n    c=list(str(t))\n\n    if c.count(\"3\") and c.count(\"5\") and c.count(\"7\"):\n\n        count+=1\n\n    lista.append(10*t+3)\n\n    lista.append(10*t+5)\n\n    lista.append(10*t+7)\n\nprint(count)", "output": "B", "improve_diff": 3.4118992214, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n\n\ndef solve():\n\n    readline = sys.stdin.buffer.readline\n\n    mod = 10 ** 9 + 7\n\n    a, b, c = list(map(int, readline().split()))\n\n    if a == b == c:\n\n        if a == b == c == 1:\n\n            print((0))\n\n        else:\n\n            print((-1))\n\n    else:\n\n        cnt = 0\n\n        while True:\n\n            if a % 2 == b % 2 == c % 2 == 0:\n\n                cnt += 1\n\n                a, b, c = (b + c) // 2, (a + c) // 2, (a + b) // 2\n\n            else:\n\n                print(cnt)\n\n                exit()\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n \nB. import sys\n\n\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    mod = 10 ** 9 + 7\n\n    a, b, c = list(map(int, input().rstrip('\\n').split()))\n\n    if a == b == c:\n\n        if a == b == c == 1:\n\n            print((0))\n\n        else:\n\n            print((-1))\n\n    else:\n\n        if a % 2 == 0 and b % 2 == 0 and c % 2 == 0:\n\n            cnt = 0\n\n            while True:\n\n                if a % 2 == 0 and b % 2 == 0 and c % 2 == 0:\n\n                    cnt += 1\n\n                    a, b, c = (b + c) // 2, (a + c) // 2, (a + b) // 2\n\n                else:\n\n                    break\n\n            print(cnt)\n\n        else:\n\n            print((0))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "output": "B", "improve_diff": 1.0121219771, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #\n\n#\uff08abc \u21d2cba)\n\n\n\n#\n\nimport sys\n\ninput = sys.stdin.readline\n\nS = input()\n\nS=S.strip(\"\\n\")\n\nQ = int(input())\n\nFQ_dic={}\n\nfor i in range(Q):\n\n    FQ_dic[i] =input().split()\n\n\n\nrev =0\n\nfront =\"\"\n\nback =\"\"\n\n\n\nfor i in range(Q):\n\n   # print(S) \n\n\n\n    if FQ_dic[i][0] ==\"1\": #\n\n                rev +=1\n\n    else:                   #  \n\n        if FQ_dic[i][1]==\"1\":     #= \n\n            if rev %2 ==0:\n\n                front += FQ_dic[i][2]\n\n            else:\n\n                back  += FQ_dic[i][2]  \n\n        else: #                      #=\n\n            if rev %2 ==0:\n\n                back  += FQ_dic[i][2]  \n\n            else:        \n\n                front += FQ_dic[i][2]\n\nfront =front[::-1]\n\nS =front + S + back\n\n\n\nif rev %2 ==0:\n\n    print(*S,sep=\"\")\n\nelse:\n\n    print(*S[::-1],sep=\"\")\n \nB. # deque \n\n\n\n#\n\nfrom collections import deque\n\nimport sys\n\ninput = sys.stdin.readline\n\nS = input().strip()\n\nQ = int(eval(input()))\n\nFQ_dic={}\n\nfor i in range(Q):\n\n    FQ_dic[i] =input().split()\n\n\n\nrev =0 #Flag\n\ndq =deque(S)\n\nfor i in range(Q):\n\n    if FQ_dic[i][0] ==\"1\":\n\n        rev +=1\n\n    else:\n\n        a,b,c =FQ_dic[i]\n\n        if rev %2 ==0 and b ==\"1\"  :\n\n            dq.appendleft(c)\n\n        elif rev %2 ==0 and b ==\"2\":\n\n            dq.append(c)\n\n        elif rev %2 ==1 and b ==\"1\":\n\n            dq.append(c)\n\n        elif rev %2 ==1 and b ==\"2\":\n\n            dq.appendleft(c)\n\nif rev %2 ==1:\n\n    dq.reverse()\n\nans =\"\".join(dq)\n\nprint(ans)", "output": "A", "improve_diff": 1.5477726024, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\n\n\ndef main():\n\n    N = int(input())\n\n\n\n    dp = [0] * (N + 1)\n\n    rt = int(N ** 0.5) + 1\n\n    for i in range(1, rt):\n\n        ii = i ** 2\n\n        for j in range(1, i+1):\n\n            iji = ii + j **2 + i * j\n\n\n\n            if iji + 1 + i + j > N:\n\n                break\n\n            for k in range(1, j+1):\n\n                case = iji + k**2 + i * k + j * k\n\n                l =6\n\n                if i == j or j == k:\n\n                    l = 3\n\n                    if i == k:\n\n                        l = 1\n\n                if case <= N:\n\n                    dp[case] += l\n\n                else:\n\n                    break\n\n\n\n    print(*dp[1:N + 1], sep=\"\\n\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. import sys\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\n\n\ndef main():\n\n    N = int(input())\n\n\n\n    dp = [0] * (N + 1)\n\n    rt = int(N ** 0.5) + 1\n\n    for i in range(1, rt):\n\n        ii = i ** 2\n\n        for j in range(1, rt):\n\n            iji = ii + j **2 + i * j\n\n\n\n            if iji + 1 + i + j > N:\n\n                break\n\n            for k in range(1, rt):\n\n                case = iji + k**2 + i * k + j * k\n\n                if case <= N:\n\n                    dp[case] += 1\n\n                else:\n\n                    break\n\n\n\n    print(*dp[1:N + 1], sep=\"\\n\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "A", "improve_diff": 1.0154965391, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A1,A2,A3 = sorted(map(int,input().split()))\n\nprint((A3-A1)) \nB. A1,A2,A3 = sorted(list(map(int,input().split())))\n\nprint((A3-A1))", "output": "B", "improve_diff": 1.0208022965, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k=list(map(int,input().split()))\n\nans=0\n\nfor i in range(1,n+1):\n\n  tmp=i\n\n  div=1\n\n  while k>tmp:\n\n    tmp=tmp*2\n\n    div*=1/2\n\n  ans+=(1/n)*div\n\nprint(ans) \nB. n,k=list(map(int,input().split()))\n\nans=0\n\nfor i in range(1,n+1):\n\n  tmp=i\n\n  cnt=0\n\n  while k>tmp:\n\n    tmp=tmp*2\n\n    cnt+=1\n\n  ans+=(1/n)*pow(1/2,cnt)\n\nprint(ans)", "output": "A", "improve_diff": 1.1719278994, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from fractions import Fraction\n\n\n\nA,B = input().split()\n\n#A = int(A)\n\n#B = float(B)\n\n\n\nfrom decimal import *\n\n\n\na = Decimal(A)\n\nb = Decimal(B)\n\ngetcontext().prec = 28\n\nans = a * b\n\nprint((int(ans)))\n \nB. import sys\n\nreadline = sys.stdin.readline\n\n\n\nA,B = readline().split()\n\nA = int(A)\n\nB = int(float(B) * 100 + 0.5)\n\n\n\nprint((A * B // 100))", "output": "B", "improve_diff": 2.4482820365, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef dfs(A):\n\n    # \n\n    global ans\n\n    \n\n    # N\n\n    if len(A) == N:\n\n        score = 0\n\n        for a, b, c, d in buff:\n\n            if A[b-1] - A[a-1] == c:\n\n                score += d\n\n        ans = max(ans, score)\n\n        return\n\n    \n\n    A.append(A[-1])\n\n    # \n\n    while A[-1] <= M:\n\n        # \n\n        dfs(A[:])\n\n        A[-1] += 1\n\n\n\n\n\n# main\n\nN, M, Q = list(map(int, input().split()))\n\nbuff = [list(map(int, input().split())) for _ in range(Q)]\n\n\n\nans = 0\n\ndfs([1])\n\n\n\nprint(ans) \nB. import itertools\n\nN, M, Q = list(map(int, input().split()))\n\nbuff = [list(map(int, input().split())) for _ in range(Q)]\n\n\n\nans = 0\n\nfor A in itertools.combinations_with_replacement(list(range(1, M+1)), N):\n\n    score = 0\n\n    for a, b, c, d in buff:\n\n        if A[b-1] - A[a-1] == c:\n\n            score += d\n\n    ans = max(ans, score)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.152868776, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nls = list(map(int,input().split()))\n\ncnt = [0] * (N+1)\n\n\n\nfor i in range(N-1):\n\n    cnt[ls[i]] += 1\n\n    \n\nfor i in range(1,N+1):\n\n    print((cnt[i])) \nB. from collections import Counter\n\nN = int(eval(input()))\n\nList = list(map(int,input().split()))\n\nC = Counter(List)\n\n\n\nfor i in range(1,N):\n\n  if i in list(C.keys()):\n\n    print((C[i]))\n\n  else:\n\n    print((0))\n\nprint((0))", "output": "A", "improve_diff": 1.586482916, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def GCD(a, b):\n\n    return a if b == 0 else GCD(b, a % b)\n\n\n\n\n\nk = int(eval(input()))\n\n\n\nans = 0\n\nfor a in range(1, k + 1):\n\n    for b in range(1, k + 1):\n\n        ab = GCD(a, b)\n\n        if ab == 1:\n\n            ans += k\n\n            continue\n\n        for c in range(1, k + 1):\n\n            ans += GCD(ab, c)\n\n\n\nprint(ans)\n \nB. from math import gcd\n\n\n\nk = int(eval(input()))\n\n\n\nans = 0\n\nfor a in range(1, k + 1):\n\n    for b in range(1, k + 1):\n\n        ab = gcd(a, b)\n\n        for c in range(1, k + 1):\n\n            ans += gcd(ab, c)\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.3742166013, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nans = 10**N - 2*9**N + 8**N\n\nprint((ans%(10**9+7))) \nB. N = int(eval(input()))\n\nMOD = 10**9+7\n\nans = (pow(10, N, MOD) - 2* pow(9, N, MOD) + pow(8, N, MOD))%MOD\n\nprint(ans)", "output": "B", "improve_diff": 9.3288045043, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nl = list(map(int,input().split()))\n\n\n\nfrom itertools import accumulate\n\n\n\ntot=sum(l)\n\nans=2020202020*100000\n\nfor i in list(accumulate(l)):\n\n    ans=min(ans, abs(tot-(i*2)))\n\n\n\nfor i in list(accumulate(l[::-1])):\n\n    ans=min(ans, abs(tot--(i*2)))\n\n\n\nprint(ans)\n \nB. n = int(eval(input()))\n\nl = list(map(int,input().split()))\n\n\n\nfrom itertools import accumulate\n\ncum=list(accumulate(l))\n\n\n\ntot=sum(l)\n\nans=2020202020*100000\n\nfor i in cum:\n\n    ans=min(ans, abs(tot-i*2))\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0302568898, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nn,k=list(map(int,input().split()))\n\nans=0\n\nfor i in range(1,n+1):\n\n    ans+=(1/2)**math.ceil(max(math.log2(k/i),0))\n\nprint((ans/n))\n \nB. n,k=list(map(int,input().split()))\n\nans=0\n\nfor i in range(1,n+1):\n\n\ttmp=1/n\n\n\tcnt=i\n\n\twhile cnt<k:\n\n\t\tcnt*=2\n\n\t\ttmp/=2\n\n\tans+=tmp\n\nprint(ans)\n\n# x", "output": "B", "improve_diff": 1.7286746839, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\ncnt = defaultdict(int)\n\nfor num in a:\n\n    for i in [-1, 0, 1]:\n\n        cnt[num + i] += 1\n\nans = 0\n\nfor i in cnt:\n\n    ans = max(cnt[i], ans)\n\nprint(ans) \nB. n = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = sorted(a)\n\n\n\nli = [[a[0],1]]\n\n\n\nfor i in range(1,n):\n\n  if a[i] != a[i-1]:\n\n    li.append([a[i],1])\n\n  else:\n\n    li[len(li)-1][1]+=1\n\nans = 0\n\nfor i in range(len(li)):\n\n  ans_tmp =li[i][1]\n\n  if 0<=i-1:\n\n    if li[i-1][0]+1  == li[i][0]:\n\n      ans_tmp = ans_tmp +li[i-1][1]\n\n  if i+1<len(li):\n\n    if li[i+1][0]-1  == li[i][0]:\n\n      ans_tmp = ans_tmp +li[i+1][1]\n\n  ans = max(ans,ans_tmp)\n\nprint(ans)", "output": "B", "improve_diff": 1.5258193165, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def d_lunlun_number():\n\n    from collections import deque\n\n    K = int(eval(input()))\n\n\n\n    queue = deque(list(range(1, 10)))\n\n    ans = -1\n\n    for _ in range(K):\n\n        ans = queue.popleft()\n\n        lsd = ans % 10  # least significant digit\n\n        if lsd != 0:\n\n            queue.append(10 * ans + (lsd - 1))\n\n        queue.append(10 * ans + lsd)\n\n        if ans % 10 != 9:\n\n            queue.append(10 * ans + (lsd + 1))\n\n    return ans\n\n\n\nprint((d_lunlun_number())) \nB. def d_lunlun_number():\n\n    import sys\n\n    sys.setrecursionlimit(10**6)\n\n    K = int(eval(input()))\n\n\n\n    ans = []\n\n\n\n    def dfs(num, current, digit_max):\n\n        if current == digit_max:\n\n            ans.append(num)\n\n            return None\n\n        for n in range(10):\n\n            if abs((num % 10) - n) >= 2:\n\n                continue\n\n            dfs(num * 10 + n, current + 1, digit_max)\n\n\n\n    for leading in range(1, 10):\n\n        for d in range(1, 11):\n\n            dfs(leading, 1, d)\n\n    return sorted(ans)[K - 1]\n\n\n\nprint((d_lunlun_number()))", "output": "A", "improve_diff": 5.0010515163, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #https://atcoder.jp/contests/abc065/submissions/5881131\n\nimport sys\n\ninput = sys.stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.par = [i for i in range(n+1)]\n\n        self.rank = [0] * (n+1)\n\n\n\n    def find(self, x):\n\n        if self.par[x] == x:\n\n            return x\n\n        else:\n\n            self.par[x] = self.find(self.par[x])\n\n            return self.par[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n\n            self.par[x] = y\n\n        else:\n\n            self.par[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same_check(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\ndef MST(n, E):\n\n    E = sorted(E, key=lambda x: x[2])\n\n    uf = UnionFind(n)\n\n    ct = 0\n\n    for i,j,cost in E:\n\n      if uf.same_check(i,j):\n\n        continue\n\n      else:\n\n        uf.union(i,j)\n\n        ct += cost\n\n    return ct\n\n  \n\ndef solve():\n\n  N = int(eval(input()))\n\n  X = []\n\n  append=X.append\n\n  for i in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    append((i, x, y))\n\n \n\n  F = []\n\n  append = F.append\n\n  Y = sorted(X, key = lambda x: x[1])\n\n  for i in range(len(Y)-1):\n\n    append((Y[i][0], Y[i+1][0], abs(Y[i+1][1]-Y[i][1])))\n\n \n\n  Y = sorted(X, key = lambda x: x[2])\n\n  for i in range(len(Y)-1):\n\n    append((Y[i][0], Y[i+1][0], abs(Y[i+1][2]-Y[i][2])))\n\n \n\n  print((MST(N, F)))\n\n\n\nsolve() \nB. import heapq\n\nimport sys\n\ninput = sys.stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.par = [i for i in range(n+1)]\n\n        self.rank = [0] * (n+1)\n\n\n\n    def find(self, x):\n\n        if self.par[x] == x:\n\n            return x\n\n        else:\n\n            self.par[x] = self.find(self.par[x])\n\n            return self.par[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n\n            self.par[x] = y\n\n        else:\n\n            self.par[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same_check(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\ndef solve():\n\n  n = int(eval(input()))\n\n  query = []\n\n  xquery = []\n\n  yquery = []\n\n  for i in range(n):\n\n    x,y = (int(i) for i in input().split())\n\n    xquery.append((x,y,i))\n\n    yquery.append((y,x,i))\n\n  xquery = sorted(xquery)\n\n  yquery = sorted(yquery)\n\n  for i in range(n-1):\n\n    tx,ty,place = xquery[i]\n\n    tx2,ty2,place2 = xquery[i+1]\n\n    cost = min(abs(tx2-tx),abs(ty2-ty))\n\n    heapq.heappush(query,(cost,place,place2))\n\n    \n\n    ty,tx,place = yquery[i]\n\n    ty2,tx2,place2 = yquery[i+1]\n\n    cost = min(abs(tx2-tx),abs(ty2-ty))\n\n    heapq.heappush(query,(cost,place,place2))\n\n  ct = 0\n\n  uf = UnionFind(n)\n\n  while len(query) > 0:\n\n    cost,place1,place2 = heapq.heappop(query)\n\n    if uf.same_check(place1,place2):\n\n      continue\n\n    else:\n\n      uf.union(int(place1),int(place2))\n\n      ct += cost\n\n  print(ct)\n\n      \n\n\n\nsolve()", "output": "A", "improve_diff": 1.4587144826, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\na.sort()\n\nb.sort()\n\nc.sort()\n\n\n\nfrom bisect import bisect_left,bisect_right\n\nans = 0\n\nfor i in range(n):\n\n    pos_a = bisect_left(a,b[i])\n\n    pos_c = bisect_right(c,b[i])\n\n    ans += pos_a*(n-pos_c)\n\n\n\nprint(ans) \nB. n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nb=list(map(int,input().split()))\n\nc=list(map(int,input().split()))\n\na.sort()\n\nb.sort()\n\nc.sort()\n\nfrom bisect import bisect_left,bisect_right\n\nans=0\n\nfor i in range(n):\n\n  ida=bisect_left(a,b[i])\n\n  idc=bisect_right(c,b[i])\n\n  ans+=ida*(n-idc)\n\nprint(ans)", "output": "A", "improve_diff": 1.0078218798, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # s\n\ndef make_divisors(n):\n\n    divisors = []\n\n    ret = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            ret.append((i,n//i))\n\n    return ret\n\n\n\nif __name__ == \"__main__\":\n\n    n = int(eval(input()))\n\n    ret = make_divisors(n)\n\n    # print(ret)\n\n    ans = 10**18\n\n    for a,b in ret:\n\n        ans = min(a+b, ans)\n\n    print((ans-2)) \nB. N = int(eval(input()))\n\nsqN = int(N**0.5)+1\n\nfor i in range(sqN,0,-1):\n\n    if N % i == 0:\n\n        ans = i+N//i\n\n        break\n\n\n\nprint((ans-2))", "output": "A", "improve_diff": 1.0627758799, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = [[] for _ in range(M + 1)]\n\n\n\nfor n in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if a > M:\n\n        continue\n\n    AB[a].append(0-b)\n\n\n\nearn = 0\n\nq = []\n\n\n\nfor m in range(1, M + 1):\n\n\n\n    for job in AB[m]:\n\n        heapq.heappush(q, job)\n\n\n\n    if q != []:\n\n        earn += heapq.heappop(q)\n\n\n\nprint((0-earn))\n \nB. import queue\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = [[] for _ in range(M + 1)]\n\n\n\nfor n in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if a > M:\n\n        continue\n\n    AB[a].append(0-b)\n\n\n\nearn = 0\n\nq = queue.PriorityQueue()\n\n\n\nfor m in range(1, M + 1):\n\n\n\n    for job in AB[m]:\n\n        q.put(job)\n\n\n\n    if not q.empty():\n\n        earn += q.get()\n\n\n\nprint((0-earn))\n", "output": "A", "improve_diff": 1.3558929684, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import factorial\n\nn,m=list(map(int,input().split()))\n\nl=10**9+7\n\nif abs(n-m)>1:\n\n  print((0))\n\n  exit()\n\nif abs(n-m)==1:\n\n  print(((factorial(n)*factorial(m))%l))\n\nelse:\n\n  print((((factorial(n)**2)*2)%l)) \nB. import math\n\nn, m = list(map(int, input().split()))\n\n\n\nif abs(n-m)>1:\n\n  print((0))\n\nelif n-m==1:\n\n  print((int((math.factorial(n)*math.factorial(m))%(10**9+7))))\n\nelif m-n==1:\n\n  print((int((math.factorial(m)*math.factorial(n))%(10**9+7))))\n\nelif n==m:\n\n  print((int((math.factorial(n)*math.factorial(m)*2)%(10**9+7))))", "output": "B", "improve_diff": 1.0109718451, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def root(x):\n\n    if par[x] == x:\n\n        return x\n\n    par[x] = root(par[x])\n\n    return par[x]\n\n\n\ndef same(x, y):\n\n    return root(x) == root(y)\n\n\n\ndef unite(x, y):\n\n    x = root(x)\n\n    y = root(y)\n\n    par[x] = y\n\n\n\nv,e = list(map(int, input().split()))\n\nadj = [list(map(int, input().split())) for i in range(e)]\n\nadj.sort(key = lambda x:x[2])\n\npar = [i for i in range(v)]\n\nsum = 0\n\n\n\nfor i,j,k in adj:\n\n    if not same(i, j):\n\n        sum += k\n\n        unite(i, j)\n\nprint(sum)\n \nB. v,e = list(map(int, input().split()))\n\nadj = [list(map(int, input().split())) for i in range(e)]\n\nadj.sort(key = lambda x:x[2])\n\ngroup = [[i] for i in range(v)]\n\nkey = [i for i in range(v)]\n\nsum = 0\n\nfor i,j,k in adj:\n\n    if key[i] != key[j]:\n\n        h = key[j]\n\n        group[key[i]] += group[h]\n\n        sum += k\n\n        for t in group[h]:\n\n            key[t] = key[i]\n\n        group[h] = []\n\n        if len(group[key[i]]) == v:\n\n            break\n\nprint(sum)\n", "output": "B", "improve_diff": 1.0184268146, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,A,B,C=list(map(int,input().split()))\n\nl=[int(eval(input())) for i in range(N)]\n\ninf=10**9\n\ndef dfs(cur,a,b,c):\n\n  if cur==N:\n\n    return abs(a-A)+abs(b-B)+abs(c-C)-30 if min(a,b,c)>0 else inf\n\n  ret0 = dfs(cur+1,a,b,c)\n\n  ret1 = dfs(cur+1,a+l[cur],b,c)+10\n\n  ret2 = dfs(cur+1,a,b+l[cur],c)+10\n\n  ret3 = dfs(cur+1,a,b,c+l[cur])+10\n\n  return min(ret0,ret1,ret2,ret3)\n\nprint((dfs(0,0,0,0))) \nB. import itertools\n\nn,a,b,c=(list(map(int,input().split())))\n\nl=[int(eval(input())) for i in range(n)]\n\nans=10**9\n\nfor k in itertools.product(list(range(4)),repeat=n):\n\n    A=[[] for i in range(4)]\n\n    for i in range(n):\n\n        A[k[i]]+=[l[i]]\n\n    if A[1] and A[2] and A[3]:\n\n        tmp=10*(n-len(A[0])-3)\n\n        tmp+=abs(a-sum(A[1]))\n\n        tmp+=abs(b-sum(A[2]))\n\n        tmp+=abs(c-sum(A[3]))\n\n        ans=min(tmp,ans)\n\nprint(ans)", "output": "A", "improve_diff": 3.6442644798, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # dp\n\nN,M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nA.sort(reverse=True)\n\nf = [-1, 2,5,5,4,5,6,3,7,6] # 1-indexed\n\n\n\n# dp[i]: i(int)\n\ndp = [-float('inf')]*(N+1)\n\ndp[0] = 0\n\nfor i in range(N+1):\n\n    nxt = dp[i]\n\n    for aj in A:\n\n        if i-f[aj]<0: continue\n\n        nxt = max(nxt, \n\n                  dp[i-f[aj]] + 1)\n\n    dp[i] = nxt\n\n    #print(dp)\n\n#print(dp[N])\n\nketa = dp[N]\n\nans = \"\"\n\nmatchs = N\n\n# \n\nwhile keta>0:\n\n    for aj in A:\n\n        if matchs-f[aj] < 0: continue\n\n        if dp[matchs-f[aj]] == keta-1:\n\n            ans += str(aj)\n\n            matchs -= f[aj]\n\n            keta -= 1\n\n            break\n\nprint(ans)\n \nB. # \uff11\n\nN,M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nf = [-1, 2,5,5,4,5,6,3,7,6] # 1-indexed\n\n\n\n# dp[i]: i(str)\n\ndp = [None]*(N+1)\n\ndp[0] = \"\"\n\n\n\n# str\n\ndef max_str(s1:str, s2:str)->str:\n\n    \"\"\"return bigger one\"\"\"\n\n    l1, l2 = len(s1), len(s2)\n\n    if l1 != l2:\n\n        return s1 if l1>l2 else s2\n\n    if l1 == l2: \n\n        return s1 if s1>s2 else s2\n\n    \n\nfor i in range(2, N+1):\n\n    nxt = \"\"\n\n    for aj in A:\n\n        # \uff0ci\n\n        if i-f[aj]<0 or dp[i-f[aj]]==None: continue\n\n        nxt = max_str(nxt, \n\n                      dp[i-f[aj]]+str(aj))\n\n    if nxt!=\"\":\n\n        dp[i] = nxt\n\n    #print(dp)\n\nprint((dp[N]))\n", "output": "A", "improve_diff": 1.0539656487, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python3\n\nimport sys\n\nimport heapq\n\n\n\ndef solve(X: int, Y: int, Z: int, K: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n\n    A = sorted(A,reverse = True)\n\n    B = sorted(B,reverse = True)\n\n    C = sorted(C,reverse = True)\n\n\n\n    d = []\n\n    heapq.heappush(d, (-(A[0]+B[0]+C[0]), 0, 0, 0)) # heapq\n\n    ijk_set = set((0,0,0))\n\n\n\n    for _ in range(K):\n\n        tmp, i, j, k = heapq.heappop(d)\n\n        print((-tmp))\n\n        if (i+1,j,k) not in ijk_set and i+1 <= X-1:\n\n            heapq.heappush(d, (-(A[i+1]+B[j]+C[k]), i+1, j, k))\n\n            ijk_set.add((i+1,j,k))\n\n        if (i,j+1,k) not in ijk_set and j+1 <= Y-1:\n\n            heapq.heappush(d, (-(A[i]+B[j+1]+C[k]), i, j+1, k))\n\n            ijk_set.add((i,j+1,k))\n\n        if (i,j,k+1) not in ijk_set and k+1 <= Z-1:\n\n            heapq.heappush(d, (-(A[i]+B[j]+C[k+1]), i, j, k+1))\n\n            ijk_set.add((i,j,k+1))\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    Z = int(next(tokens))  # type: int\n\n    K = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(X)]  # type: \"List[int]\"\n\n    B = [int(next(tokens)) for _ in range(Y)]  # type: \"List[int]\"\n\n    C = [int(next(tokens)) for _ in range(Z)]  # type: \"List[int]\"\n\n    solve(X, Y, Z, K, A, B, C)\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. #!/usr/bin/env python3\n\nimport sys\n\n\n\n\n\ndef solve(X: int, Y: int, Z: int, K: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n\n    AB = []\n\n\n\n    for i in range(X):\n\n        for j in range(Y):\n\n            AB.append(A[i]+B[j])\n\n    AB.sort(reverse=True)\n\n    AB = AB[:K]\n\n\n\n    ABC = []\n\n    for k in range(Z):\n\n        for ab_index in range(len(AB)):\n\n            ABC.append(C[k]+AB[ab_index])\n\n\n\n    ABC.sort(reverse=True)\n\n    ABC = ABC[:K]\n\n    for i in range(len(ABC)):\n\n        print((ABC[i]))\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    Z = int(next(tokens))  # type: int\n\n    K = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(X)]  # type: \"List[int]\"\n\n    B = [int(next(tokens)) for _ in range(Y)]  # type: \"List[int]\"\n\n    C = [int(next(tokens)) for _ in range(Z)]  # type: \"List[int]\"\n\n    solve(X, Y, Z, K, A, B, C)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.3968217594, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \"\"\"\n\n~~ Author : Bhaskar\n\n~~ Dated : 13~06~2020\n\n\"\"\"\n\n\n\nimport sys\n\nfrom bisect import *\n\nfrom math import floor, sqrt, ceil, factorial as F, gcd, pi\n\nfrom itertools import chain, combinations, permutations, accumulate\n\nfrom collections import Counter, defaultdict, OrderedDict, deque\n\n\n\nINT_MAX = sys.maxsize\n\nINT_MIN = -(sys.maxsize) - 1\n\nmod = 1000000007\n\nch = \"abcdefghijklmnopqrstuvwxyz\"\n\nlcm = lambda a, b: (a * b) // gcd(a, b)\n\nsetbit = lambda x: bin(x)[2:].count(\"1\")\n\nINT = lambda type: type(sys.stdin.readline()) if type in [int, float] else type(sys.stdin.readline()).replace(\"\\n\", \"\")\n\nARRAY = lambda type: list(map(type, sys.stdin.readline().split()))\n\nNUMS = lambda type: list(map(type, sys.stdin.readline().split()))\n\n\n\n\n\ndef solve():\n\n\n\n    n = INT(int)\n\n    a = ARRAY(int)\n\n    if 0 in a:\n\n        print((0))\n\n    else:\n\n        p = 1\n\n        ok = False\n\n        for i in a:\n\n            p *= i\n\n            if p > 10**18:\n\n                ok = True\n\n                break\n\n        print((p if not ok else -1))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # try:\n\n    #     sys.stdin = open(\"input.txt\", \"r\")\n\n    # except:\n\n    #     pass\n\n    solve()\n \nB. \"\"\"\n\n~~ Author : Bhaskar\n\n~~ Dated : 31~05~2020\n\n\"\"\"\n\n\n\nimport sys\n\nfrom bisect import *\n\nfrom math import floor,sqrt,ceil,factorial as F,gcd,pi\n\nfrom itertools import chain,combinations,permutations,accumulate\n\nfrom collections import Counter,defaultdict,OrderedDict,deque\n\nfrom array import array\n\nINT_MAX = sys.maxsize\n\nINT_MIN = -(sys.maxsize)-1\n\nmod = 10**18\n\nlcm = lambda a,b : (a*b)//gcd(a,b)\n\nsetbit = lambda x : bin(x)[2:].count(\"1\")\n\n\n\ndef solve():\n\n    n = int(sys.stdin.readline())\n\n    a = list(map(int,sys.stdin.readline().split()))\n\n    ans =  1\n\n    flag = False\n\n    for i in a:\n\n        ans *= i\n\n        # print(ans)\n\n        if ans > mod:\n\n            flag = True\n\n            break\n\n    if 0 in a:\n\n        print((0))\n\n    else:\n\n        if not flag:\n\n            print(ans)\n\n        else:\n\n            print((-1))\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "output": "A", "improve_diff": 1.0548378191, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. h,w,d=list(map(int,input().split()))\n\na=[list(map(int,input().split())) for i in range(h)]\n\n\n\ndef find_element(k):\n\n    global h,w,a\n\n    for i in range(h):\n\n        for j in range(w):\n\n            if a[i][j]==k:\n\n                return (i,j)\n\n\n\ndef make_distance(S,T):\n\n    return abs(S[0]-T[0])+abs(S[1]-T[1])\n\n\n\nx1=[]\n\nx2=[]\n\nfor i in range(1,d+1):\n\n    l=(h*w-i)//d\n\n    x1.append([0]*(l+1))\n\n    x2.append([[0,0]for i in range(l+1)])\n\n\n\nfor i in range(h):\n\n    for j in range(w):\n\n        p=a[i][j]%d\n\n        if p==0:\n\n            p=d-1\n\n        else:\n\n            p-=1\n\n        l=(a[i][j]-(p+1))//d\n\n        x2[p][l]=[i,j]\n\n\n\n\n\nfor i in range(1,d+1):\n\n    l=len(x1[i-1])\n\n    for j in range(l-1):\n\n        x1[i-1][j+1]=x1[i-1][j]+make_distance(x2[i-1][j],x2[i-1][j+1])\n\n\n\nq=int(eval(input()))\n\nfor i in range(q):\n\n    l,r=list(map(int,input().split()))\n\n    p=l%d\n\n    if p==0:\n\n        v1=l//d-1\n\n        v2=r//d-1\n\n        print((x1[d-1][v2]-x1[d-1][v1]))\n\n    else:\n\n        v1=l//d\n\n        v2=r//d\n\n        print((x1[p-1][v2]-x1[p-1][v1]))\n\n#print(x)\n \nB. from math import ceil\n\nh,w,d=list(map(int,input().split()))\n\nx=ceil((h*w)/d)\n\nnum=[[[-1,-1] for j in range(x)] for i in range(d)]#(1\u21920)\n\nmp=[[0]*x for i in range(d)]\n\na=[list(map(int,input().split())) for i in range(h)]\n\nfor i in range(h):\n\n    for j in range(w):\n\n        k,l=a[i][j]%d,a[i][j]//d\n\n        if k==0:\n\n            num[d-1][l-1]=[i,j]\n\n        else:\n\n            num[k-1][l]=[i,j]\n\nfor i in range(d):\n\n    for j in range(x):\n\n        if j!=x-1:\n\n            if num[i][j+1]!=[-1,-1]:\n\n                mp[i][j+1]+=(mp[i][j]+abs(num[i][j+1][0]-num[i][j][0])+abs(num[i][j+1][1]-num[i][j][1]))\n\n            else:\n\n                break\n\nq=int(eval(input()))\n\nfor i in range(q):\n\n    l,r=list(map(int,input().split()))\n\n    if l%d!=0:\n\n        e,f=l//d,r//d\n\n    else:\n\n        e,f=l//d-1,r//d-1\n\n    g= d-1 if l%d==0 else l%d-1\n\n    if e==0:\n\n        print((mp[g][f]))\n\n    else:\n\n        print((mp[g][f]-mp[g][e]))\n", "output": "A", "improve_diff": 1.3544502168, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport math\n\nfrom collections import defaultdict, deque, Counter\n\nfrom copy import deepcopy\n\nfrom bisect import bisect, bisect_right, bisect_left\n\nfrom heapq import heapify, heappop, heappush\n\n    \n\ninput = sys.stdin.readline\n\ndef RD(): return input().rstrip()\n\ndef F(): return float(input().rstrip())\n\ndef I(): return int(input().rstrip())\n\ndef MI(): return list(map(int, input().split()))\n\ndef MF(): return list(map(float,input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\ndef TI(): return tuple(map(int, input().split()))\n\ndef LF(): return list(map(float,input().split()))\n\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\n    \n\n\n\n#mod\n\ndef modinv(a, mod=10**9+7):\n\n    return pow(a, mod-2, mod)\n\n\n\n# nCr mod m\n\n# modinv\n\n# rn/2\n\ndef combination(n, r, mod=10**9+7):\n\n    r = min(r, n-r)\n\n    res = 1\n\n    for i in range(r):\n\n        res = res * (n - i) * modinv(i+1, mod) % mod\n\n    return res\n\n\n\n\n\n#\n\ndef Raise(x, y):\n\n    # xy\n\n    n = 0\n\n    while True:\n\n        if (1<<n) > y:\n\n            break\n\n        n+=1\n\n    D = [0]*(n+1)\n\n    D[0] = x\n\n    index = 0\n\n    for index in range(1,n):\n\n        D[index] = (D[index-1]**2)\n\n    res = 1\n\n    index = 0\n\n    for index in range(0, n):\n\n        if (y>>index)&1 == 1:\n\n            res *= D[index]\n\n    return res\n\n\n\n\n\ndef main():\n\n    # 10^2 - 2*9^2 + 8^2\n\n    n = I()\n\n    mod=10**9+7\n\n    res = pow(10, n, mod)- 2 * pow(9, n, mod) + pow(8, n, mod)\n\n    print((res % (10**9+7)))\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. import sys\n\nimport math\n\nfrom collections import defaultdict, deque, Counter\n\nfrom copy import deepcopy\n\nfrom bisect import bisect, bisect_right, bisect_left\n\nfrom heapq import heapify, heappop, heappush\n\n    \n\ninput = sys.stdin.readline\n\ndef RD(): return input().rstrip()\n\ndef F(): return float(input().rstrip())\n\ndef I(): return int(input().rstrip())\n\ndef MI(): return list(map(int, input().split()))\n\ndef MF(): return list(map(float,input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\ndef TI(): return tuple(map(int, input().split()))\n\ndef LF(): return list(map(float,input().split()))\n\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\n    \n\n\n\n#mod\n\ndef modinv(a, mod=10**9+7):\n\n    return pow(a, mod-2, mod)\n\n\n\n# nCr mod m\n\n# modinv\n\n# rn/2\n\ndef combination(n, r, mod=10**9+7):\n\n    r = min(r, n-r)\n\n    res = 1\n\n    for i in range(r):\n\n        res = res * (n - i) * modinv(i+1, mod) % mod\n\n    return res\n\n\n\n\n\n#\n\ndef Raise(x, y, mod=10**9+7):\n\n    # xy\n\n    n = 0\n\n    while True:\n\n        if (1<<n) > y:\n\n            break\n\n        n+=1\n\n    D = [0]*(n+1)\n\n    x = x % mod\n\n    D[0] = x\n\n    index = 0\n\n    for index in range(1,n):\n\n        D[index] = (D[index-1]**2)\n\n    res = 1\n\n    index = 0\n\n    for index in range(0, n):\n\n        if (y>>index)&1 == 1:\n\n            res *= D[index]\n\n    return res\n\n\n\n\n\ndef main():\n\n    # 10^2 - 2*9^2 + 8^2\n\n    n = I()\n\n    res = Raise(10, n)- 2 * Raise(9, n) + Raise(8, n)\n\n    print((res % (10**9+7)))\n\n    \n\nif __name__ == \"__main__\":\n\n    main()", "output": "A", "improve_diff": 7.5669415371, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in a:\n\n    if i not in d:\n\n        d[i] = 1\n\n    else:\n\n        d[i] += 1\n\n\n\nd = sorted(list(d.items()), key=lambda x:x[1], reverse=True)\n\nans = 0\n\nif len(d) <= k:\n\n    print((0))\n\nelse:\n\n    for i in range(len(d) - k):\n\n        ans += d[-i-1][1]\n\n    print(ans) \nB. import collections\n\n\n\nn, k = list(map(int,input().split()))\n\na = input().split()\n\na = sorted(list(collections.Counter(a).values()), reverse=True)\n\ns = sum(a[:k])\n\n\n\nprint((0 if s == n else n - s))", "output": "A", "improve_diff": 1.5240072924, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # AOJ 1501: Grid\n\n# Python3 2018.7.13 bal4u\n\n\n\nMOD = 100000007\n\ndef dp(n, k):\n\n\tif tbl[n][k]: return tbl[n][k]\n\n\tif (k << 1) > n: k = n-k\n\n\tif k == 0: ans = 1\n\n\telif k == 1: ans = n\n\n\telse: ans = dp(n-1, k) + dp(n-1, k-1)\n\n\ttbl[n][k] = ans % MOD\n\n\treturn tbl[n][k]\n\n\n\ntbl = [[0 for j in range(1001)] for i in range(1001)]\n\nk = 0\n\nr, c, a1, a2, b1, b2 = list(map(int, input().split()))\n\n\n\ndr = abs(a1-b1)\n\nif dr > r-dr: dr = r-dr\n\nif (dr << 1) == r: k += 1\n\n\n\ndc = abs(a2-b2)\n\nif dc > c-dc: dc = c-dc\n\nif (dc << 1) == c: k += 1\n\n\n\nprint(((dp(dr+dc, min(dr, dc)) << k) % MOD))\n\n\n \nB. # AOJ 1501: Grid\n\n# Python3 2018.7.13 bal4u\n\n\n\nfrom math import factorial\n\ndef comb (n, k):\n\n\treturn factorial(n)//factorial(n-k)//factorial(k)\n\n\t\n\nk = 0\n\nr, c, a1, a2, b1, b2 = list(map(int, input().split()))\n\n\n\ndr = abs(a1-b1)\n\nif dr > r-dr: dr = r-dr\n\nif (dr << 1) == r: k += 1\n\n\n\ndc = abs(a2-b2)\n\nif dc > c-dc: dc = c-dc\n\nif (dc << 1) == c: k += 1\n\n\n\nprint(((comb(dr+dc, min(dr, dc)) << k) % 100000007))\n", "output": "B", "improve_diff": 2.8640358387, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def slove():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    a, b = list(map(int, input().rstrip('\\n').split()))\n\n    s = str(input().rstrip('\\n'))\n\n    ls = list(\"1234567890\")\n\n    for i in range(len(s)):\n\n        if i < a:\n\n            if s[i] not in ls:\n\n                print(\"No\")\n\n                exit()\n\n        elif i == a:\n\n            if s[i] != \"-\":\n\n                print(\"No\")\n\n                exit()\n\n        elif b <= i:\n\n            if s[i] not in ls:\n\n                print(\"No\")\n\n                exit()\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n \nB. def slove():\n\n    import sys\n\n    import collections\n\n    input = sys.stdin.readline\n\n    a, b = list(map(int, input().rstrip('\\n').split()))\n\n    s = str(input().rstrip('\\n'))\n\n    d = collections.defaultdict(int)\n\n    for i in range(10):\n\n        d[str(i)]\n\n\n\n    b = True\n\n    for i in range(a + b + 1):\n\n        if i < a:\n\n            if s[i] not in d:\n\n                b = False\n\n                break\n\n        elif i == a:\n\n            if s[i] != \"-\":\n\n                b = False\n\n                break\n\n        else:\n\n            if s[i] not in d:\n\n                b = False\n\n                break\n\n    if b:\n\n        print(\"Yes\")\n\n    else:\n\n        print(\"No\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n", "output": "A", "improve_diff": 1.5575080407, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. h,w = list(map(int,input().split()))\n\nc = [[int(i) for i in input().split()] for _ in range(10)]\n\na = [[int(i) for i in input().split()] for _ in range(h)]\n\n\n\nfor k in range(10):\n\n    for i in range(10):\n\n        for j in range(10):\n\n            c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n\n\n\nans = 0\n\nmp = [c[i][1] for i in range(10)]\n\nmp.append(0)\n\nfor i in range(h):\n\n    for j in range(w): ans += mp[a[i][j]]\n\nprint(ans) \nB. h,w = list(map(int,input().split()))\n\nc = [[int(i) for i in input().split()] for _ in range(10)]\n\na = [[int(i) for i in input().split()] for _ in range(h)]\n\n\n\nfor k in range(10):\n\n    for i in range(10):\n\n        for j in range(10):\n\n            c[i][j] = min(c[i][j],c[i][k]+c[k][j])\n\n\n\nans = 0\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if abs(a[i][j]) != 1:\n\n            ans += c[a[i][j]][1]\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0168840203, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys, collections, heapq\n\nF = sys.stdin\n\ndef single_input(): return F.readline().strip(\"\\n\")\n\ndef line_input(): return F.readline().strip(\"\\n\").split()\n\n\n\ndef solve():\n\n    N, Q = list(map(int, line_input()))\n\n    event = []\n\n    for i in range(N):\n\n        s, t, x = list(map(int, line_input()))\n\n        event.append((s-x, 1, x))\n\n        event.append((t-x,-1, x))\n\n    for i in range(Q):\n\n        d = int(single_input())\n\n        event.append((d, 2, d))\n\n    event.sort()\n\n    candidate = []\n\n    heapq.heapify(candidate)\n\n    stop = collections.defaultdict(int)\n\n    ans = \"\"\n\n    for time, parameter, co in event:\n\n        if parameter == 1:\n\n            heapq.heappush(candidate, co)\n\n            stop[co] += 1\n\n        elif parameter == -1:\n\n            stop[co] -= 1\n\n        else:\n\n            while candidate:\n\n                x = heapq.heappop(candidate)\n\n                if stop[x] > 0:\n\n                    heapq.heappush(candidate, x)\n\n                    ans += str(x) + \"\\n\"\n\n                    break\n\n            else: ans += \"-1\\n\"\n\n    print(ans)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. import sys, collections, heapq\n\ndef single_input(F): return F.readline().strip(\"\\n\")\n\ndef line_input(F): return F.readline().strip(\"\\n\").split()\n\n\n\ndef solve():\n\n    F = sys.stdin\n\n    N, Q = list(map(int, line_input(F)))\n\n    event = []\n\n    for i in range(N):\n\n        s, t, x = list(map(int, line_input(F)))\n\n        event.append((s-x, 1, x))\n\n        event.append((t-x,-1, x))\n\n    for i in range(Q):\n\n        d = int(single_input(F))\n\n        event.append((d, 2, d))\n\n    event.sort()\n\n    candidate = []\n\n    heapq.heapify(candidate)\n\n    stop = collections.defaultdict(int)\n\n    ans = \"\"\n\n    for time, parameter, co in event:\n\n        if parameter == 1:\n\n            heapq.heappush(candidate, co)\n\n            stop[co] += 1\n\n        elif parameter == -1:\n\n            stop[co] -= 1\n\n        else:\n\n            while candidate:\n\n                x = heapq.heappop(candidate)\n\n                if stop[x] > 0:\n\n                    heapq.heappush(candidate, x)\n\n                    ans += str(x) + \"\\n\"\n\n                    break\n\n            else: ans += \"-1\\n\"\n\n    print(ans)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "output": "B", "improve_diff": 1.0411824893, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python3\n\nimport sys\n\nfrom collections import Counter\n\nsys.setrecursionlimit(10**8)\n\nINF = float(\"inf\")\n\n\n\n\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    def group_count(self):\n\n        return len(self.roots())\n\n\n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n\n\n    def __str__(self):\n\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    Q = int(eval(input()))\n\n    B, C = [0]*Q, [0]*Q\n\n    for i in range(Q):\n\n        B[i], C[i] = list(map(int, input().split()))\n\n    # \n\n    # Bi O(1),C[i] O(1)  O(1) O(1)\n\n\n\n    group = [None]*(10**5+1)\n\n    uf = UnionFind(N)\n\n\n\n    # union_find\n\n    # Ni\n\n    # group\n\n    # j (< 10**5)j\n\n\n\n    for i, a in enumerate(A):\n\n        # a\uff1f\n\n        # \n\n        # \n\n        if group[a] is None:\n\n            group[a] = i\n\n        else:\n\n            uf.union(i, group[a])\n\n            group[a] = uf.find(i)\n\n    # print(A)\n\n    # print(group)\n\n    # print(uf.parents)\n\n\n\n    tot = sum(A)\n\n    for i in range(Q):\n\n        if group[B[i]] is None:\n\n            b = 0\n\n        elif group[C[i]] is None:\n\n            b = uf.size(group[B[i]])\n\n            group[C[i]] = uf.find(group[B[i]])\n\n            group[B[i]] = None\n\n        else:\n\n            b = uf.size(group[B[i]])\n\n            uf.union(group[B[i]], group[C[i]])\n\n            group[C[i]] = uf.find(group[B[i]])\n\n            group[B[i]] = None\n\n        tot = tot - B[i]*b + C[i]*b\n\n        print(tot)\n\n        # print(group)\n\n        # print(uf.parents)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. #!/usr/bin/env python3\n\nimport sys\n\nfrom collections import Counter\n\nsys.setrecursionlimit(10**8)\n\nINF = float(\"inf\")\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    Q = int(eval(input()))\n\n    B, C = [0]*Q, [0]*Q\n\n    for i in range(Q):\n\n        B[i], C[i] = list(map(int, input().split()))\n\n    # \n\n    # Bi O(1),C[i] O(1)  O(1) O(1)\n\n\n\n    count = Counter(A)\n\n    tot = sum(A)\n\n    for i in range(Q):\n\n        b = count[B[i]]\n\n        c = count[C[i]]\n\n        count[C[i]] += b\n\n        count[B[i]] = 0\n\n        tot = tot - B[i]*b + C[i]*b\n\n        print(tot)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.0911314154, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def euclid(a, b):\n\n    global l\n\n    if b == 0:\n\n        return a\n\n    else:\n\n        ch = l[a][b]\n\n        if ch == 0:\n\n            return euclid(b, a%b)\n\n        else:\n\n            return ch\n\n\n\ndef gcd(a, b, c):\n\n    global l\n\n    d = l[c][b]\n\n    if d == 0:\n\n        d = euclid(c, b)\n\n        l[c][b] = d\n\n\n\n    e = l[max(d, a)][min(d, a)]\n\n    if e == 0:\n\n        e = euclid(max(d, a), min(d, a))\n\n        l[max(d, a)][min(d, a)] = e\n\n\n\n    return e\n\n\n\nK = int(eval(input()))\n\nans = 0\n\nl = []\n\nfor i in range(K+1):\n\n    l.append([0]*(K+1))\n\n\n\nfor i in range(1, K+1):\n\n    for j in range(i, K+1):\n\n        for k in range(j, K+1):\n\n            num = gcd(i, j, k)\n\n            if i == j:\n\n                if j == k:\n\n                    ans += num\n\n                else:\n\n                    ans += 3*num\n\n            else:\n\n                if j == k:\n\n                    ans += 3*num\n\n                else:\n\n                    ans += 6*num\n\n\n\nprint(ans) \nB. import math\n\n\n\nK = int(eval(input()))\n\nans = 0\n\nl = []\n\nfor i in range(K+1):\n\n    l.append([0]*(K+1))\n\n\n\nfor i in range(1, K+1):\n\n    for j in range(i, K+1):\n\n        for k in range(j, K+1):\n\n            num = math.gcd(math.gcd(i, j), k)\n\n            if i == j:\n\n                if j == k:\n\n                    ans += num\n\n                else:\n\n                    ans += 3*num\n\n            else:\n\n                if j == k:\n\n                    ans += 3*num\n\n                else:\n\n                    ans += 6*num\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.3749318791, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K = int(eval(input()))\n\n\n\nlunlun_number_list = []\n\n\n\ndef dfs(N):\n\n    lunlun_number_list.append(N)\n\n    if len(str(N)) > 10:\n\n        return\n\n    now_int = int(str(N)[-1])\n\n    if now_int == 0:\n\n        for i in range(2):\n\n            dfs(N*10 + i)\n\n    elif now_int == 9:\n\n        for i in range(8, 10, 1):\n\n            dfs(N*10 + i)\n\n    else:\n\n        for i in range(now_int-1, now_int+2, 1):\n\n            dfs(N*10 + i)\n\n\n\nfor i in range(1, 10, 1):\n\n    dfs(i)\n\n\n\nlunlun_number_list.sort()\n\nprint((lunlun_number_list[K-1]))\n \nB. import collections\n\nK = int(eval(input()))\n\n\n\nque = collections.deque()\n\nfor i in range(1, 10, 1):\n\n    que.append(i)\n\ncnt = 0\n\nfor i in range(K):\n\n    x = que.popleft()\n\n    cnt += 1\n\n    if cnt == K:\n\n        print(x)\n\n        exit()\n\n    if x%10 == 0:\n\n        que.append(10*x+0)\n\n        que.append(10*x+1)\n\n    elif x%10 == 9:\n\n        que.append(10*x+8)\n\n        que.append(10*x+9)\n\n    else:\n\n        que.append(10*x+(x%10)-1)\n\n        que.append(10*x+(x%10)+0)\n\n        que.append(10*x+(x%10)+1)\n\n\n", "output": "B", "improve_diff": 8.5423973064, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, h = list(map(int, input().split()))\n\na, b = [], []\n\nfor _ in range(n):\n\n    ai, bi = list(map(int, input().split()))\n\n    a.append(ai), b.append(bi)\n\na.sort(), b.sort()\n\n\n\nans, amax = 0, a[-1]\n\nfor bi in b[::-1]:\n\n    if bi <= amax or h<=0:\n\n        break\n\n    h -= bi\n\n    ans += 1\n\nprint((ans + ((h + amax - 1) // amax) * (h > 0)))\n \nB. n, h = list(map(int, input().split()))\n\na, b = [], []\n\nfor _ in range(n):\n\n    ai, bi = list(map(int, input().split()))\n\n    a.append(ai), b.append(bi)\n\na.sort(), b.sort()\n\n\n\nans, amax = 0, a[-1]\n\nfor bi in b[::-1]:\n\n    if bi <= amax or h <= 0:\n\n        break\n\n    h -= bi\n\n    ans += 1\n\nprint((ans + (h + amax - 1) // amax if h > 0 else ans))\n", "output": "A", "improve_diff": 1.0266469839, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from  collections import Counter\n\n\n\ndef main():\n\n    num, avg = list(map(int, input().split()))\n\n    data = list(map(int, input().split()))\n\n    \n\n    max_num = max(num, avg, max(data))\n\n    dp = [[[0 for i in range(max_num ** 2 + 1)] for j in range(num + 1)] for k in range(num + 1)]\n\n    dp[0][0][0] = 1\n\n\n\n    for i in range(1, num + 1):\n\n        now_card = data[i - 1]\n\n        for j in range(num + 1):\n\n            for k in range(max_num ** 2 + 1):\n\n                # print(i, j, k)\n\n                dp[i][j][k] += dp[i - 1][j][k]\n\n                if k - now_card >= 0 and j - 1 >= 0:\n\n                    dp[i][j][k] += dp[i - 1][j - 1][k - now_card]\n\n        # print(dp[i][j])\n\n\n\n    ans = 0\n\n    for i in range(1, num + 1):\n\n        ans += dp[num][i][i * avg]\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. from  collections import Counter\n\n\n\ndef main():\n\n    num, avg = list(map(int, input().split()))\n\n    data = list(map(int, input().split()))\n\n\n\n    dp = [[[0 for i in range(6000)] for j in range(num + 1)] for k in range(num + 1)]\n\n    dp[0][0][0] = 1\n\n\n\n    for i in range(1, num + 1):\n\n        now_card = data[i - 1]\n\n        for j in range(num + 1):\n\n            for k in range(6000):\n\n                # print(i, j, k)\n\n                dp[i][j][k] += dp[i - 1][j][k]\n\n                if k - now_card >= 0 and j - 1 >= 0:\n\n                    dp[i][j][k] += dp[i - 1][j - 1][k - now_card]\n\n        # print(dp[i][j])\n\n\n\n    ans = 0\n\n    for i in range(1, num + 1):\n\n        ans += dp[num][i][i * avg]\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 2.3060032636, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # https://atcoder.jp/contests/abc084/tasks/abc084_d\n\n# D - 2017-like Number\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n# \n\ndef is_prime(n):\n\n    if n == 1:\n\n        return False\n\n    for k in range(2, int(pow(n, 0.5)) + 1):\n\n        if n % k == 0:\n\n            return False\n\n    return True\n\n\n\n\n\ndef resolve():\n\n    q = int(eval(input()))\n\n    LR = [list(map(int, input().split())) for _ in range(q)]\n\n\n\n    # 1201702017\n\n    Lile_2017 = [0] * (10 ** 5 + 1)\n\n\n\n    # \n\n    prime = set()\n\n    not_prime = set()\n\n\n\n    # 1~1000002017\n\n    for n in range(1, 10 ** 5 + 1):\n\n        flg1, flg2 = False, False\n\n        if n % 2 != 0:\n\n            if n in prime:\n\n                flg1 = True\n\n            elif n in not_prime:\n\n                flg1 = False\n\n            else:\n\n                flg1 = is_prime(n)\n\n                prime.add(n) if flg1 else not_prime.add(n)\n\n\n\n            if (n + 1) // 2 in prime:\n\n                flg2 = True\n\n            elif (n + 1) // 2 in not_prime:\n\n                flg2 = False\n\n            else:\n\n                flg2 = is_prime((n + 1) // 2)\n\n                prime.add((n + 1) // 2) if flg1 else not_prime.add((n + 1) // 2)\n\n\n\n        Lile_2017[n - 1] += 1 if flg1 and flg2 else 0\n\n\n\n    # 2017\n\n    Ruiseki = [0]\n\n    for i in range(1, 10 ** 5 + 1):\n\n        Ruiseki.append(Ruiseki[-1] + Lile_2017[i - 1])\n\n\n\n    # \n\n    for l, r in LR:\n\n        print((Ruiseki[r] - Ruiseki[l - 1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n \nB. import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    def is_prime(n):\n\n        if n == 1:\n\n            return False\n\n        for k in range(2, int(pow(n, 0.5)) + 1):\n\n            if n % k == 0:\n\n                return False\n\n        return True\n\n\n\n    q = int(eval(input()))\n\n    primes = set()\n\n    nums = set()\n\n    for i in range(2, 10 ** 5 + 1):\n\n        if is_prime(i):\n\n            primes.add(i)\n\n            if (i + 1) // 2 in primes:\n\n                nums.add(i)\n\n\n\n    cnt = [0]\n\n    for i in range(1, 10 ** 5 + 1):\n\n        op = 1 if i in nums else 0\n\n        cnt.append(cnt[-1] + op)\n\n\n\n    for _ in range(q):\n\n        l, r = list(map(int, input().split()))\n\n        res = cnt[r] - cnt[l - 1]\n\n        print(res)\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n", "output": "B", "improve_diff": 1.1146458785, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def gcd(x, y):\n\n    if y > x:\n\n        x, y = y, x\n\n    while y:\n\n        x, y = y, x % y\n\n    return x\n\n\n\nN=int(eval(input()))\n\na=list(map(int,input().split()))\n\n\n\nl=[0]*N\n\nl[0]=a[0]\n\nfor i in range(1,N):\n\n    l[i]=gcd(l[i-1],a[i])\n\n\n\nr=[0]*N\n\nr[N-1]=a[N-1]\n\nfor i in range(N-2,-1,-1):\n\n    r[i]=gcd(r[i+1],a[i])\n\n\n\nans=max(r[1],l[N-2])\n\nfor i in range(1,N-1):\n\n    tmp=gcd(l[i-1],r[i+1])\n\n    ans=max(tmp,ans)\n\n\n\nprint(ans) \nB. def gcd(x, y):\n\n    if y > x:\n\n        x, y = y, x\n\n    while y:\n\n        x, y = y, x % y\n\n    return x\n\n\n\nN=int(eval(input()))\n\na=list(map(int,input().split()))\n\n\n\nl=[0]*N\n\nl[0]=a[0]\n\nfor i in range(1,N):\n\n    l[i]=gcd(l[i-1],a[i])\n\n\n\nr=[0]*N\n\nr[N-1]=a[N-1]\n\nfor i in range(N-2,-1,-1):\n\n    r[i]=gcd(r[i+1],a[i])\n\n\n\nans=max(r[1],l[N-2])\n\nfor i in range(1,N-1):\n\n    tmp=gcd(l[i-1],r[i+1])\n\n    if tmp>ans: ans=tmp\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.0223599141, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(10**9)\n\n\n\nMOD=10**9+7\n\nn,k=list(map(int,input().split()))\n\n\n\nif k>=n-1:\n\n  k=n-1\n\n\n\ninv_table = [0]+[1]\n\nfor i in range(2,k+1):\n\n  inv_table.append(-1*(MOD//i)*inv_table[MOD%i] %MOD)\n\n\n\ncomb_sum=1\n\nfact=1\n\ncomb1=1\n\ncomb2=1\n\nfor i in range(1,k+1):\n\n  comb1=(comb1*(n-i+1)*inv_table[i])%MOD\n\n  comb2=(comb2*(n-i)*inv_table[i])%MOD\n\n  comb=(comb1*comb2)%MOD\n\n  comb_sum+=comb\n\n\n\nprint((comb_sum%MOD)) \nB. import sys\n\nsys.setrecursionlimit(10**9)\n\n\n\nMOD=10**9+7\n\nn,k=list(map(int,input().split()))\n\n\n\nif k>=n-1:\n\n  k=n-1\n\n\n\ninv_table = [0]+[1]\n\nfor i in range(2,k+1):\n\n  inv_table+=[inv_table[MOD%i]*(MOD-int(MOD/i))%MOD]\n\n\n\ncomb_sum=1\n\nfact=1\n\ncomb1=1\n\ncomb2=1\n\nfor i in range(1,k+1):\n\n  comb1=(comb1*(n-i+1)*inv_table[i])%MOD\n\n  comb2=(comb2*(n-i)*inv_table[i])%MOD\n\n  comb=(comb1*comb2)%MOD\n\n  comb_sum+=comb\n\n\n\nprint((comb_sum%MOD))", "output": "A", "improve_diff": 1.1607312617, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque\n\n\n\nN, Q = list(map(int, sys.stdin.readline().split(\" \")))\n\n\n\nedges = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n\n    a, b = list(map(int, sys.stdin.readline().split(\" \")))\n\n    # print(a, b)\n\n    edges[a-1].append(b-1)\n\n    edges[b-1].append(a-1)\n\n# print(edges)\n\n# sys.exit()\n\n\n\npoints = [0] * N\n\nfor _ in range(Q):\n\n    p, x = list(map(int, sys.stdin.readline().split(\" \")))\n\n    points[p-1] += x\n\n\n\n\n\nvisited = set()\n\ncounted = [0] * N\n\nq = deque([(0, points[0])])\n\nwhile q:\n\n    node, point = q.popleft()\n\n    # print(node, point)\n\n    if node in visited:\n\n        continue\n\n    counted[node] = str(point)\n\n    visited.add(node)\n\n    for edge in edges[node]:\n\n        q.appendleft((edge, point + points[edge]))\n\n\n\nprint((\" \".join(counted))) \nB. from pprint import pprint\n\nfrom collections import deque, defaultdict\n\n \n\nimport sys\n\n \n\n# n, q = map(int, input().strip().split(\" \"))\n\nn, q = list(map(int, sys.stdin.readline().strip().split(\" \")))\n\nedges = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n\n    # a_i, b_i = map(int, input().strip().split(\" \"))\n\n    a_i, b_i = list(map(int, sys.stdin.readline().strip().split(\" \")))\n\n    edges[a_i-1].append(b_i-1)\n\n    edges[b_i-1].append(a_i-1)\n\n \n\ncounter = [0] * n\n\np = [0] * n\n\nfor _ in range(q):\n\n    # p_i, x_i = map(int, input().strip().split(\" \"))\n\n    p_i, x_i = list(map(int, sys.stdin.readline().strip().split(\" \")))\n\n    p[p_i-1] += x_i\n\n    # counter[p_i-1] += x_i\n\n \n\n \n\nparents = deque()\n\nparents.append(0)\n\nvisited = set()\n\nwhile parents:\n\n    parent = parents.popleft()\n\n    if parent in visited:\n\n        continue\n\n    counter[parent] += p[parent]\n\n    visited.add(parent)\n\n    for child in edges[parent]:\n\n        if child in visited:\n\n            continue\n\n        counter[child] += counter[parent]\n\n        # print(\"child\")\n\n        # print(child, counter[child])\n\n        parents.append(child)\n\n \n\nprint((\" \".join(list(map(str, counter)))))", "output": "A", "improve_diff": 1.9776762772, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nans = 10 ** 20\n\nfor i in range(1, 10 ** 6 + 1):\n\n    if i ** 2 > N: break\n\n    if N % i == 0:\n\n        ans = min(ans, i + N // i - 2)\n\nprint(ans) \nB. import sys\n\ndef solve():\n\n    N = int(eval(input()))\n\n    moveN = 10000000000000000000\n\n    for i in range(1, N + 1):\n\n        if i ** 2 > N: break\n\n        if N % i == 0:\n\n            moveN = min(i + (N // i) - 2, moveN)\n\n    print(moveN)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "output": "B", "improve_diff": 1.1034341025, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_right\n\nN = int(eval(input()))\n\nunit = [1]\n\nfor b in [6,9]:\n\n    u = b\n\n    while u <= N:\n\n        unit.append(u)\n\n        u *= b\n\nunit.sort()\n\nNu = len(unit)\n\n\n\nans = N\n\nstate_pool = [(0, 0, Nu-1)]\n\nwhile state_pool:\n\n    n, i, pk = state_pool.pop()\n\n    if N - n >= (ans-i)*unit[pk]:\n\n        continue\n\n    sk = bisect_right(unit, N-n, 0, pk+1)\n\n    for k in range(sk):\n\n        u = unit[k]\n\n        c = n + u\n\n        if c == N:\n\n            if i + 1 < ans:\n\n                ans = i + 1\n\n        else:\n\n            state_pool.append((c, i+1, k))\n\nprint(ans) \nB. from bisect import bisect_right\n\nN = int(eval(input()))\n\nunit = [1]\n\nfor b in [6,9]:\n\n    u = b\n\n    while u <= N:\n\n        unit.append(u)\n\n        u *= b\n\nunit.sort()\n\nNu = len(unit)\n\n\n\nans = N\n\nstate_pool = [(0, 0, 0, Nu-1)]\n\nwhile state_pool:\n\n    n, i, parent, pk = state_pool.pop()\n\n    if N - n >= (ans-i)*unit[pk]:\n\n        continue\n\n    elif pk > 0 and i > 0:\n\n        state_pool.append((parent+unit[pk-1], i, parent, pk-1))\n\n\n\n    k = bisect_right(unit, N-n, 0, pk+1) - 1\n\n    c = n + unit[k]\n\n    if c == N:\n\n        if i + 1 < ans:\n\n            ans = i + 1\n\n    else:\n\n        state_pool.append((c, i+1, n, k))\n\nprint(ans)", "output": "B", "improve_diff": 1.0384648955, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\ndef main():\n\n    N = int(readline())\n\n    S = readline().strip()\n\n\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n\n    for i in range(N - 1, -1, -1):\n\n        for j in range(N - 1, i, -1):\n\n            if S[i] == S[j]:\n\n                dp[i][j] = dp[i + 1][j + 1] + 1\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i + 1, N):\n\n            if ans < min(dp[i][j], j - i):\n\n                ans = min(dp[i][j], j - i)\n\n\n\n    print(ans)\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\ndef main():\n\n    N = int(readline())\n\n    S = readline().strip()\n\n\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n\n    ans = 0\n\n\n\n    for i in range(N - 1, -1, -1):\n\n        for j in range(N - 1, i, -1):\n\n            if S[i] == S[j]:\n\n                dp[i][j] = dp[i + 1][j + 1] + 1\n\n            if ans < min(dp[i][j], j - i):\n\n                ans = min(dp[i][j], j - i)\n\n\n\n    print(ans)\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.0311362058, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a=int(eval(input())) # 500\n\nb=int(eval(input())) # 100\n\nc=int(eval(input())) # 50\n\nx=int(eval(input()))\n\nsum = []\n\ncount = 0\n\n\n\nfor i in range(0, a+1):\n\n    asum = 500 * i\n\n    for i in range(0, b+1):\n\n        bsum = 100 * i\n\n        for i in range(0, c+1):\n\n            csum = 50 * i\n\n            sum.append(asum + bsum + csum)\n\n\n\nfor i in sum:\n\n    if i == x:\n\n        count += 1\n\n\n\nprint(count)\n \nB. a=int(eval(input())) # 500\n\nb=int(eval(input())) # 100\n\nc=int(eval(input())) # 50\n\nx=int(eval(input()))\n\ncount = 0\n\n\n\nfor i in range(0, a+1):\n\n    for j in range(0, b+1):\n\n        for k in range(0, c+1):\n\n            if 500 * i + 100 * j + 50 * k == x:\n\n                count += 1\n\nprint(count)\n", "output": "B", "improve_diff": 1.1308093871, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\nm=0\n\nfor i in range(n):\n\n  s=(a[-1-i][0]+m)%a[-1-i][1]\n\n  if s!=0:m+=a[-1-i][1]-s\n\nprint(m) \nB. n=int(eval(input()))\n\na=[]\n\nb=[]\n\nfor i in range(n):\n\n  aa,bb=list(map(int,input().split()))\n\n  a.append(aa)\n\n  b.append(bb)\n\nm=0\n\nfor i in range(n-1,-1,-1):\n\n  a[i]+=m\n\n  if a[i]%b[i]:m+=b[i]-a[i]%b[i]\n\nprint(m)", "output": "B", "improve_diff": 1.0274931423, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nvalue = sorted(list(map(int,input().split())))[::-1]\n\nprint((sum(value[::2]) - sum(value[1::2])))\n\n\n \nB. import numpy as np\n\nN = int(eval(input()))\n\na = sorted(list(map(int,input().split())),reverse=True)\n\nprint((sum(a[::2]) - sum(a[1::2])))\n\n\n", "output": "A", "improve_diff": 11.1767931837, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA.sort()\n\n\n\nfor i in range(N//2):\n\n    if A[i*2] + A[i*2+1] < 0:\n\n        A[i*2] = -1 * A[i*2]\n\n        A[i*2+1] = -1 * A[i*2+1]\n\n    else:\n\n        break\n\n\n\nprint((sum(A))) \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nnum_of_minus = sum([a < 0 for a in A])\n\nabs_A = [abs(a) for a in A]\n\nans = sum(abs_A)\n\n\n\nif num_of_minus % 2 == 0:\n\n    print(ans)\n\nelse:\n\n    print((ans - 2 * min(abs_A)))", "output": "A", "improve_diff": 1.0304901604, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom numpy import fromstring\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall as f\n\ndef main():\n\n  t=fromstring(sys.stdin.buffer.read(),'i',sep=' ')\n\n  n,m,l=t[:3]\n\n  m=m*3+3\n\n  print(('\\n'.join((f(f(csr_matrix((t[5:m:3],(t[3:m:3],t[4:m:3])),[n+1]*2),0)<=l)[t[m+1::2],t[m+2::2]].clip(0,n).astype(int)%n-1).astype(str).tolist())))\n\nmain() \nB. import numpy as np\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import floyd_warshall as f\n\ndef main():\n\n  t=np.fromfile(open(0,'rb'),'i',sep=' ')\n\n  n,m,l=t[:3]\n\n  m=m*3+3\n\n  print(('\\n'.join((f(f(csr_matrix((t[5:m:3],(t[3:m:3],t[4:m:3])),[n+1]*2),0)<=l)[t[m+1::2],t[m+2::2]].clip(0,n).astype(int)%n-1).astype(str).tolist())))\n\nmain()", "output": "B", "improve_diff": 1.0175055866, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,y = list(map(int,input().split()))\n\n\n\ndef f(x):\n\n  if x==3:\n\n    return 100000\n\n  elif x==2:\n\n    return 200000\n\n  elif x== 1:\n\n    return 300000\n\n  else:\n\n    return 0\n\n\n\nans = f(x)+f(y)\n\nif x == y== 1:\n\n  ans += 400000\n\nprint(ans) \nB. x,y = list(map(int,input().split()))\n\namount = 0\n\nif x < 4:\n\n  amount += (4-x)*100000\n\nif y < 4:\n\n  amount += (4-y)*100000\n\nif x ==1 and y==1:\n\n  amount += 400000\n\nprint(amount)", "output": "A", "improve_diff": 1.034112304, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\ndef training(n):\n\n    power = 1\n\n    for i in range(1, n+1):\n\n        power = power * i % 1000000007\n\n    return power\n\n\n\nprint((training(n))) \nB. n = int(eval(input()))\n\np = 1\n\n\n\nfor i in range(1, n+1):\n\n    p = p * i % 1000000007\n\n\n\nprint(p)", "output": "A", "improve_diff": 1.1276516282, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python3\n\n# -*- coding: UTF-8 -*-\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.rank=[0]*size\n\n        self.par =[int(i) for i in range(size)]\n\n        self.grp =size\n\n\n\n    def find(self, x):\n\n        if x==self.par[x]: return x\n\n\n\n        self.par[x]=self.find(self.par[x])\n\n        return self.par[x]\n\n\n\n    def same(self, x, y): #2\n\n        return self.find(x)==self.find(y)\n\n\n\n    def unite(self, x, y): #2\n\n        x,y=self.find(x),self.find(y)\n\n        if x==y:\n\n            return\n\n\n\n        self.grp-=1\n\n        if self.rank[x]<self.rank[y]:\n\n            self.par[x]=y\n\n        else:\n\n            self.par[y]=x\n\n            if self.rank[x]==self.rank[y]:\n\n                self.rank[x]+=1\n\n\n\n    def group_num(self):\n\n        return self.grp\n\n\n\n\n\nn,m=list(map(int, input().split()))\n\n\n\nuf=UnionFind(n)\n\n\n\nfor i in range(m):\n\n    x,y,z=list(map(int, input().split()))\n\n    uf.unite(x-1,y-1)\n\n\n\nprint((uf.grp)) \nB. #!/usr/bin/env python3\n\n# -*- coding: UTF-8 -*-\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.rank=[0]*size\n\n        self.par =[int(i) for i in range(size)]\n\n        self.grp =size\n\n\n\n    def find(self, x):\n\n        if x==self.par[x]: return x\n\n\n\n        self.par[x]=self.find(self.par[x])\n\n        return self.par[x]\n\n\n\n    def same(self, x, y):\n\n        return self.find(x)==self.find(y)\n\n\n\n    def unite(self, x, y):\n\n        x,y=self.find(x),self.find(y)\n\n        if x==y:\n\n            return\n\n\n\n        self.grp-=1\n\n        if self.rank[x]<self.rank[y]:\n\n            self.par[x]=y\n\n        else:\n\n            self.par[y]=x\n\n            if self.rank[x]==self.rank[y]:\n\n                self.rank[x]+=1\n\n\n\n    def group_num(self):\n\n        return self.grp\n\n\n\n\n\n\n\nn,m=list(map(int,input().split()))\n\nuf=UnionFind(n)\n\nans=chk=0\n\nfor i in range(m):\n\n    x,y,z=list(map(int,input().split()))\n\n    uf.unite(x-1,y-1)\n\nprint((uf.grp))", "output": "A", "improve_diff": 1.0138763171, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nmod2 = 998244353\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,k = inpl()\n\na = inpln(n)\n\na.sort()\n\nres = INF\n\nfor i in range(n-k+1):\n\n    res = min(res, a[i+k-1] - a[i])\n\nprint(res) \nB. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,k = inpl()\n\na = [inp() for _ in range(n)]\n\na.sort()\n\nres = INF\n\nfor i in range(n-k+1):\n\n    res = min(res, a[i+k-1] - a[i])\n\nprint(res)", "output": "A", "improve_diff": 1.4225180018, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K = list(map(int, input().split()))\n\nD = set(input().split())\n\n\n\nfor n in range(N, N * 10 + 1):\n\n    ok = True\n\n    for c in str(n):\n\n        if c in D:\n\n            ok = False\n\n    if ok:\n\n        print(n)\n\n        break\n\n\n\n    \n\n     \nB. import sys\n\nimport itertools\n\n# import numpy as np\n\nimport time\n\nimport math\n\nimport heapq\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\n\n \n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n# map(int, input().split())\n\nN, K = list(map(int, input().split()))\n\nD = input().split()\n\n\n\nfor n in range(N, 100000):\n\n    s = str(n)\n\n    ok = True\n\n    for c in s:\n\n        if c in D:\n\n            ok = False\n\n    if ok:\n\n        print(n)\n\n        break\n\n\n\n    \n\n    ", "output": "A", "improve_diff": 1.7089390556, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import bisect\n\nN, M = list(map(int, input().split()))\n\nP, Y = [], []\n\npref = [[] for _ in range(N+1)] # non-0-indexed\n\nfor m in range(M):\n\n    p,y = list(map(int, input().split()))\n\n    P.append(p)\n\n    Y.append(y)\n\n    pref[p].append(y)\n\nfor i, p in enumerate(pref):\n\n    pref[i] = sorted(p)\n\n    \n\nfor p,y in zip(P,Y):\n\n    ans = \"{:0>6}\".format(p)\n\n    i = bisect.bisect(pref[p], y)\n\n    ans += \"{:0>6}\".format(i)\n\n    print(ans)\n\n\n\n\n \nB. import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\nP = []\n\nY = []\n\nfor _ in range(M):\n\n    p, y = list(map(int, input().split()))\n\n    P.append(p)\n\n    Y.append(y)\n\nP = np.array(P)\n\nY = np.array(Y)\n\nPY = np.c_[P, Y]\n\nsort_ind = np.argsort(Y)\n\n\n\nPY_sort = PY[sort_ind]\n\ncount = [0] * (int(1e+5) + 1)\n\nid_list = []\n\nfor p, y in PY_sort:\n\n    count[p] += 1\n\n    id_list.append(str(p).zfill(6) + str(count[p]).zfill(6))\n\n\n\nid_list = np.array(id_list)\n\nid_list = id_list[np.argsort(sort_ind)]\n\nfor city_id in id_list:\n\n    print(city_id)", "output": "A", "improve_diff": 7.6871293807, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n\n\ndef main() -> None:\n\n    n = int(eval(input()))\n\n    a = [0] * n\n\n    b = [0] * n\n\n    ans = 0\n\n\n\n    for i in range(n):\n\n        a[i], b[i] = list(map(int, sys.stdin.readline().split()))\n\n\n\n    for i in range(n - 1, -1, -1):\n\n        a[i] += ans\n\n        if a[i] % b[i] != 0:\n\n            ans += abs(a[i] % b[i] - b[i])\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. import sys\n\n\n\n\n\ndef main() -> None:\n\n    n = int(sys.stdin.readline())\n\n    a = [0] * n\n\n    b = [0] * n\n\n    ans = 0\n\n\n\n    for i in range(n):\n\n        a[i], b[i] = list(map(int, sys.stdin.readline().split()))\n\n\n\n    for i in range(n - 1, -1, -1):\n\n        a[i] += ans\n\n        if a[i] % b[i] != 0:\n\n            ans += abs(a[i] % b[i] - b[i])\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "A", "improve_diff": 1.0151759151, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = list(map(int, input().split()))\n\nr = [i for i in range(N+1)]\n\nn = [0 for i in range(N+1)]\n\nbuf = []\n\n\n\ndef root(x):\n\n  if x==r[x]:\n\n    return x\n\n  else:\n\n    r[x] = root(r[x])\n\n    return r[x]\n\n\n\ndef unite(x, y):\n\n  rx = root(x)\n\n  ry = root(y)\n\n  if rx < ry:\n\n    r[ry] = rx\n\n  elif rx > ry:\n\n    r[rx] = ry\n\n    \n\n\n\nfor _ in range(M):\n\n  a, b = list(map(int, input().split()))\n\n  unite(a, b)\n\n\n\nfor x in range(1, N+1):\n\n  if r[x] != x and r[r[x]] != r[x]:\n\n    _ = root(x)\n\n  \n\n  \n\nfor x in r[1:]:\n\n  n[x] += 1\n\n    \n\nans = max(n[1:])\n\n\n\nprint(ans) \nB. from collections import deque\n\n \n\nN, M = list(map(int, input().split()))\n\ng = {i:set() for i in range(N)}\n\nv = [-1 for i in range(N)]\n\nfor _ in range(M):\n\n  a, b = list(map(int, input().split()))\n\n  a, b = a-1, b-1\n\n  g[a].add(b)\n\n  g[b].add(a)\n\n  \n\nQ = deque()\n\nans = 0\n\nfor a in g:\n\n  if v[a]==-1:\n\n    v[a] = 1\n\n    ans_tmp = 1\n\n    Q.append(a)\n\n    while len(Q)>0:\n\n      na = Q.popleft()\n\n      for nb in g[na]:\n\n        if v[nb] == -1:\n\n          v[nb] = 1\n\n          ans_tmp += 1\n\n          Q.append(nb)\n\n    ans = max(ans, ans_tmp)\n\nprint(ans)", "output": "A", "improve_diff": 1.6075274631, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from decimal import Decimal\n\na,b,c=list(map(int,input().split()))\n\nif(Decimal(a).sqrt()+Decimal(b).sqrt()<Decimal(c).sqrt()):\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\") \nB. a,b,c=list(map(int,input().split()))\n\nprint((\"Yes\" if 4*a*b<(c-a-b)**2 and c-a-b>0 else \"No\"))", "output": "B", "improve_diff": 1.7871451972, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, a, b = list(map(int, input().split()))\n\nsum_all = 0\n\nfor i in range(1, n + 1):\n\n    m = str(i)\n\n    sum_m = 0\n\n    for j in range(len(m)):\n\n        sum_m += int(m[j])\n\n    if a <= sum_m <= b:\n\n        sum_all += i\n\nprint(sum_all) \nB. import math\n\n\n\nn, a, b = list(map(int, input().split()))\n\n\n\nsum_all = 0\n\nfor i in range(1, n + 1):\n\n    sum_n = 0\n\n    m = i\n\n    while(m > 0):\n\n        sum_n += math.floor(m % 10)\n\n        m /= 10\n\n    if a <= sum_n <= b:\n\n        sum_all += i\n\n\n\nprint(sum_all)", "output": "A", "improve_diff": 1.6329334368, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import cmath\n\nimport numpy as np\n\nimport sys\n\n\n\nINF=10**18\n\nMOD=10**9+7\n\nMAX=10**5+7\n\n\n\ndef main():\n\n    N=int(eval(input()))\n\n    dp=[0, 0, 0]\n\n    for _ in range(N):\n\n        a,b,c=list(map(int, input().split()))\n\n        ndp=[0, 0, 0]\n\n        ndp[0]=max(dp[1], dp[2])+a\n\n        ndp[1]=max(dp[2], dp[0])+b\n\n        ndp[2]=max(dp[0], dp[1])+c\n\n        dp=ndp\n\n    print((max(dp)))\n\n\n\nif __name__=='__main__':\n\n    main()\n \nB. import sys\n\n\n\nINF=10**18\n\nMOD=10**9+7\n\nMAX=10**5+7\n\n\n\ndef main():\n\n    N=int(eval(input()))\n\n    dp=[0, 0, 0]\n\n    for line in sys.stdin.readlines():\n\n        a,b,c=list(map(int, line.split()))\n\n        ndp=[0, 0, 0]\n\n        ndp[0]=max(dp[1], dp[2])+a\n\n        ndp[1]=max(dp[2], dp[0])+b\n\n        ndp[2]=max(dp[0], dp[1])+c\n\n        dp=ndp\n\n    print((max(dp)))\n\n\n\nmain()\n", "output": "B", "improve_diff": 11.347306235, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    n = int(eval(input()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    point = sum(b)\n\n\n\n    for i in range(1,n):\n\n        if a[i-1] +1 == a[i]:\n\n            point += c[a[i-1]-1]\n\n\n\n\n\n    print(point)\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. def main():\n\n    n = int(eval(input()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    total_score = sum(b)\n\n\n\n    for i in range(1, n):\n\n        prev = a[i - 1]\n\n        if prev + 1 == a[i]:\n\n            total_score += c[prev - 1]\n\n\n\n    print(total_score)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.012703952, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\n# a,b,c=map(int,input().split())\n\ncnt=0\n\ndef gcd(a,b):\n\n    if a==0: return b\n\n    else: return gcd(b%a,a)\n\n# print(gcd(a,b))\n\n\n\ndef gcd_3(a,b,c):\n\n    if gcd(a,b)==0: return c\n\n    else: return gcd(c % gcd(a,b),gcd(a,b))\n\n\n\nfor i in range(1,n+1):\n\n    for j in range ( 1 , n + 1 ):\n\n        for k in range ( 1 , n + 1 ):\n\n            # print(i,j,k)\n\n            cnt+=gcd_3(i,j,k)\n\nprint(cnt)\n \nB. def main():\n\n    from math import gcd\n\n\n\n    K = int(eval(input()))\n\n\n\n    result = 0\n\n    for a in range(1, K + 1):\n\n        for b in range(1, K + 1):\n\n            t = gcd(a, b)\n\n            for c in range(1, K + 1):\n\n                result += gcd(t, c)\n\n    print(result)\n\n\n\n\n\nmain()", "output": "A", "improve_diff": 1.3619057316, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\nN = int(eval(input()))\n\nH = list(map(int, input().split()))\n\n\n\n# memo = [0] + [abs(H[i] - H[i-1]) for i in range(1, N)]\n\n# memo = [H[i] - H[i-1] for i in range(1, N)]\n\nmemo = [sum(H)] * (N+2)\n\nmemo[0] = 0\n\nfor i in range(N):\n\n    memo[i+1] = min(memo[i+1], memo[i] + abs(H[i+1] - H[i]))\n\n    if i > N-3:\n\n        break\n\n    memo[i+2] = min(memo[i+2], memo[i] + abs(H[i+2] - H[i]))\n\n\n\nprint((memo[N-1])) \nB. N = int(eval(input()))\n\nH = list(map(int, input().split()))\n\n\n\ndp = [0] * N\n\ndp[1] = abs(H[1] - H[0])\n\nfor i in range(2, N):\n\n    dp[i] = min(dp[i-1] + abs(H[i] - H[i-1]), dp[i-2] + abs(H[i] - H[i-2]))\n\n\n\nprint((dp[N-1]))\n", "output": "B", "improve_diff": 1.0176950998, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\ndef abs(x):\n\n  return math.fabs(x)\n\na,b=list(map(int,input().split()))\n\nc=int(abs(b)-abs(a))\n\nprint((int(abs(c))+(c*a<0)+(c*b<0) if c!=0 else 1)) \nB. a,b=list(map(int,input().split()))\n\nc=int(abs(b)-abs(a))\n\nprint((int(abs(c))+(c*a<0)+(c*b<0) if c!=0 else 1))", "output": "B", "improve_diff": 1.3432411141, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def era(num):\n\n    input_list = [False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range(num)]\n\n    input_list[0] = input_list[1] = False\n\n    input_list[2] = input_list[3] = input_list[5] = True\n\n    sqrt = num**0.5\n\n\n\n    for serial in range(3, num, 2):\n\n\n\n        if serial >= sqrt:\n\n            return input_list\n\n\n\n        for s in range(serial ** 2, num, serial): \n\n            input_list[s] = False\n\n\n\nN=int(eval(input()))\n\nif N<25:\n\n    Prime=[2,3,5]\n\nelse:\n\n    input_list=era(int(N**0.5)+1)\n\n    Prime=[i for i, b in enumerate(input_list) if b == True]\n\n\n\nFac={}\n\nfor p in Prime:\n\n    while N%p==0:\n\n        N//=p\n\n        if p in Fac:\n\n            Fac[p]+=1\n\n        else:\n\n            Fac[p]=1\n\n    if N==1:\n\n        break\n\nif N!=1:\n\n    Fac[N]=1\n\nans=0\n\n\n\nfor k in Fac:\n\n    nec=1\n\n    while True:\n\n        if Fac[k]>=nec:\n\n            ans+=1\n\n            Fac[k]-=nec\n\n            nec+=1\n\n        else:\n\n            break\n\n\n\nprint(ans) \nB. N=int(eval(input()))\n\nF={}\n\nfor i in range(2,int(N**0.5)+1):\n\n    if N%i==0:\n\n        F[i]=1\n\n        N//=i\n\n    while N%i==0:\n\n        N//=i\n\n        F[i]+=1\n\nif N>1:\n\n    F[N]=1\n\n\n\nans=0\n\nfor f in F:\n\n    j=1\n\n    while True:\n\n        F[f]-=j\n\n        j+=1\n\n        if F[f]>=0:\n\n            ans+=1\n\n        else:\n\n            break\n\nprint(ans)", "output": "B", "improve_diff": 1.3114499019, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import product\n\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\nN = int(eval(input()))\n\n# XAGC, XGAC, AXGC, AGXC, XACG: prohibited\n\nA=0; C=1; G=2; T=3\n\ncur = defaultdict(lambda: 1)\n\ncur[(A,G,C)] = cur[(G,A,C)] = cur[(A,C,G)] = 0\n\nfor _ in range(3,N):\n\n    prev = cur\n\n    cur = defaultdict(int)\n\n    for (i,j,k,l) in product(list(range(4)),repeat=4):\n\n        if ((j,k,l)==(A,G,C) or (j,k,l)==(G,A,C) or (i,k,l)==(A,G,C) or\n\n            (i,j,l)==(A,G,C) or (j,k,l)==(A,C,G)):\n\n            continue\n\n        else:\n\n            cur[(j,k,l)] += prev[(i,j,k)]\n\n    for ijk in product(list(range(4)),repeat=3):\n\n        cur[ijk] %= MOD\n\n\n\nans = sum(cur.values()) % MOD\n\nif N <= 3:\n\n    print(([1,4,16,61][N]))\n\nelse:\n\n    print(ans) \nB. from itertools import product\n\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\nN = int(eval(input()))\n\nD, L = 4, 3\n\nAGC = list(range(L))\n\nATGC = list(range(D))\n\ncur = defaultdict(lambda: 1)\n\n# XAGC, XGAC, AXGC, AGXC, XACG: prohibited\n\nflip = lambda x, n: x[:n] + [x[n+1],x[n]] + x[n+2:]\n\nprohibited1 = [tuple(AGC)] + [tuple(flip(AGC,i)) for i in range(L-1)]\n\nprohibited2 = ({(X,) + p for p in prohibited1 for X in ATGC} | \n\n             {tuple(flip([X]+AGC,0)) for X in ATGC} |\n\n             {tuple(flip(AGC+[X],L-1)) for X in ATGC})\n\nfor p in prohibited1:\n\n    cur[p] = 0\n\nfor _ in range(L,N):\n\n    prev = cur\n\n    cur = defaultdict(int)\n\n    for recent in product(ATGC, repeat=L+1):\n\n        if recent in prohibited2:\n\n            continue\n\n        else:\n\n            cur[recent[1:]] += prev[recent[:-1]]\n\n    for latest in product(ATGC, repeat=L):\n\n        cur[latest] %= MOD\n\n\n\nans = sum(cur.values()) % MOD\n\nif N < L:\n\n    print((D**N))\n\nelif N == L:\n\n    print((D**L - len(prohibited1)))\n\nelse:\n\n    print(ans)", "output": "B", "improve_diff": 1.199407343, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys; sys.setrecursionlimit(50000)\n\ninput = sys.stdin.readline\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = sorted(map(int, input().split()), reverse=True)\n\nB = sorted(map(int, input().split()), reverse=True)\n\nC = sorted(map(int, input().split()), reverse=True)\n\n\n\nresult = []\n\nfor x in range(X):\n\n    for y in range(Y):\n\n        if x * y > K: break\n\n        for z in range(Z):\n\n            if x * y * z > K: break\n\n            result.append(A[x]+B[y]+C[z])\n\n            \n\nfor i in sorted(result, reverse=True)[:K]:\n\n    print(i)\n \nB. import sys; sys.setrecursionlimit(50000)\n\ninput = sys.stdin.readline\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\nimport heapq\n\nq = []\n\nS = set()\n\nheapq.heappush(q, (-(A[0]+B[0]+C[0]), 0, 0, 0))\n\nS.add((0, 0, 0))\n\nfor _ in range(K):\n\n    p, i, j, k = heapq.heappop(q)\n\n    print((-p))\n\n    if i + 1 < X and not (i+1, j, k) in S:\n\n        heapq.heappush(q, (-(A[i+1]+B[j]+C[k]), i+1, j, k))\n\n        S.add((i+1,j,k))\n\n    if j + 1 < Y and not (i, j+1, k) in S:\n\n        heapq.heappush(q, (-(A[i]+B[j+1]+C[k]), i, j+1, k))\n\n        S.add((i,j+1,k))\n\n    if k + 1 < Z and not (i, j, k+1) in S:\n\n        heapq.heappush(q, (-(A[i]+B[j]+C[k+1]), i, j, k+1))\n\n        S.add((i,j,k+1))\n", "output": "A", "improve_diff": 1.4050339765, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\ndef resolve():\n\n  N = int(eval(input()))\n\n  A = [int(x) for x in input().split(\" \")]\n\n  collection = Counter(A)\n\n  for i in range(1, N + 1):\n\n    print((collection[i]))\n\n  # results = [str(A.count(i))+'\\n' for i in range(1, N+1)]\n\n  # print('\\n'.join(results))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve() \nB. def resolve():\n\n  N = int(eval(input()))\n\n  A = [int(x) for x in input().split(\" \")]\n\n  results = [0] * N\n\n  for a in A:\n\n    results[a-1] += 1\n\n  for r in results:\n\n    print(r)\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()", "output": "B", "improve_diff": 1.5848113993, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\ntmp = []\n\nfor i in range(10):\n\n  for j in range(10):\n\n    solve = (4*(i+1))+(7*(j+1))\n\n    if solve <= 100:\n\n      tmp.append(solve)\n\nmultiples = sorted(list(set(tmp)))\n\nif N % 4 == 0 or N % 7 == 0 or N in multiples:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\") \nB. N = int(eval(input()))\n\nmultiple_4 = [x*4 for x in range(101) if x >= 1 and x <= 25]\n\nmultiple_7 = [x*7 for x in range(101) if x >= 1 and x <= 14]\n\nmultiple_4_7 = [x*4+7 for x in range(101) if x >= 1 and x <= 23]\n\nmultiple_7_4 = [x*7+4 for x in range(101) if x >= 1 and x <= 23]\n\ntmp = []\n\nfor i in range(10):\n\n  for j in range(10):\n\n    solve = (4*(i+1))+(7*(j+1))\n\n    if solve <= 100:\n\n      tmp.append(solve)\n\nmultiple_other = sorted(list(set(tmp)))\n\nif N in multiple_4 or N in multiple_7 or N in multiple_4_7 or N in multiple_7_4 or N in multiple_other:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")", "output": "A", "improve_diff": 1.0279838109, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\n\n\nans_l=[0]*(n+1)\n\nans=0\n\ndef con(a):\n\n    return int(a*(a-1)*0.5)\n\nfor i in range(n):\n\n    ans_l[l[i]]+=1\n\n#print(\"ans_l\",ans_l)\n\n#print(\"l\",l)\n\nfor j in ans_l:\n\n    ans+=con(j)\n\n# print(ans)\n\nfor i in range(n):\n\n    ans_2=ans\n\n    # print(\"ans_2_0:\",ans_2)\n\n    #print(\"ans_l[l[i]]\",ans_l[l[i]])\n\n    ans_2-=con(ans_l[l[i]])\n\n    #print(\"ans_2_1:\",ans_2)\n\n    \n\n    #print(\"ans_l[l[i]]:\",ans_l[l[i]]-1)\n\n    ans_2+=con(ans_l[l[i]]-1)\n\n    print(ans_2)\n \nB. n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\n\n\nans_l=[0]*(n+1)\n\nans=0\n\ndef con(a):\n\n    return int(a*(a-1)*0.5)\n\nfor i in l:\n\n    ans_l[i]+=1\n\n#print(\"ans_l\",ans_l)\n\n#print(\"l\",l)\n\nfor j in ans_l:\n\n    ans+=con(j)\n\n# print(ans)\n\nfor i in l:\n\n    ans_2=ans\n\n    # print(\"ans_2_0:\",ans_2)\n\n    #print(\"ans_l[i]\",ans_l[i])\n\n    ans_2-=con(ans_l[i])\n\n    #print(\"ans_2_1:\",ans_2)\n\n    \n\n    #print(\"ans_l[i]:\",ans_l[i]-1)   \n\n    ans_2+=con(ans_l[i]-1)\n\n    print(ans_2)", "output": "A", "improve_diff": 1.0246253396, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nV = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\n\n\nans = 0\n\n\n\nfor i,j in zip(V,C):\n\n    if i-j>0:\n\n        ans += i-j\n\n\n\nprint(ans)\n \nB. import numpy as np \n\n\n\nN = int(eval(input()))\n\nV = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\n\n\nans = 0\n\n\n\nfor i,j in zip(V,C):\n\n    if i-j>0:\n\n        ans += i-j\n\n\n\nprint(ans)", "output": "A", "improve_diff": 11.2122110875, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x=int(eval(input()))\n\nf=0\n\nif x == 2:\n\n\tprint((2))\n\nelse:\n\n\tfor i in range(x,10**6):\n\n\t\tfor j in range(2,i//2+2):\n\n\t\t\tif i%j == 0:\n\n\t\t\t\tbreak\n\n\t\telse:\n\n\t\t\tf=i\n\n\t\t\tbreak\n\n\tprint(f)\n \nB. from math import sqrt\n\nn=int(eval(input()))\n\ndef is_prime(n):\n\n    if n<2:\n\n        return False\n\n    for k in range(2,int(sqrt(n))+1):\n\n        if n%k==0:\n\n            return False\n\n    return True\n\nwhile not is_prime(n):\n\n    n+=1\n\nprint(n)", "output": "A", "improve_diff": 1.2887936561, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nh = list(map(int,input().split()))\n\ndp = [0]*(n)\n\nfor i in range(1,n):\n\n    if i>1:\n\n        dp[i] = min(dp[i-1] + abs(h[i]-h[i-1]), dp[i-2] + abs(h[i]-h[i-2]))\n\n    else:\n\n        dp[i] = dp[i-1] + abs(h[i]-h[i-1])\n\nprint((dp[-1])) \nB. n = int(eval(input()))\n\nh = list(map(int,input().split()))\n\n\n\ndp = [0]*n\n\ndp[1] = abs(h[0]-h[1])\n\n\n\nfor i in range(2,n):\n\n    dp[i] = min(dp[i-1]+abs(h[i-1]-h[i]),dp[i-2]+abs(h[i-2]-h[i]))\n\nprint((dp[-1]))", "output": "B", "improve_diff": 1.0279338324, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=list(map(int,input().split()))\n\n\n\na.sort()\n\nimport bisect\n\nans=0\n\n#A=[1,2,3,4,5] #\n\n#index = bisect.bisect_left(A, 3) #2 \n\n#index = bisect.bisect_right(A, 3) # 3 \n\n#A.insert(index, 3) #\n\n#print(a)\n\nfor i in range(len(a)-1):\n\n    for j in range(i+1,len(a)):\n\n        #a[i]<a[j]\n\n\n\n        #a[k]<a[i]<a[j]\n\n\n\n        #a[k]+a[i]>a[j]\n\n        #=>a[i]> a[k] >a[j]-a[i]\n\n\n\n        ll= bisect.bisect_right(a, a[j]-a[i])\n\n\n\n        rr= bisect.bisect_left(a, a[i])\n\n        if a[rr+1]==a[i]:\n\n            rr=i\n\n        #print(a[i],a[j],\"|\",ll,rr,max(0,rr-ll))\n\n        ans+=(max(0,rr-ll))\n\n\n\nprint(ans)\n\n\n\n\n \nB. n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\n\n\nl.sort()\n\nl.append(10**9)\n\ncnt=0\n\ni=0\n\n#print(l)\n\n\n\nwhile i<n-2:\n\n    j=i+1\n\n    while j<n-1:\n\n        LL=j+1\n\n        RR=n-1\n\n        #print(\"#\",l[i],l[j],l[LL],l[RR])\n\n        while LL<=RR:\n\n            k=(LL+RR)//2\n\n            if k==n:\n\n                break\n\n            #print(l)\n\n            #print(i,j,LL,RR,k)\n\n            #print(l[i]+l[j],l[k],l[k+1])\n\n            if l[i]+l[j]>l[k] and l[i]+l[j]<=l[k+1]:\n\n                cnt+=k-j\n\n                break\n\n            elif LL==RR:\n\n                break\n\n            elif l[i]+l[j]<=l[k]:\n\n                RR=k\n\n            elif l[i]+l[j]>l[k]:\n\n                LL=k+1\n\n            elif l[i]+l[j]<l[k] and k==j+1:\n\n                break\n\n        j+=1\n\n    i+=1\n\n\n\nprint(cnt)\n", "output": "B", "improve_diff": 1.4116539668, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from operator import mul\n\nfrom functools import reduce\n\n\n\nn, p = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\neven = 0\n\nodd = 0\n\nfor a in A:\n\n    if a % 2 == 0:\n\n        even += 1\n\n    else:\n\n        odd += 1\n\n\n\n\n\ndef cmb(n, r):\n\n    r = min(n-r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = reduce(mul, list(range(n, n - r, -1)))\n\n    under = reduce(mul, list(range(1, r + 1)))\n\n    return over // under\n\n\n\n\n\nans = 2**even\n\ncnt = 0\n\nif p == 0:\n\n    for i in range(0, odd+1, 2):\n\n        cnt += cmb(odd, i)\n\nelse:\n\n    for i in range(1, odd+1, 2):\n\n        cnt += cmb(odd, i)\n\n\n\nprint((ans*cnt))\n \nB. n, p = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nodd = False\n\nfor a in A:\n\n    if a % 2 == 1:\n\n        odd = True\n\n        break\n\n\n\nif odd:\n\n    print((2**(n-1)))\n\nelif p == 0:\n\n    print((2**n))\n\nelse:\n\n    print((0))\n", "output": "B", "improve_diff": 1.7110517279, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nmn = float(\"inf\")\n\nfor i in range(1,n):\n\n  count = 0\n\n  for s in str(i):\n\n    count += int(s)\n\n  for p in str(n-i):\n\n    count += int(p)\n\n  if count < mn:\n\n    mn = count\n\nprint(mn) \nB. n = int(eval(input()))\n\nmn = float(\"inf\")\n\nfor i in range(1,n):\n\n  if sum(map(int,str(i))) + sum(map(int,str(n-i))) < mn:\n\n    mn = sum(map(int,str(i))) + sum(map(int,str(n-i)))\n\nprint(mn)", "output": "B", "improve_diff": 1.4261736898, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\na=int(eval(input()))\n\nb=int(eval(input()))\n\nc=int(eval(input()))\n\nd=int(eval(input()))\n\ne=int(eval(input()))\n\nk=int(eval(input()))\n\n\n\nif e-a>k:\n\n    print(\":(\")\n\nelse:\n\n    print(\"Yay!\")\n\n\n\n\n \nB. # coding: utf-8\n\n# Your code here!\n\na=int(eval(input()))\n\nb=int(eval(input()))\n\nc=int(eval(input()))\n\nd=int(eval(input()))\n\ne=int(eval(input()))\n\nk=int(eval(input()))\n\nif e-a<=k:\n\n    print(\"Yay!\")\n\nelse:\n\n    print(\":(\")", "output": "B", "improve_diff": 1.0288999658, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\nS = deque(list(input().strip()))\n\nQ = int(eval(input()))\n\ncnt = 0\n\nfor i in range(Q):\n\n    q = list(input().split())\n\n    if len(q)==1:\n\n        cnt += 1\n\n    else:\n\n        F = int(q[1])\n\n        C = q[2]\n\n        if cnt%2==0:\n\n            if F==1:\n\n                S.appendleft(C)\n\n            else:\n\n                S.append(C)\n\n        else:\n\n            if F==1:\n\n                S.append(C)\n\n            else:\n\n                S.appendleft(C)\n\nif cnt%2==0:\n\n    print((\"\".join(S)))\n\nelse:\n\n    S = list(S)[::-1]\n\n    print((\"\".join(S))) \nB. from collections import deque\n\nS = deque(list(input().strip()))\n\nQ = int(eval(input()))\n\ncnt = 0\n\nfor _ in range(Q):\n\n    q = list(input().split())\n\n    if int(q[0])==1:\n\n        cnt += 1\n\n    else:\n\n        if cnt%2==0:\n\n            if int(q[1])==1:\n\n                S.appendleft(q[2])\n\n            else:\n\n                S.append(q[2])\n\n        else:\n\n            if int(q[1])==1:\n\n                S.append(q[2])\n\n            else:\n\n                S.appendleft(q[2])\n\nif cnt%2==0:\n\n    print((\"\".join(S)))\n\nelse:\n\n    S.reverse()\n\n    print((\"\".join(S)))", "output": "B", "improve_diff": 1.0088256359, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def sieve(x):\n\n    \"\"\"\n\n    Sieve of Eratosthenes\n\n    :param x: max value\n\n    :return: list of bool\n\n    \"\"\"\n\n\n\n    is_prime = [True] * (x + 1)\n\n    is_prime[0] = is_prime[1] = False\n\n\n\n    for i in range(2, x + 1):\n\n        if is_prime[i]:\n\n            for j in range(i * 2, x + 1, i):\n\n                is_prime[j] = False\n\n\n\n    return is_prime\n\n\n\n\n\nn = int(eval(input()))\n\n\n\nis_prime = sieve(10 ** 6)\n\nprimes = [i for i, e in enumerate(is_prime) if e]\n\n\n\nans = 0\n\nfor e in primes:\n\n    div = e\n\n    while n % div == 0:\n\n        n //= div\n\n        ans += 1\n\n        div *= e\n\n\n\n    while n % e == 0:\n\n        n //= e\n\n\n\nans += n != 1\n\n\n\nprint(ans)\n \nB. from math import sqrt\n\nfrom collections import defaultdict\n\n\n\nn = int(eval(input()))\n\n\n\nd = defaultdict(int)\n\nfor i in range(2, int(sqrt(n)) + 10):\n\n    while n % i == 0:\n\n        d[i] += 1\n\n        n //= i\n\n\n\nif n != 1:\n\n    d[n] += 1\n\n\n\nans = 0\n\nfor v in list(d.values()):\n\n    mn = 1\n\n    while v >= mn:\n\n        v -= mn\n\n        ans += 1\n\n        mn += 1\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 6.3507759816, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. r,g,b,n=list(map(int,input().split()))\n\n\n\nans=0\n\nfor R in range(n//r+1):\n\n    for B in range((n)//b+1):\n\n        if (R*r+B*b-n)<=0 and (R*r+B*b-n)%g==0:\n\n            ans+=1\n\n            \n\nprint(ans) \nB. r,g,b,n=list(map(int,input().split()))\n\nans=0\n\nr,g,b=max(r,g,b),r+g+b-max(r,g,b)-min(r,g,b),min(r,g,b)\n\nfor i in range(n//r+1):\n\n  for j in range(n//g+1):\n\n    if (n-i*r-j*g)%b or (n-i*r-j*g)<0:\n\n      continue\n\n    ans+=1\n\nprint(ans)\n", "output": "A", "improve_diff": 1.1711125403, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import*\n\na,b,x=list(map(int,input().split()))\n\nprint((atan(2*(b/a-x/a**3)if x>a**2*b/2else a*b**2/(2*x))/pi*180)) \nB. from math import*\n\ndef solve(B):\n\n    \u03b1=b*sin((90-B)*pi/180)/sin(B*pi/180)\n\n    s=\u03b1*b/2\n\n    if \u03b1>a:s-=(\u03b1-a)*(b-b*a/\u03b1)/2\n\n    return s>=x/a\n\na,b,x=list(map(int,input().split()))\n\nok=0\n\nng=90\n\nwhile ng-ok>1e-7:\n\n    mid=(ok+ng)/2\n\n    if solve(mid):ok=mid\n\n    else:ng=mid\n\nprint(ok)", "output": "A", "improve_diff": 1.1063959979, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. MOD=10**9+7\n\n\n\ndef powmod(a,p):\n\n  if p==0:\n\n    return 1\n\n  elif p==1:\n\n    return a\n\n  elif p%2==0:\n\n    powsq=powmod(a,p//2)\n\n    return (powsq**2)%MOD\n\n  elif p%2==1:\n\n    powsq=powmod(a,p//2)\n\n    return (a*powsq**2)%MOD\n\n\n\ndef invmod(a):\n\n  return powmod(a,MOD-2)\n\n\n\nX,Y=list(map(int,input().split()))\n\n\n\nif (X+Y)%3!=0:\n\n  print((0))\n\nelse:\n\n  u=(2*X-Y)//3\n\n  v=(-X+2*Y)//3\n\n  if u>=0 and v>=0:\n\n    #print(int(u),int(v))\n\n    ui=int(u)\n\n    vi=int(v)\n\n\n\n    bunshi=1\n\n    for i in range(vi):\n\n      bunshi*=ui+vi-i\n\n      bunshi%=MOD\n\n    bumbo=1\n\n    for i in range(vi):\n\n      bumbo*=vi-i\n\n      bumbo%=MOD\n\n\n\n    #calculate bunshi/bumbo%MOD as bunshi*bumbo^-1%MOD\n\n    print((bunshi*invmod(bumbo)%MOD))\n\n  else:\n\n    print((0)) \nB. MOD=10**9+7\n\nX,Y=list(map(int,input().split()))\n\n\n\ndef powmod(a,p):\n\n  if p==0:\n\n    return 1\n\n  elif p==1:\n\n    return a\n\n  else:\n\n    pow2=powmod(a,p//2)\n\n    if p%2==0:\n\n      return (pow2**2)%MOD\n\n    else:\n\n      return (a*pow2**2)%MOD\n\ndef invmod(a):\n\n  return powmod(a,MOD-2)\n\ndef comb_mod(n,r):\n\n  nPr=1\n\n  fact_r=1\n\n  for i in range(r):\n\n    nPr*=n-i\n\n    nPr%=MOD\n\n    fact_r*=r-i\n\n    fact_r%=MOD  \n\n  return (nPr*invmod(fact_r))%MOD\n\n\n\nif (X+Y)%3!=0:\n\n  print((0))\n\nelse:\n\n  u=(2*X-Y)//3\n\n  v=(-X+2*Y)//3\n\n  if u>=0 and v>=0:    \n\n    #print(u,v)\n\n    print((comb_mod(u+v,v)))\n\n  else:\n\n    print((0))", "output": "B", "improve_diff": 1.7568535946, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,a,b = list(map(int,input().split()))\n\nmod = 10**9+7\n\ndef combmod(n,k,mod):\n\n    x = y = 1\n\n    for i in range(min(k,n-k)):\n\n        x = x*(n-i)%mod\n\n        y = y*(i+1)%mod\n\n    return x * pow(y, mod-2, mod) % mod\n\nans = (((pow(2, n, mod) - 1)%mod - combmod(n, a, mod))%mod - combmod(n, b, mod))%mod\n\nprint(ans) \nB. n,a,b = list(map(int,input().split()))\n\nmod = 10**9+7\n\na = min(a,n-a)\n\nb = min(b,n-b)\n\nm = max(a,b)\n\nX = [0]*(m+1)\n\nY = [0]*(m+1)\n\nX[0] = 1\n\nX[1] = n\n\nY[0] = Y[1] = 1\n\n\n\nfor i in range(2,m+1):\n\n    X[i] = X[i-1]*(n-i+1)%mod\n\n    Y[i] = Y[i-1]*i%mod\n\n    \n\nans = (((pow(2,n,mod)-1)%mod-X[a]*pow(Y[a],mod-2,mod)%mod)%mod-X[b]*pow(Y[b],mod-2,mod)%mod)%mod\n\nprint(ans)", "output": "A", "improve_diff": 1.2561740736, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import deque \n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    to = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b = map(int, readline().split())\n\n        a -= 1\n\n        b -= 1\n\n        to[a].append(b)\n\n        to[b].append(a)\n\n    score = [0 for  _ in range(N)]\n\n    for _ in range(Q):\n\n        p, x = map(int, readline().split()) \n\n        p -= 1\n\n        score[p] += x  \n\n    \n\n    dq = deque() \n\n    dq.append(0)\n\n    done = [0 for _ in range(N)]\n\n    done[0] = 1\n\n\n\n    while len(dq)>0:\n\n        v = dq.popleft()\n\n        for nx in to[v]:\n\n            if done[nx]:\n\n                continue\n\n            score[nx] += score[v]\n\n            done[nx] = 1\n\n            dq.append(nx)\n\n    for i in range(N):\n\n        if i==N-1:\n\n            print(score[i])\n\n        else:\n\n            print(score[i], end=' ')\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nfrom copy import deepcopy\n\nfrom collections import deque\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    m = map(int, read().split())\n\n    n = deepcopy(m)\n\n    to = [[] for _ in range(N)]\n\n    for a, b in [(a-1, b-1) for a, b in zip(m, m)][:N-1]:\n\n        to[a].append(b)\n\n        to[b].append(a)\n\n    score = [0 for _ in range(N)]\n\n    for p, x in [(p-1, x) for p, x in zip(n, n)][N-1:]:\n\n        score[p] += x\n\n\n\n    dq = deque()\n\n    dq.append(0)\n\n    done = [0 for _ in range(N)]\n\n    done[0] = 1\n\n    while len(dq)>0:\n\n        node = dq.popleft()\n\n        for nx in to[node]: \n\n            if done[nx] == 1:\n\n                continue \n\n            done[nx] = 1\n\n            score[nx] += score[node]\n\n            dq.append(nx)\n\n    for i in score:\n\n        print(i, end=' ')\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0913879474, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python\n\n# coding: utf-8\n\n\n\nN, A, B, C = list(map(int, input().split()))\n\nll = []\n\nfor _ in range(N):\n\n    ll.append(int(eval(input())))\n\n\n\ndef dfs(n, a, b, c):\n\n    if n == N:\n\n        if a == 0 or b == 0 or c == 0: return float('inf')\n\n        return abs(A-a) + abs(B-b) + abs(C-c)\n\n    ca = dfs(n+1, a+ll[n], b, c)\n\n    if a > 0: ca += 10\n\n    cb = dfs(n+1, a, b+ll[n], c)\n\n    if b > 0: cb += 10\n\n    cc = dfs(n+1, a, b, c+ll[n])\n\n    if c > 0: cc += 10\n\n    cn = dfs(n+1, a, b, c)\n\n    return min(ca, cb, cc, cn)\n\n\n\n\n\ndef main():\n\n    print((dfs(0, 0, 0, 0)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. #!/usr/bin/env python\n\n# coding: utf-8\n\n\n\nimport itertools\n\n\n\ndef main():\n\n    N, A, B, C = list(map(int, input().split()))\n\n    ll = []\n\n    for _ in range(N):\n\n        ll.append(int(eval(input())))\n\n\n\n    cand = []\n\n    ids = set(range(N))\n\n    for a in range(1, N-1):\n\n        for b in range(1, N-a):\n\n            for c in range(1, N-a-b+1):\n\n                cand.append((a, b, c))\n\n    best_cost = -1\n\n    for a, b, c in cand:\n\n        la = itertools.combinations(ids, a)\n\n        for a_ in la:\n\n            lb = itertools.combinations(ids-set(a_), b)\n\n            for b_ in lb:\n\n                lc = itertools.combinations(ids-set(a_)-set(b_), c)\n\n                for c_ in lc:\n\n                    cost = (len(a_)-1)*10 + abs(sum(ll[e] for e in a_)-A)\n\n                    cost += (len(b_)-1)*10 + abs(sum(ll[e] for e in b_)-B)\n\n                    cost += (len(c_)-1)*10 + abs(sum(ll[e] for e in c_)-C)\n\n                    if best_cost == -1 or cost < best_cost:\n\n                        best_cost = cost\n\n    print(best_cost)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 2.222733138, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python3\n\n\n\nimport sys\n\nimport math\n\nfrom bisect import bisect_right as br\n\nfrom bisect import bisect_left as bl\n\nsys.setrecursionlimit(2147483647)\n\nfrom heapq import heappush, heappop,heappushpop\n\nfrom collections import defaultdict\n\nfrom itertools import accumulate\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom operator import itemgetter\n\nfrom itertools import permutations\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nn = I()\n\na = [I() for _ in range(n)]\n\ndp = [10**10]*(n)\n\nfor i in range(n):\n\n    r = br(dp, -a[i])\n\n    dp[r] = -a[i]\n\nprint((n - dp.count(10**10)))         \nB. #!/usr/bin/env python3\n\nimport sys\n\nimport math\n\nfrom bisect import bisect_right as br\n\nfrom bisect import bisect_left as bl\n\nsys.setrecursionlimit(2147483647)\n\nfrom heapq import heappush, heappop,heappushpop\n\nfrom collections import defaultdict\n\nfrom itertools import accumulate\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom operator import itemgetter\n\nfrom itertools import permutations\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\n\n\ndef main():\n\n  n = I()\n\n  a = [I() for _ in range(n)]\n\n  dp = [inf]*n\n\n  for i in range(n):\n\n    r = br(dp,-a[i])\n\n    dp[r] = -a[i]\n\n  print((n-dp.count(inf)))\n\n  return\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "output": "A", "improve_diff": 1.036391997, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import product\n\nH, W, K = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\n# dp[i][j]:= i, j\n\ndp = [[0] * W for i in range(H + 1)]\n\ndp[0][0] = 1\n\n\n\n\n\ndef calc(x):\n\n    if x < 0:\n\n        return 1\n\n    ret = 0\n\n    for p in product(['0', '1'], repeat=x):\n\n        p = ''.join(p)\n\n        if '11' not in p:\n\n            ret += 1\n\n    return ret\n\n\n\n\n\nfor i in range(1, H + 1):\n\n    for j in range(W):\n\n        tmp = 0\n\n        if j > 0:  # \n\n            tmp += dp[i - 1][j - 1] * calc(j - 2) * calc(W - j - 2) % mod\n\n\n\n        # \n\n        tmp += dp[i - 1][j] * calc(j - 1) * calc(W - j - 2) % mod\n\n\n\n        if j + 1 < W:  # \n\n            tmp += dp[i - 1][j + 1] * calc(j - 1) * calc(W - j - 3) % mod\n\n\n\n        dp[i][j] = tmp\n\n\n\nprint((dp[H][K - 1] % mod))\n \nB. H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef transition(w):\n\n    X = [1, 2, 3, 5, 8, 13, 21, 34]\n\n    if w >= 0:\n\n        return X[w]\n\n    else:\n\n        return 1\n\n\n\n\n\n# hw\n\ndp = [[0] * W for h in range(H + 1)]\n\ndp[0][0] = 1\n\n\n\nfor h in range(H):\n\n    for w in range(W):\n\n        # \n\n        dp[h + 1][w] += dp[h][w] * (transition(w - 1) * transition(W - w - 2))\n\n        dp[h + 1][w] %= MOD\n\n\n\n        # \n\n        if w + 1 < W:\n\n            dp[h + 1][w + 1] += dp[h][w] * (transition(w - 1) * transition(W - w - 3))\n\n            dp[h + 1][w + 1] %= MOD\n\n\n\n        # \n\n        if w - 1 >= 0:\n\n            dp[h + 1][w - 1] += dp[h][w] * (transition(w - 2) * transition(W - w - 2))\n\n            dp[h + 1][w - 1] %= MOD\n\n\n\nprint((dp[H][K - 1]))\n", "output": "B", "improve_diff": 1.0108638698, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef I(): return int(eval(input()))\n\n\n\n\n\nn = I()\n\ncnt = [0] * 10001\n\nfor x in range(1, 101):\n\n    for y in range(1, 101):\n\n        for z in range(1, 101):\n\n            v = x**2 + y**2 + z**2 + x*y + y*z + z*x\n\n            if v <= n:\n\n                cnt[v] += 1\n\n\n\nfor i in range(1, n + 1):\n\n    print((cnt[i]))\n \nB. import sys\n\n\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef I(): return int(eval(input()))\n\n\n\n\n\nn = I()\n\ncnt = [0] * 10001\n\nfor x in range(1, 101):\n\n    for y in range(1, 101):\n\n        for z in range(1, 101):\n\n            v = x*x + y*y + z*z + x*y + y*z + z*x\n\n            if v <= n:\n\n                cnt[v] += 1\n\n\n\nfor i in range(1, n + 1):\n\n    print((cnt[i]))\n", "output": "B", "improve_diff": 1.3458018319, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\np = 10**9 + 7\n\n\n\ndef fact(n):\n\n    n_ = 1\n\n    yield n_\n\n    for i in range(1, n+1):\n\n         n_ = (n_*i) % p\n\n         yield n_\n\n\n\ndef invfact(n, f, p):\n\n    m = pow(f[n], p-2, p)\n\n    yield m\n\n    for i in range(n, 0, -1):\n\n        m = m * i % p\n\n        yield m\n\n\n\nans = 0\n\nm = n - 1\n\nf = list(fact(m))\n\nrf = list(invfact(m, f, p))\n\nrf.reverse()\n\nperm = 0\n\n\n\nfor k in range((n+1)//2, n):\n\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n\n    ans += (perm_ - perm) %p * k % p\n\n    ans %= p\n\n    perm = perm_\n\n\n\nprint(ans) \nB. n = int(eval(input()))\n\np = 10**9 + 7\n\n\n\ndef fact(n):\n\n    n_ = 1\n\n    yield n_\n\n    for i in range(1, n+1):\n\n         n_ = (n_*i) % p\n\n         yield n_\n\n\n\ndef invfact(n, f, p):\n\n    m = pow(f[n], p-2, p)\n\n    yield m\n\n    for i in range(n, 0, -1):\n\n        m = m * i % p\n\n        yield m\n\n\n\nans = 0\n\nm = n - 1\n\nf = list(fact(m))\n\nrf = list(invfact(m, f, p))\n\nrf.reverse()\n\nperm = 0\n\n\n\nfor k in range((n+1)//2, n):\n\n    b = m - k\n\n    a = (m - 1) - (2 * b)\n\n    perm_ = f[a+b] * rf[a] %p * f[k] % p\n\n    ans += (perm_ - perm) %p * k % p\n\n    ans %= p\n\n    perm = perm_\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0541255875, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\"\"\"\n\nSpyder\n\n\n\n\n\n\"\"\"\n\nimport math\n\n\n\na,b = list(map(int, input().split()))\n\n\n\nalpha = []\n\nbeta = []\n\n\n\nfor x in range(math.floor(a/0.08), math.floor(a/0.05)):\n\n    if math.floor(x * 0.08) == a:\n\n        alpha.append(x)\n\nfor y in range(math.floor(b/0.10), math.floor(b/0.05)):\n\n    if math.floor(y * 0.1) == b:\n\n        beta.append(y)\n\n\n\nif min(alpha) in beta:\n\n    print((min(alpha)))\n\nelif min(beta) in alpha:\n\n    print((min(beta)))\n\nelse:\n\n    print(\"-1\")    \n \nB. import math\n\nA,B = (int(x) for x in input().split())\n\nA1 = math.ceil(A/0.08)\n\nA2 = math.ceil((A+1)/0.08)\n\n\n\n\"\"\"if float((A+1)/0.08).is_integer() == True:\n\n    A2 = math.floor((A+1)/0.08)\n\nelse:\n\n    A2 = math.floor((A+1)/0.08) + 1\n\n\"\"\"\n\nB1 = math.ceil(B/0.1)\n\nB2 = math.ceil((B+1)/0.1)\n\n\n\n\"\"\"if float((B+1)/0.1).is_integer() == True:\n\n    B2 = math.floor((B+1)/0.1)\n\nelse:\n\n    B2 = math.floor((B+1)/0.1) + 1\n\n\"\"\"\n\na = list(range(A1, A2))\n\nb = list(range(B1, B2))\n\nc = set(a) & set(b)\n\nif len(c) == 0:\n\n          print((-1))\n\nelse:\n\n          print((min(c)))", "output": "B", "improve_diff": 1.0155628561, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. inf = 10**15\n\nmod = 10**9+7\n\nh,n = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ndp = [[inf for j in range(h+1)] for i in range(n+1)]\n\nfor i in range(n):\n\n    dp[i][0] = 0\n\n    a,b = ab[i]\n\n    for j in range(h):\n\n        if j+1-a>=0:\n\n            dp[i+1][j+1] = min(dp[i+1][j+1-a]+b, dp[i][j+1], dp[i][j+1-a]+b)\n\n        else:\n\n            dp[i+1][j+1] = min(dp[i][j+1], b)\n\nprint((dp[n][h])) \nB. h,n = list(map(int, input().split()))\n\nmagic = []\n\nINF = 10**8\n\ndp = [[INF for j in range(h+1)] for i in range(n+1)] #ji\n\n \n\nfor i in range(n):\n\n    a,b = list(map(int, input().split()))\n\n    magic.append([a, b])\n\n \n\nfor i in range(n):\n\n    for j in range(h):\n\n        if j+1 > magic[i][0]:\n\n            dp[i+1][j+1] = min(dp[i][j+1], dp[i][j+1-magic[i][0]] + magic[i][1], dp[i+1][j+1-magic[i][0]] + magic[i][1])\n\n        else:\n\n            dp[i+1][j+1] = min(dp[i][j+1], magic[i][1])\n\n            \n\nprint((dp[n][h]))", "output": "A", "improve_diff": 1.0958140046, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K = int(eval(input()))\n\na = 7\n\n\n\nfor n in range(1,1+K):\n\n  if a%K==0:\n\n    print(n)\n\n    exit()\n\n  a = (a*10+7)%K\n\n\n\nprint((-1)) \nB. K = int(eval(input()))\n\na = 7\n\n\n\nfor k in range(1,K+1):\n\n  if a%K==0:\n\n    print(k)\n\n    exit()\n\n  a = (10*a+7)%K\n\n\n\nprint((-1))", "output": "A", "improve_diff": 1.0393512592, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import bisect\n\nN,M=list(map(int, input().split()))\n\nP=[[] for _ in range(N)]\n\nL=[]\n\nfor i in range(M):\n\n    p,y=list(map(int, input().split()))\n\n    L.append((p,y))\n\n    P[p-1].append(y)\n\n\n\nnewP=[]\n\nfor p in P:\n\n    p=sorted(p)\n\n    newP.append(p)\n\n\n\nfor i in range(M):\n\n    t=L[i]\n\n    p,y=t\n\n    num=bisect.bisect_right(newP[p-1],y)\n\n    \n\n    p=str(p).zfill(6)\n\n    num=str(num).zfill(6)\n\n    print((p+num))\n \nB. \n\nN, M=list(map(int, input().split()))\n\n#A=[]\n\nY=[[] for _ in range(N)] #\n\nfor i in range(M):\n\n  p,y=list(map(int, input().split()))\n\n  #A.append((p,y))\n\n  Y[p-1].append([y,i+1])\n\n\n\nfor i in range(N):\n\n  if Y[i]:\n\n    Y[i].sort(key=lambda x: x[0])\n\n#index\n\nans=[]\n\nfor i in range(N):\n\n  for j,L in enumerate(Y[i]):\n\n    p,y,n=i+1, L[0],L[1]\n\n    ans.append((n,p,j+1))\n\nans=sorted(ans)\n\nfor n,p,y in ans:\n\n  a=(6-len(str(p)))*\"0\"+str(p)+(6-len(str(y)))*\"0\"+str(y)\n\n  print(a)", "output": "B", "improve_diff": 1.4437857726, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC79 D - Wall\n\nH, W = list(map(int, input().split()))\n\nC = [list(map(int, input().split())) for _ in range(10)]\n\nA = [list(map(int, input().split())) for _ in range(H)]\n\n\n\ndef f_warshall(C):\n\n  for k in range(10):\n\n    for i in range(10):\n\n      for j in range(10):\n\n        C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n\n\n\nf_warshall(C)\n\n\n\ncost = 0\n\nfor i in range(H):\n\n  for j in range(W):\n\n    if A[i][j] == -1:\n\n      continue\n\n    else:\n\n      cost += C[A[i][j]][1]\n\n\n\nprint((int(cost))) \nB. # ABC79 D - Wall\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\nH, W = list(map(int, input().split()))\n\nC = [list(map(int, input().split())) for _ in range(10)]\n\nA = [list(map(int, input().split())) for _ in range(H)]\n\n\n\nC = floyd_warshall(C)  \n\n\n\ncost = 0\n\nfor i in range(H):\n\n    for a in A[i]:\n\n        if a != -1:\n\n            cost += C[a][1]\n\n\n\nprint((int(cost)))", "output": "A", "improve_diff": 15.0180722822, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nabc  = [[], [], []]\n\n\n\nabc = [list(map(int, input().split())) for _ in range(n)] # DB, ok\n\n#print(abc)\n\n\n\ndp = [[0,0,0] for _ in range(n)]\n\ndp[0] = abc[0]\n\n#print(dp)\n\n\n\nfor i in range(1, n):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + abc[i][j]) # DB\n\n\n\nprint((max(dp[-1]))) \nB. n = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(n)]\n\n\n\ndp = [[0,0,0] for _ in range(n)]\n\ndp[0] = l[0]\n\n\n\nfor i in range(1, n):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + l[i][j])\n\n\n\nprint((max(dp[-1])))", "output": "B", "improve_diff": 1.0392562507, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\ndef sieve_of_eratosthenes(n=5 * 10 ** 6):\n\n  sieve = [1] * (n + 1); sieve[0] = sieve[1] = 0\n\n  for i in range(2, int(n ** 0.5) + 1):\n\n    if not sieve[i]: continue\n\n    for j in range(i * 2, n, i): sieve[j] = 0\n\n  prime_numbers = [i for i in range(2, n + 1) if sieve[i]]\n\n  return sieve, prime_numbers\n\n\n\nis_prime, prime_numbers = sieve_of_eratosthenes(10 ** 3)\n\n\n\ndef prime_factorize(n):\n\n  res = dict()\n\n  if n < 2: return res\n\n  border = int(n ** 0.5)\n\n  for p in prime_numbers:\n\n    if p > border: break\n\n    while n % p == 0: res[p] = res.get(p, 0) + 1; n //= p\n\n    if n == 1: return res\n\n  res[n] = 1\n\n  return res\n\n\n\ndef prime_factorize_factorial(n):\n\n  res = dict()\n\n  for i in range(2, n + 1):\n\n    for p, c in list(prime_factorize(i).items()): res[p] = res.get(p, 0) + c\n\n  return res\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n  res = 1\n\n  for c in list(prime_factorize_factorial(n).values()):\n\n    res *= c + 1; res %= MOD\n\n  print(res)\n\n\n\nif __name__ ==  '__main__':\n\n  main() \nB. import sys\n\nfrom collections import defaultdict\n\n\n\ndef sieve_of_eratosthenes(n=5 * 10 ** 6):\n\n  sieve = [1] * (n + 1); sieve[0] = sieve[1] = 0\n\n  for i in range(2, int(n ** 0.5) + 1):\n\n    if not sieve[i]: continue\n\n    for j in range(i * 2, n, i): sieve[j] = 0\n\n  prime_numbers = [i for i in range(2, n + 1) if sieve[i]]\n\n  return sieve, prime_numbers\n\n\n\nis_prime, prime_numbers = sieve_of_eratosthenes(10 ** 3)\n\n\n\ndef prime_factorize(n):\n\n  res = defaultdict(int)\n\n  if n < 2: return res\n\n  border = int(n ** 0.5)\n\n  for p in prime_numbers:\n\n    if p > border: break\n\n    while n % p == 0: res[p] += 1; n //= p\n\n    if n == 1: return res\n\n  res[n] = 1\n\n  return res\n\n\n\ndef prime_factorize_factorial(n):\n\n  res = defaultdict(int)\n\n  for i in range(2, n + 1):\n\n    for p, c in list(prime_factorize(i).items()): res[p] += c\n\n  return res\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n  res = 1\n\n  for c in list(prime_factorize_factorial(n).values()):\n\n    res *= c + 1; res %= MOD\n\n  print(res)\n\n\n\nif __name__ ==  '__main__':\n\n  main()", "output": "A", "improve_diff": 1.477421459, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nhs = list(map(int, input().split()))\n\n\n\nif N == 2:\n\n  print((abs(hs[1] - hs[0])))\n\n  exit()\n\n\n\ntotal_cost = [-1 for _ in range(N)]\n\ntotal_cost[0] = 0\n\ntotal_cost[1] = abs(hs[1]-hs[0])\n\n\n\nfor i in range(2, N):\n\n  total_cost[i] = min(abs(hs[i]-hs[i-1]) + total_cost[i-1], abs(hs[i]-hs[i-2]) + total_cost[i-2])\n\n\n\nprint((total_cost[N-1]))\n \nB. import sys\n\n# import pdb\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nhs = list(map(int, input().split()))\n\n\n\ndp_list = [-1 for _ in range(N)]\n\ndp_list[0] = 0\n\ndp_list[1] = abs(hs[1] - hs[0])\n\n\n\nsys.setrecursionlimit(1000000)\n\ndef dp_memo(p):\n\n  if dp_list[p] != -1:\n\n    return dp_list[p]\n\n\n\n  result = min(dp_memo(p-1) + abs(hs[p] - hs[p-1]), dp_memo(p-2) + abs(hs[p] - hs[p-2]))\n\n  dp_list[p] = result\n\n  return result\n\n\n\n\n\ndef dp_recur():\n\n  cost1 = 0\n\n  cost2 = abs(hs[1] - hs[0])\n\n\n\n  if N == 2:\n\n    print(cost2)\n\n    exit()\n\n  # pdb.set_trace()\n\n  for i in range(2, N):\n\n    cost3 = min(cost2 + abs(hs[i] - hs[i-1]), cost1 + abs(hs[i] - hs[i-2]))\n\n    cost1 = cost2\n\n    cost2 = cost3\n\n  return cost3\n\n\n\n# print(dp_recur())\n\nprint((dp_memo(N-1)))\n", "output": "B", "improve_diff": 1.1110387903, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,K = list(map(int,input().split()))\n\na = [int(i) for i in input().split()]\n\nans = float(\"INF\")\n\nfor i in range(1<<N):\n\n    cnt = 0\n\n    tmp = a[:]\n\n    m = tmp[0]\n\n    for j in range(1,N):\n\n        if i >> j & 1 and m >= tmp[j]:\n\n            cnt += m - tmp[j] + 1\n\n            tmp[j] = m + 1\n\n        m = max(m,tmp[j])\n\n    color = 1\n\n    m = tmp[0]\n\n    for j in range(1,N):\n\n        if tmp[j] > m:\n\n            color += 1\n\n            m = tmp[j]\n\n    if color >= K: ans = min(ans,cnt)\n\nprint(ans) \nB. from itertools import combinations as comb\n\nN,K = list(map(int,input().split()))\n\na = [int(i) for i in input().split()]\n\nans = float(\"INF\")\n\n\n\nfor c in comb(list(range(1,N)),K-1):\n\n    cnt = 0\n\n    color = 0\n\n    mh = a[0]\n\n    for i in range(1,N):\n\n        if i == c[color]:\n\n            cnt += max(mh-a[i]+1,0)\n\n            color += 1\n\n            if color == K-1: break\n\n            mh = max(mh+1,a[i])\n\n        else:\n\n            mh = max(mh,a[i])\n\n    ans = min(cnt ,ans)\n\nprint(ans)", "output": "A", "improve_diff": 1.0381128616, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\ndef fact(n):\n\n    mod = int(1e9)+7\n\n    return math.factorial(n)%mod\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nif abs(N-M) >= 2:\n\n    print((0))\n\n    exit()\n\n\n\nmod = int(1e9)+7\n\n\n\nif N == M:\n\n    print((2*fact(N)*fact(M)%mod))\n\nelse:\n\n    print((fact(N)*fact(M)%mod)) \nB. import math\n\ndef fact(n):\n\n    return math.factorial(n)\n\n\n\nN,M = list(map(int,input().split()))\n\n\n\nif abs(N-M) >= 2:\n\n    print((0))\n\n    exit()\n\n\n\nmod = int(1e9)+7\n\n\n\nif N == M:\n\n    print((2*fact(N)*fact(M)%mod))\n\nelse:\n\n    print((fact(N)*fact(M)%mod))", "output": "A", "improve_diff": 1.0294224525, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nx = list(map(int, input().split()))\n\n\n\nx_mean = sum(x)/n\n\np1 = int(x_mean)\n\np2 = p1 + 1\n\n\n\nif abs(x_mean - p1) > abs(x_mean - p2):\n\n    p = p2\n\nelse:\n\n    p = p1\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans += (x[i]-p)**2\n\nprint(ans) \nB. n = int(eval(input()))\n\nx = list(map(int, input().split()))\n\n\n\nf = 10**100\n\n\n\nfor p in range(min(x), max(x) + 1):\n\n    l = [(x[i] - p)**2 for i in range(n)]\n\n    f1 = sum(l)\n\n    f = min(f, f1)\n\n\n\nprint(f)", "output": "A", "improve_diff": 1.0465784609, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,y,z = list(map(int, input().split()))\n\n\n\nprint((int((x-z)/(y+z)))) \nB. x,y,z = list(map(int,input().split()))\n\n\n\nprint(((x-z)//(y+z)))", "output": "B", "improve_diff": 1.0394526078, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # https://atcoder.jp/contests/abc095/tasks/arc096_a\n\n\n\n\n\n# A1\u2192A\n\n# B1\u2192B\n\n# A,B\u2192AB\n\n\n\n\n\n# 2AB<=A+Bmin(X,Y)\n\n# A\u2192A<AB\u2192AAB\n\n# B\u2192\n\n\n\n# 2AB<=A+B\n\n# A,B<AB\u2192A,B\n\n# A<2AB \u2192A\n\n# \n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n# \n\nans = 0\n\nif 2 * c <= a + b:\n\n    n = min(x, y)\n\n    ans += 2 * n * c\n\n    x -= n\n\n    y -= n\n\n\n\n# print(x, y, ans)\n\n\n\n# A\n\nif a <= 2 * c:\n\n    ans += x * a\n\nelse:\n\n    ans += x * 2 * c\n\n\n\nif b <= 2 * c:\n\n    ans += y * b\n\nelse:\n\n    ans += y * 2 * c\n\nprint(ans)\n \nB. import sys\n\nsys.setrecursionlimit(1 << 25)\n\nread = sys.stdin.readline\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H):\n\n    '''\n\n    H is number of rows\n\n    AB\n\n    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, read().split())))\n\n    return tuple(map(list, list(zip(*ret))))\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, read().split())))\n\n    return ret\n\n    # return [list(map(int, read().split())) for _ in range(H)] # pypy\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom operator import itemgetter\n\nfrom itertools import product, permutations, combinations\n\nfrom bisect import bisect_left, bisect_right  # , insort_left, insort_right\n\n\n\n# https://atcoder.jp/contests/abc095/tasks/arc096_a\n\nA, B, C, X, Y = read_ints()\n\n\n\n# \n\nbuyed = min(X, Y)\n\nc1 = min(A + B, 2 * C) * buyed\n\nX -= buyed\n\nY -= buyed\n\n\n\nif X:\n\n    c2 = min(A, 2 * C) * X\n\nelif Y:\n\n    c2 = min(B, 2 * C) * Y\n\nelse:\n\n    c2 = 0\n\n\n\nprint((c1 + c2))\n", "output": "A", "improve_diff": 1.6203269845, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\n\n\nwhile True:\n\n    N, K, S = list(map(int, input().split()))\n\n    if N == K == S == 0:\n\n        break\n\n    print((sum(1 for l in itertools.combinations(list(range(1, N+1)), K) if sum(l) == S))) \nB. import itertools\n\n\n\nwhile True:\n\n    N, K, S = list(map(int, input().split()))\n\n    if N == K == S == 0:\n\n        break\n\n    ans = 0\n\n    for l in itertools.combinations(list(range(1, N+1)), K):\n\n        if sum(l) == S:\n\n            ans += 1\n\n    print(ans)", "output": "A", "improve_diff": 1.4832937071, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. li = list(map(int,input().split()))\n\nout = int(li[0] / (li[1] + li[2])) * li[1]\n\nremain = li[0] - int(li[0] / (li[1] + li[2])) *  (li[1] + li[2])\n\nif(remain > li[1]):\n\n    out += li[1]\n\nelse:\n\n    out += remain\n\nprint(out) \nB. N, A, B = list(map(int, input().split()))\n\nn = int(N / (A + B))\n\nm = min(N - n * (A + B), A)\n\nprint((n * A + m))", "output": "B", "improve_diff": 1.0350654582, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\n\n\na = np.zeros(201)\n\n\n\nfor d in range(1,201,2):\n\n  a[d::2*d]+=1\n\n\n\na=(a==8).cumsum()\n\n\n\nN = int(eval(input()))\n\nprint((a[N]))\n \nB. N = int(eval(input()))\n\na = 0\n\n\n\nfor i in range(1,1+N,2):\n\n  n = 0\n\n  for j in range(1,1+i,2):\n\n    if i%j==0:\n\n      n+=1\n\n    if n==8:\n\n      a+=1\n\n\n\nprint(a)", "output": "B", "improve_diff": 12.4603295781, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_left\n\n\n\nN = int(eval(input()))\n\nA = [int(eval(input())) for _ in range(N)]\n\n\n\n# \n\ndp = [-1 for _ in range(N)]\n\nfor a in A:\n\n    dp[bisect_left(dp, a) - 1] = a\n\nans = sum(x >= 0 for x in dp)\n\n\n\nprint(ans)\n \nB. from bisect import bisect\n\n\n\nN = int(eval(input()))\n\nA = [int(eval(input())) for _ in range(N)]\n\n\n\nINF = 10**10\n\ndp = [-INF]\n\nfor a in A:\n\n    if a <= -dp[-1]:\n\n        dp.append(-a)\n\n    else:\n\n        i = bisect(dp, -a)\n\n        dp[i] = -a\n\nans = len(dp) - 1\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0310033475, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\n\n\n\n\ndef p_g_dp():\n\n    N, M = list(map(int, input().split()))\n\n    outs = [[] for _ in range(N)]\n\n    ins = [0] * N\n\n    for _ in range(M):\n\n        f, t = list(map(int, input().split()))\n\n        outs[f - 1].append(t - 1)\n\n        ins[t - 1] += 1\n\n    q = deque(t for t in range(N) if ins[t] == 0)\n\n    res = []\n\n    dp = [0] * N\n\n    while q:\n\n        f = q.popleft()\n\n        res.append(f)\n\n        for t in outs[f]:\n\n            ins[t] -= 1\n\n            if ins[t] == 0:\n\n                q.append(t)\n\n                dp[t] = max(dp[t], dp[f] + 1)\n\n    print((max(dp)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    p_g_dp()\n \nB. import sys\n\n\n\n\n\ndef recursion_g(eges, length, f):\n\n    if length[f] != -1:\n\n        return length[f]\n\n    memo = [0]\n\n    for t in eges[f]:\n\n        memo.append(recursion_g(eges, length, t) + 1)\n\n    length[f] = max(memo)\n\n    return length[f]\n\n\n\n\n\ndef p_g():\n\n    sys.setrecursionlimit(10 ** 6)\n\n    N, M = list(map(int, input().split()))\n\n    edges = [[] for _ in range(N)]\n\n    length = [-1] * N\n\n    for _ in range(M):\n\n        x, y = list(map(int, input().split()))\n\n        edges[x - 1].append(y - 1)\n\n\n\n    for i in range(N):\n\n        recursion_g(edges, length, i)\n\n    print((max(length)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    p_g()\n", "output": "B", "improve_diff": 1.4151255498, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nsrc = [int(eval(input())) for i in range(N)]\n\nnow = 0\n\nfor i in range(N):\n\n    a = src[now] - 1\n\n    if a == 1:\n\n        print((i+1))\n\n        exit()\n\n    now = a\n\nprint((-1)) \nB. N = eval(input())\n\narr = [eval(input())-1 for i in range(N)]\n\n\n\nnow = 0\n\ncount = 0\n\nwhile (now != 1):\n\n    count += 1\n\n    now = arr[now]\n\n    if count > 100000:\n\n        count = -1\n\n        break\n\nprint(count)\n", "output": "A", "improve_diff": 1.167968711, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.data = [-1] * size\n\n\n\n    def find(self, x):\n\n        if self.data[x] < 0:\n\n            return x\n\n        else:\n\n            self.data[x] = self.find(self.data[x])\n\n            return self.data[x]\n\n\n\n    def union(self, x, y):\n\n        x, y = self.find(x), self.find(y)\n\n        if x != y:\n\n            if self.data[y] < self.data[x]:\n\n                x, y = y, x\n\n            self.data[x] += self.data[y]\n\n            self.data[y] = x\n\n        return (x != y)\n\n\n\n    def same(self, x, y):\n\n        return (self.find(x) == self.find(y))\n\n\n\n    def size(self, x):\n\n        return -self.data[self.find(x)]\n\n\n\n\n\ndef main():\n\n    MAX = 10 ** 5 + 1\n\n    uf = UnionFind(2 * MAX)\n\n\n\n    N, *XY = list(map(int, open(0).read().split()))\n\n\n\n    for x, y in zip(*[iter(XY)] * 2):\n\n        uf.union(x, y + MAX)\n\n\n\n    X = Counter(uf.find(i) for i in range(MAX))\n\n    Y = Counter(uf.find(i) for i in range(MAX, MAX * 2))\n\n    res = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n\n\n    print((res - N))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. from collections import Counter\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.data = [-1] * size\n\n\n\n    def find(self, x):\n\n        if self.data[x] < 0:\n\n            return x\n\n        else:\n\n            self.data[x] = self.find(self.data[x])\n\n            return self.data[x]\n\n\n\n    def union(self, x, y):\n\n        x, y = self.find(x), self.find(y)\n\n        if x != y:\n\n            if self.data[y] < self.data[x]:\n\n                x, y = y, x\n\n            self.data[x] += self.data[y]\n\n            self.data[y] = x\n\n        return (x != y)\n\n\n\n    def same(self, x, y):\n\n        return (self.find(x) == self.find(y))\n\n\n\n    def size(self, x):\n\n        return -self.data[self.find(x)]\n\n\n\n\n\nMAX = 10 ** 5 + 10\n\nuf = UnionFind(2 * MAX)\n\n\n\nN, *XY = list(map(int, open(0).read().split()))\n\n\n\nfor x, y in zip(*[iter(XY)] * 2):\n\n    uf.union(x, y + MAX)\n\n\n\nX = Counter(uf.find(i) for i in range(MAX))\n\nY = Counter(uf.find(i) for i in range(MAX, MAX * 2))\n\nres = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n\n\nprint((res - N))\n", "output": "A", "improve_diff": 1.0762230852, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X, A = list(map(int, input().split()))\n\nif X < A:\n\n    print((0))\n\nelse:\n\n    print((10)) \nB. X, A = list(map(int, input().split()))\n\nprint((0 if X < A else 10))", "output": "B", "improve_diff": 1.0612552692, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from time import time\n\n\n\ndef change(before_tax,after_tax,previous_price):\n\n    #change z from taxrate x to taxrate y\n\n    original_price = 0\n\n    for i in range(1, previous_price+1):\n\n        if i * (100 + before_tax) // 100 == previous_price:\n\n            original_price = i\n\n            break\n\n        else:\n\n            pass\n\n    return original_price * (100 + after_tax) // 100\n\n\n\n#l = []\n\n\n\nwhile True:\n\n    x,y,s = [int(x) for x in input().split()]\n\n    if x == 0:\n\n        break\n\n    else:\n\n        ans = 0\n\n        for i in range(1,s):\n\n            price1, price2 = i, s - i\n\n            afterprice = change(x,y,price1) + change(x,y,price2)\n\n            if afterprice > ans:\n\n                ans = afterprice\n\n            else:\n\n                continue\n\n        #l.append(ans)\n\n        print(ans)\n\n'''\n\nfor x in l:\n\n    print(x)\n\n'''\n \nB. def change(before_tax,after_tax,previous_price):\n\n    original_price = 0\n\n    for i in range(1, previous_price+1):\n\n        if i * (100 + before_tax) // 100 == previous_price:\n\n            original_price = i\n\n            break\n\n        else:\n\n            pass\n\n    return original_price * (100 + after_tax) // 100\n\n\n\nans_list = []\n\n\n\nwhile True:\n\n    x,y,s = [int(x) for x in input().split()]\n\n    if x == 0:\n\n        break\n\n    else:\n\n        ans = 0\n\n        for i in range(1,s):\n\n            price1, price2 = i, s - i\n\n            afterprice = change(x,y,price1) + change(x,y,price2)\n\n            if afterprice > ans:\n\n                ans = afterprice\n\n            else:\n\n                continue\n\n        ans_list.append(ans)\n\n\n\nfor x in ans_list:\n\n    print(x)\n", "output": "A", "improve_diff": 1.0563370501, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K = [int(x) for x in input().split()]\n\nA_lst = [int(x) for x in input().split()]\n\ndict = {}\n\nfor i in A_lst:\n\n    if not i in list(dict.keys()):\n\n        dict[i] = 1\n\n    else:\n\n        dict[i] += 1\n\n\n\nval_lst = list(dict.values())\n\nval_lst.sort()\n\nk = len(val_lst)\n\ncnt = 0\n\n\n\nfor i in val_lst:\n\n    if k <= K:\n\n        break\n\n    else:\n\n        k -= 1\n\n        cnt += i\n\n\n\nprint(cnt)\n \nB. N, K = [int(x) for x in input().split()]\n\nA_lst = [int(x) for x in input().split()]\n\ndict = {}\n\nfor i in A_lst:\n\n    if not i in list(dict.keys()):\n\n        dict[i] = 1\n\n    else:\n\n        dict[i] += 1\n\n\n\nlst = []\n\nfor i in list(dict.keys()):\n\n    lst.append(dict[i])\n\nlst.sort()\n\nk = len(lst)\n\ncnt = 0\n\n\n\nfor i in lst:\n\n    if k <= K:\n\n        break\n\n    else:\n\n        k -= 1\n\n        cnt += i\n\n\n\nprint(cnt)\n", "output": "A", "improve_diff": 1.0558966042, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n    if  i % 3 == 0 or i % 5 == 0:\n\n        ans += 0\n\n    else:\n\n        ans += i\n\n\n\nprint(ans)\n \nB. N = int(eval(input()))\n\nans = []\n\n\n\nfor i in range(N+1):\n\n    if i % 3 != 0 and i % 5 != 0:\n\n        ans.append(i)\n\n\n\nprint((sum(ans)))", "output": "B", "improve_diff": 1.12634932, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n1 = int(eval(input()))\n\n\n\nlista = list(map(int, input().split()))\n\n\n\ncont = 0\n\nfor e in lista:\n\n    aux = e\n\n    while(aux%2 == 0):\n\n        aux /= 2\n\n        cont += 1\n\n        \n\n\n\nprint(cont) \nB. a = int(eval(input()))\n\nlista = list(map(int, input().split()))\n\nans=0\n\n\n\nfor i in lista:\n\n  while i % 2==0:\n\n    i = i / 2\n\n    ans += 1\n\n    \n\nprint(ans)", "output": "B", "improve_diff": 1.2386523785, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M,K=map(int,input().split())\n\n\n\npar=[-1]*N\n\nnum=[0]*N\n\n\n\ndef find(x):\n\n    if par[x-1]<0:\n\n        return x\n\n    else:\n\n        par[x-1]=find(par[x-1])\n\n        return par[x-1]\n\n\n\ndef union(x,y):\n\n    if find(x)==find(y):\n\n        return\n\n    if find(x)>find(y):\n\n        x,y=y,x\n\n    par[find(x)-1]+=par[find(y)-1]\n\n    par[find(y)-1]=find(x)   \n\n\n\ndef size(x):\n\n    return -par[find(x)-1]\n\n\n\ndef same(x,y):\n\n    return find(x)==find(y)\n\n        \n\n\n\nfor _ in range(M):\n\n    a,b=map(int,input().split())\n\n    union(a,b)\n\n    num[a-1]+=1\n\n    num[b-1]+=1\n\n\n\nfor _ in range(K):\n\n    c,d=map(int,input().split())\n\n    if same(c,d):\n\n        num[c-1]+=1\n\n        num[d-1]+=1\n\n\n\nfor i in range(N):\n\n    print(size(i+1)-1-num[i],end=\" \")\n \nB. N,M,K=map(int,input().split())\n\n\n\npar=[-1]*N\n\nnum=[0]*N\n\n\n\ndef find(x):\n\n    if par[x-1]<0:\n\n        return x\n\n    else:\n\n        par[x-1]=find(par[x-1])\n\n        return par[x-1]\n\n\n\ndef union(x,y):\n\n    p,q=find(x),find(y)\n\n    if p==q:\n\n        return\n\n    if p>q:\n\n        p,q=q,p\n\n    par[p-1]+=par[q-1]\n\n    par[q-1]=p   \n\n\n\ndef size(x):\n\n    return -par[find(x)-1]\n\n\n\ndef same(x,y):\n\n    return find(x)==find(y)\n\n        \n\n\n\nfor _ in range(M):\n\n    a,b=map(int,input().split())\n\n    union(a,b)\n\n    num[a-1]+=1\n\n    num[b-1]+=1\n\n\n\nfor _ in range(K):\n\n    c,d=map(int,input().split())\n\n    if same(c,d):\n\n        num[c-1]+=1\n\n        num[d-1]+=1\n\n\n\nfor i in range(N):\n\n    print(size(i+1)-1-num[i],end=\" \")\n", "output": "A", "improve_diff": 1.0238016233, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=sorted(list(map(int,input().split())))[::-1]\n\nans=0\n\nfor i in range(n):\n\n    if i%2==0:\n\n        ans+=a[i]\n\n    else:\n\n        ans-=a[i]\n\nprint(ans)\n \nB. import numpy as np\n\nimport sys\n\nn = int(eval(input()))\n\na = sorted(list(map(int,input().split())))[::-1]\n\nprint((sum(a[::2])-sum(a[1::2])))\n", "output": "A", "improve_diff": 9.6646417588, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python\n\n# coding: utf-8\n\n\n\ndef ri():\n\n    return int(eval(input()))\n\n\n\ndef rl():\n\n    return list(input().split())\n\n\n\ndef rli():\n\n    return list(map(int, input().split()))\n\n\n\ndef calc(n):\n\n    s = sum(map(int, \nB. #!/usr/bin/env python\n\n# coding: utf-8\n\n\n\ndef ri():\n\n    return int(eval(input()))\n\n\n\ndef rl():\n\n    return list(input().split())\n\n\n\ndef rli():\n\n    return list(map(int, input().split()))\n\n\n\ndef calc(n):\n\n    s = sum(map(int, str(n)))\n\n    return n / s\n\n\n\ndef main():\n\n    k = ri()\n\n    cand = list(range(1, 10))\n\n    last = 9\n\n    for n in range(1, 15):\n\n        pow10n = pow(10, n)\n\n        for d in range(1, 10):\n\n            lim = (d+1)*pow10n\n\n            e = 0\n\n            while True:\n\n                e1 = d*pow10n+e*(last+1)+last\n\n                if e1 >= lim:\n\n                    break\n\n                e2 = e1 + (last+1)\n\n                if calc(e1) > calc(e2):\n\n                    last = last*10+9\n\n                    e = 0\n\n                    continue\n\n                cand.append(e1)\n\n                e += 1\n\n    cand = sorted(list(set(cand)))\n\n    print((\"\\n\".join(map(str, cand[:k]))))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n\"\"\"\n\n1 1.0\n\n2 1.0\n\n3 1.0\n\n4 1.0\n\n5 1.0\n\n6 1.0\n\n7 1.0\n\n8 1.0\n\n9 1.0\n\n19 1.9\n\n29 2.6363636363636362\n\n39 3.25\n\n49 3.769230769230769\n\n59 4.214285714285714\n\n69 4.6\n\n79 4.9375\n\n89 5.235294117647059\n\n99 5.5\n\n199 10.473684210526315\n\n299 14.95\n\n399 19.0\n\n499 22.681818181818183\n\n599 26.043478260869566\n\n699 29.125\n\n799 31.96\n\n899 34.57692307692308\n\n999 37.0\n\n1099 57.8421052631579\n\n1199 59.95\n\n1299 61.857142857142854\n\n1399 63.59090909090909\n\n1499 65.17391304347827\n\n1599 66.625\n\n1699 67.96\n\n1799 69.1923076923077\n\n1899 70.33333333333333\n\n1999 71.39285714285714\n\n2999 103.41379310344827\n\n3999 133.3\n\n4999 161.25806451612902\n\n5999 187.46875\n\n6999 212.0909090909091\n\n7999 235.26470588235293\n\n8999 257.1142857142857\n\n9999 277.75\n\n10999 392.82142857142856\n\n11999 413.7586206896552\n\n12999 433.3\n\n13999 451.5806451612903\n\n14999 468.71875\n\n15999 484.8181818181818\n\n16999 499.97058823529414\n\n17999 514.2571428571429\n\n18999 527.75\n\n19999 540.5135135135135\n\n20999 724.1034482758621\n\n21999 733.3\n\n22999 741.9032258064516\n\n23999 749.96875\n\n24999 757.5454545454545\n\n25999 764.6764705882352\n\n26999 771.4\n\n27999 777.75\n\n28999 783.7567567567568\n\n29999 789.4473684210526\n\n39999 1025.6153846153845\n\n49999 1249.975\n\n59999 1463.3902439024391\n\n69999 1666.642857142857\n\n79999 1860.4418604651162\n\n89999 2045.4318181818182\n\n99999 2222.2\n\n109999 2972.945945945946\n\n119999 3157.8684210526317\n\n129999 3333.3076923076924\n\n139999 3499.975\n\n149999 3658.512195121951\n\n159999 3809.5\n\n169999 3953", "output": "B", "improve_diff": 11.6334317676, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K, *trees = list(map(int, open(0).read().split()))\n\ntrees = sorted(trees)\n\nprint((min(trees[i+K-1] - trees[i] for i in range(N-K+1))))\n \nB. N, K = list(map(int, input().split()))\n\ntrees = [int(eval(input())) for i in range(N)]\n\ntrees = sorted(trees)\n\n\n\nresult = min(trees[i+K-1] - trees[i] for i in range(N-K+1))\n\n\n\nprint(result)\n", "output": "B", "improve_diff": 1.0227428076, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\n\n\n\n\ndef f(n, k, a_s):\n\n    md = 10 ** 9 + 7\n\n    dp = np.zeros(k + 1, dtype=np.int64)\n\n    dp[0] = 1\n\n    for a in a_s[:-1]:\n\n        dp = np.cumsum(dp) % md\n\n        if k != a:\n\n            dp[k:a:-1] = (dp[k:a:-1] - dp[k - a - 1::-1]) % md\n\n    return np.sum(dp[k - a_s[-1]:]) % md\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\nprint((f(n, k, a_s)))\n \nB. def f(n, k, a_s):\n\n    md = 10 ** 9 + 7\n\n    dp = [0] * (k + 1)\n\n    dp[0] = 1\n\n    for a in a_s[:-1]:\n\n        ndp = [0] * (k + 1)\n\n        ndp[0] = s = dp[0] % md\n\n        for j in range(1, a + 1):\n\n            ndp[j] = s = (s + dp[j]) % md\n\n        for j in range(a + 1, k + 1):\n\n            ndp[j] = s = (s + dp[j] - dp[j - a - 1]) % md\n\n        dp = ndp\n\n    return sum(dp[k - a_s[-1]:]) % md\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\nprint((f(n, k, a_s)))\n", "output": "B", "improve_diff": 7.4389709078, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def is_753(n):\n\n    n = str(n)\n\n    return(n.count(\"7\") >= 1 and n.count(\"3\") >= 1 and n.count(\"5\") >= 1)\n\n\n\n\n\nn = int(eval(input()))\n\n\n\n\n\nv = [7, 5, 3]\n\nli = []\n\nprev = [7, 5, 3]\n\n\n\nfor i in range(9):\n\n    tmp = []\n\n    for j in v:\n\n        for k in prev:\n\n            tmp.append(k * 10 + j)\n\n    prev = tmp\n\n    li = li + prev\n\n\n\nli = [x for x in li if is_753(x) and x <= n]\n\n\n\nprint((len(li))) \nB. import sys\n\nsys.setrecursionlimit(10**6)\n\n\n\nN = int(eval(input()))\n\nV = [3, 5, 7]\n\n\n\nli = []\n\n\n\n\n\ndef rec(curr, use):\n\n    if curr > N:\n\n        return\n\n    if use == 0b111:\n\n        li.append(curr)\n\n    for i, b in enumerate(V):\n\n        rec(curr * 10 + b, use | max(1, i * 2))\n\n\n\n\n\nrec(0, 0)\n\n\n\nprint((len(li)))", "output": "B", "improve_diff": 3.7547684452, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. eval(input());a=list(map(int,input().split()));r=float('inf')\n\nfor i in range(min(a),max(a)+1):\n\n  n=0\n\n  for j in a:\n\n    n+=(j-i)**2\n\n  r=min(n,r)\n\nprint(r) \nB. import statistics\n\nn=int(eval(input()))\n\na=list(map(int,input().split()))\n\nnum=round(statistics.mean(a))\n\nprint((sum([(num-i)**2 for i in a])))", "output": "A", "improve_diff": 2.714426702, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. s = [int(eval(input())) for i in range(4)]\n\nvar = 0\n\nfor i in range(s[0]+1):\n\n  if (s[3]-500*i) >= 0:\n\n    Y = s[3]-500*i\n\n    for j in range(s[1]+1):\n\n      if ((Y-100*j) >= 0) and (((Y-100*j)//50) <= s[2]):\n\n        var = var+1\n\nprint(var) \nB. A = int(eval(input()))\n\nB = int(eval(input()))\n\nC = int(eval(input()))\n\nX = int(eval(input()))\n\nvar = 0\n\nfor i in range(A+1):\n\n  if (X-500*i) >= 0:\n\n    Y = X-500*i\n\n    for j in range(B+1):\n\n      if ((Y-100*j) >= 0) and (((Y-100*j)//50) <= C):\n\n        var = var+1\n\nprint(var)", "output": "A", "improve_diff": 1.0596445838, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\nnii=lambda:list(map(int,stdin.readline().split()))\n\nlnii=lambda:list(map(int,stdin.readline().split()))\n\n\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\n\n\nn=int(eval(input()))\n\n\n\nans=''\n\nwhile n!=0:\n\n  t_ans=n%26\n\n  ans+=str(abc[t_ans-1])\n\n\n\n  if abc[t_ans-1]=='z':\n\n    n-=1\n\n\n\n  n//=26\n\n\n\nprint((ans[::-1])) \nB. n=int(eval(input()))\n\n\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\n\n\nans=''\n\nwhile n!=0:\n\n  q=n%26\n\n  ans+=abc[q-1]\n\n\n\n  if q==0:\n\n    n-=1\n\n\n\n  n//=26\n\n\n\nprint((ans[::-1]))", "output": "A", "improve_diff": 1.008347449, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nlis = [0,26]\n\nnum = 26\n\nn = 1\n\nwhile lis[-1]<N:\n\n    num *= 26\n\n    lis.append(lis[-1]+num)\n\n    n += 1\n\nc = N-lis[-2]-1\n\nans = ''\n\nfor i in range(n):\n\n    ans = chr(c%26+ord('a')) + ans\n\n    c //= 26\n\nprint(ans) \nB. def solve():\n\n  N = int(eval(input()))\n\n  k = 1\n\n  while N>pow(26,k):\n\n    N -= pow(26,k)\n\n    k += 1\n\n  ans = ''\n\n  N -= 1\n\n  for i in range(k,0,-1):\n\n    if i>1:\n\n      ans += chr(ord('a')+N//pow(26,i-1))\n\n    else:\n\n      ans += chr(ord('a')+N%pow(26,i))\n\n    N%=pow(26,i-1)\n\n  return ans\n\nprint((solve()))", "output": "A", "improve_diff": 1.0128811391, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque\n\n\n\ninput = sys.stdin.readline\n\n\n\nN,M = list(map(int,input().split()))\n\nedge = [list(map(int,input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nindegree = [0 for _ in range(N)]\n\n\n\nfor i in range(M):\n\n    graph[edge[i][0]-1].append(edge[i][1]-1)\n\n    indegree[edge[i][1]-1] += 1\n\n\n\nqueue = deque()\n\nfor i in range(N):\n\n    if indegree[i] == 0:\n\n        queue.append(i)\n\n\n\ndp = [0]*N\n\n\n\nwhile queue:\n\n    node = queue.popleft()\n\n    for adj in graph[node]:\n\n        indegree[adj] -= 1\n\n        if indegree[adj] == 0:\n\n            queue.append(adj)\n\n            dp[adj] = dp[node]+1\n\n\n\nprint((max(dp))) \nB. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, M = list(map(int, input().split()))\n\ngraph = [[] for _ in range(N)]\n\ndeg = [0 for _ in range(N)]\n\ndp = [0 for _ in range(N)]\n\n\n\nfor _ in range(M):\n\n    x, y = list(map(int, input().split()))\n\n    graph[x - 1].append(y - 1)\n\n    deg[y - 1] += 1\n\n\n\nstack = []\n\n\n\nfor i in range(N):\n\n    if not deg[i]:\n\n        stack.append(i)\n\n\n\nwhile stack:\n\n    node = stack.pop()\n\n    for adj in graph[node]:\n\n        deg[adj] -= 1\n\n        dp[adj] = max(dp[adj], dp[node] + 1)\n\n        if not deg[adj]:\n\n            stack.append(adj)\n\n\n\nprint((max(dp)))", "output": "B", "improve_diff": 1.6116524459, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import collections\n\n\n\nn = int(input())\n\nl = [input() for _ in [0] * n]\n\n\n\ncounted = collections.Counter(l)\n\n#print(counted)\n\n# \n\nm = max(counted.values())\n\n#print(m)\n\n# \n\nchars = [key for key, value in counted.items()\n\n             if value == m]\n\n\n\nprint(*sorted(chars),sep='\\n')\n\n\n \nB. import collections\n\nimport itertools\n\n\n\nn = int(input())\n\nl = [input() for _ in [0] * n]\n\n\n\ncounter = collections.Counter(l)\n\n\n\na = counter.most_common()[0][-1]\n\nb = itertools.takewhile(\n\n    lambda kv: kv[-1] == a, counter.most_common()\n\n)\n\n\n\nc = sorted(list(k for k, v in b))\n\nprint(*c,sep='\\n')\n\n\n\n\n", "output": "A", "improve_diff": 1.0323417923, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x, y = list(map(int, input().split()))\n\n\n\nflg = False\n\nfor i in range(101):\n\n    for j in range(101):\n\n        if (i * 2) + (j * 4) == y and (i + j) == x:\n\n            print(\"Yes\")\n\n            flg = True\n\n            break\n\n    if flg == True:\n\n        break\n\nelse:\n\n    print(\"No\") \nB. x, y = list(map(int, input().split()))\n\n\n\nans = \"No\"\n\nfor i in range(101):\n\n    for j in range(101):\n\n        if (i * 2) + (j * 4) == y and (i + j) == x:\n\n            ans = \"Yes\"\n\nprint(ans)", "output": "A", "improve_diff": 1.0229009974, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import permutations\n\nn = int(eval(input()))\n\nP = tuple(map(int, input().split()))\n\nQ = tuple(map(int, input().split()))\n\n\n\nn_list = [x for x in range(1, n+1)]\n\n# print(list(permutations(n_list, n)))\n\na = b = 0\n\nfor n, i in enumerate(permutations(n_list, n)):\n\n  # print(n, i)\n\n  if i == P:\n\n    a = n\n\n  if i == Q:\n\n    b = n\n\n    \n\nprint((abs(a-b))) \nB. from collections import deque\n\nn = int(eval(input()))\n\np_que = deque(list(map(int, input().split())))\n\nq_que = deque(list(map(int, input().split())))\n\n\n\nque = deque(i for i in range(1, n+1))\n\ncnt = 0\n\na = 0\n\nb = 0\n\n\n\ndef dfs(d, q):\n\n  # print('-'*10, q)\n\n  # sorted(q)\n\n  for i in list(q):\n\n    # print(i, d, q)\n\n    d.append(i)\n\n    q.remove(i)\n\n    # print('>', d, q)\n\n    if q == deque([]):\n\n      global cnt\n\n      cnt += 1\n\n      # print('>>>', cnt, d, q)\n\n      if d == p_que:\n\n        global a\n\n        a = cnt\n\n      if d == q_que:\n\n        global b\n\n        b = cnt\n\n      # print('return')\n\n      d.remove(i)\n\n      q.appendleft(i)\n\n      return\n\n    # print('tansaku')\n\n    dfs(d, q)\n\n    # print('>returned')\n\n    # print('---', i, d, q)\n\n    d.remove(i)\n\n    if i > q[0]:\n\n      q.append(i)\n\n    else:\n\n      q.appendleft(i)\n\n    q = deque(sorted(q))\n\n\n\ndfs(deque(), que)\n\n# print(a, b)\n\nprint((abs(a-b)))", "output": "A", "improve_diff": 1.4411115171, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nL = [[-1]*n for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for j in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        L[i][x] = y\n\n#print(L)\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    temp = 0\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            temp += 1\n\n    flag = True\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            for k in range(n):\n\n                #print((i >> k) & 0)\n\n                if  L[j][k] == 1 and ((i >> k) & 1) == 0:\n\n                    flag =  False\n\n                elif L[j][k] == 0 and ((i >> k) & 1) != 0:\n\n                    flag = False\n\n                else:\n\n                    pass\n\n    if flag:\n\n        ans = max(ans, temp)\n\nprint(ans) \nB. n = int(eval(input()))\n\nX = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for j in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        X[i].append((x, y))\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    t = [-1]*n\n\n    flag = True\n\n    cnt = 0\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            cnt += 1\n\n            t[j] = 1\n\n        else:\n\n            t[j] = 0\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            for x, y in X[j]:\n\n                if t[x] != y:\n\n                    flag = False\n\n    if flag:\n\n        ans = max(ans, cnt)\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0720963019, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nAB = []\n\nans = 0\n\nfor i in range(N):\n\n    a,b = list(map(int,input().split()))\n\n    ans += a\n\n    AB.append(a+b)\n\n\n\nAB.sort(reverse=True)\n\nfor i in range(N):\n\n    if i%2 == 1:\n\n        ans -= AB[i]\n\n\n\nprint(ans) \nB. n = int(eval(input()))\n\nab = []\n\nans = 0\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    ab.append([a+b,b])\n\n    ans -= b\n\nab.sort(reverse=True)\n\nfor i in range(n):\n\n    if i%2 == 0:\n\n        ans += ab[i][0]\n\nprint(ans)\n", "output": "B", "improve_diff": 1.1072623019, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,n,*p=list(map(int,open(0).read().split()))\n\nprint((min({*list(range(999))}-{*p},key=lambda y:abs(y-x)))) \nB. x,n,*p=list(map(int,open(0).read().split()))\n\nprint((min({*list(range(999))}-{*p},key=lambda y:(abs(y-x),y))))", "output": "B", "improve_diff": 1.098058879, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom scipy.sparse.csgraph import shortest_path\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n\n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split())) # applies to numbers only\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nN, M = rl()\n\nedges = [rl() for _ in range(M)]\n\ngraph = np.zeros((N, N))\n\n\n\nfor a, b, c in edges:\n\n    graph[a-1, b-1] = c\n\n\n\ndist = shortest_path(graph, directed=False).astype(int)\n\nanswer = 0\n\nfor a, b, c in edges:\n\n    if c != dist[a-1, b-1]:\n\n        answer += 1\n\n\n\nprint(answer)\n\n#05 \nB. import sys\n\nfrom heapq import heappop, heappush\n\n#import numpy as np\n\n\n\nstdin = sys.stdin\n\n\n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split())) # applies to numbers only\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\ndef dijkstra(start):\n\n    INF = 10 ** 5\n\n    dist = [INF] * (N+1) # dist[0]\n\n    dist[start] = 0\n\n    que = [(0, start)]\n\n    while que:\n\n        # (d, v) dv\n\n        d, v = heappop(que)\n\n        # continue\n\n        if dist[v] < d:\n\n            continue\n\n        for next_city, cost in list(edges[v].items()):\n\n            # mode\n\n            d1 = d + cost\n\n            # \n\n            if dist[next_city] > d1:\n\n                dist[next_city] = d1\n\n                heappush(que, (d1, next_city))\n\n    return dist\n\n\n\nN, M = rl()\n\nINF = 10 ** 5\n\nedges = [{} for _ in range(N+1)]\n\nfor _ in range(M):\n\n    a, b, c = rl()\n\n    edges[a][b] = c\n\n    edges[b][a] = c\n\n\n\nanswer = 0\n\nfor i in range(1, N+1):\n\n    for j in range(i+1, N+1):\n\n        if j not in edges[i]:\n\n            continue\n\n        A = dijkstra(i)\n\n        if A[j] < edges[i][j]:\n\n            answer += 1\n\n            edges[i].pop(j)\n\n            edges[j].pop(i)\n\n\n\nprint(answer)\n\n# 00\n", "output": "B", "improve_diff": 12.2690493435, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m = list(map(int, input().split()))\n\nps = list(map(int, input().split()))\n\nls = [list(map(int, input().split())) for _ in range(m)]\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = list(range(n + 1))\n\n        self.ranks = [0 for _ in range(n + 1)]\n\n\n\n    def get_root(self, x):\n\n        if self.parents[x] == x:\n\n            return x\n\n        self.parents[x] = self.get_root(self.parents[x])\n\n        return self.parents[x]\n\n\n\n    def merge(self, x, y):\n\n        x = self.get_root(x)\n\n        y = self.get_root(y)\n\n        if x != y:\n\n            if self.ranks[x] < self.ranks[y]:\n\n                self.parents[x] = y\n\n            else:\n\n                self.parents[y] = x\n\n                if self.ranks[x] == self.ranks[y]:\n\n                    self.ranks[x] += 1\n\n\n\n\n\nuf = UnionFind(n)\n\nfor a, b in ls:\n\n    uf.merge(a, b)\n\nres = 0\n\nfor i in range(1, n + 1):\n\n    p0 = uf.get_root(i)\n\n    p1 = uf.get_root(ps[i - 1])\n\n    if p0 == p1:\n\n        res += 1\n\nprint(res) \nB. import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\nri = lambda: int(eval(input()))\n\nrs = lambda: input().rstrip()\n\nril = lambda: list(map(int, input().split()))\n\nrsl = lambda: input().rstrip().split()\n\nris = lambda n: [ri() for _ in range(n)]\n\nrss = lambda n: [rs() for _ in range(n)]\n\nrils = lambda n: [ril() for _ in range(n)]\n\nrsls = lambda n: [rsl() for _ in range(n)]\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = list(range(n))\n\n        self.ranks = [0 for _ in range(n)]\n\n\n\n    def get_root(self, x):\n\n        if self.parents[x] == x:\n\n            return x\n\n        self.parents[x] = self.get_root(self.parents[x])\n\n        return self.parents[x]\n\n\n\n    def merge(self, x, y):\n\n        x = self.get_root(x)\n\n        y = self.get_root(y)\n\n        if x != y:\n\n            if self.ranks[x] < self.ranks[y]:\n\n                self.parents[x] = y\n\n            else:\n\n                self.parents[y] = x\n\n                if self.ranks[x] == self.ranks[y]:\n\n                    self.ranks[x] += 1\n\n\n\n\n\nn, m = ril()\n\nps = ril()\n\nls = rils(m)\n\n\n\nuf = UnionFind(n)\n\nfor a, b in ls:\n\n    uf.merge(a - 1, b - 1)\n\nres = 0\n\nfor i in range(n):\n\n    p0 = uf.get_root(i)\n\n    p1 = uf.get_root(ps[i] - 1)\n\n    if p0 == p1:\n\n        res += 1\n\nprint(res)", "output": "A", "improve_diff": 1.0801645524, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python\n\n\n\nfrom sys import stdin, exit\n\n\n\n\n\ncode_table = {chr(65+i): '{:05b}'.format(i) for i in range(26)}\n\ncode_table.update({' ': '11010', '.': '11011', ',': '11100', '-': '11101',\n\n                   \"'\": '11110', '?': '11111'})\n\n\n\n\n\ndef decrypt(it):\n\n    if int(next(it)):\n\n        if int(next(it)):\n\n            if int(next(it)):\n\n                return 'P'\n\n            else:\n\n                return 'E'\n\n        else:\n\n            if int(next(it)):\n\n                return ' '\n\n            else:\n\n                if int(next(it)):\n\n                    if int(next(it)):\n\n                        if int(next(it)):\n\n                            if int(next(it)):\n\n                                if int(next(it)):\n\n                                    return 'Q'\n\n                                else:\n\n                                    return 'N'\n\n                            else:\n\n                                if int(next(it)):\n\n                                    return 'V'\n\n                                else:\n\n                                    return 'U'\n\n                        else:\n\n                            if int(next(it)):\n\n                                if int(next(it)):\n\n                                    return 'G'\n\n                                else:\n\n                                    return 'B'\n\n                            else:\n\n                                if int(next(it)):\n\n                                    return 'M'\n\n                                else:\n\n                                    return 'J'\n\n                    else:\n\n                        if int(next(it)):\n\n                            return 'A'\n\n                        else:\n\n                            if int(next(it)):\n\n                                if int(next(it)):\n\n                                    return 'Y'\n\n                                else:\n\n                                    return 'X'\n\n                            else:\n\n                                if int(next(it)):\n\n                                    return '-'\n\n                                else:\n\n                                    return 'Z'\n\n                else:\n\n                    return 'R'\n\n    else:\n\n        if int(next(it)):\n\n            if int(next(it)):\n\n                if int(next(it)):\n\n                    return 'I'\n\n                else:\n\n                    return 'K'\n\n            else:\n\n                if int(next(it)):\n\n                    return 'C'\n\n                else:\n\n                    if int(next(it)):\n\n                        return 'F'\n\n                    else:\n\n                        if int(next(it)):\n\n                            return '.'\n\n                        else:\n\n                            return 'H'\n\n        else:\n\n            if int(next(it)):\n\n                if int(next(it)):\n\n                    if int(next(it)):\n\n                        return 'T'\n\n                    else:\n\n                        return 'S'\n\n                else:\n\n                    if int(next(it)):\n\n                        return 'O'\n\n                    else:\n\n                        return 'L'\n\n            else:\n\n                if int(next(it)):\n\n                    return 'D'\n\n                else:\n\n                    if int(next(it)):\n\n                        if int(next(it)):\n\n                            return ','\n\n                        else:\n\n                            return 'W'\n\n                    else:\n\n                        if int(next(it)):\n\n                            return '?'\n\n                        else:\n\n                            return \"'\"\n\n\n\n\n\ndef main():\n\n    for line in stdin:\n\n        it = iter(''.join(code_table[c] for c in line.rstrip('\\r\\n')))\n\n        try:\n\n            while 1:\n\n                print(decrypt(it), end='')\n\n        except StopIteration:\n\n            print()\n\n    exit()\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. #!/usr/bin/env python\n\n\n\nfrom sys import stdin, exit\n\n\n\n\n\ncode_table = {chr(65+i): '{:05b}'.format(i) for i in range(26)}\n\ncode_table.update({' ': '11010', '.': '11011', ',': '11100', '-': '11101',\n\n                   \"'\": '11110', '?': '11111'})\n\n\n\ndecrypt = {\n\n    '101': ' ', '000000': \"'\", '000011': ',', '10010001': '-',\n\n    '010001': '.', '000001': '?', '100101': 'A', '10011010': 'B',\n\n    '0101': 'C', '0001': 'D', '110': 'E', '01001': 'F',\n\n    '10011011': 'G', '010000': 'H', '0111': 'I', '10011000': 'J',\n\n    '0110': 'K', '00100': 'L', '10011001': 'M', '10011110': 'N',\n\n    '00101': 'O', '111': 'P', '10011111': 'Q', '1000': 'R',\n\n    '00110': 'S', '00111': 'T', '10011100': 'U', '10011101': 'V',\n\n    '000010': 'W', '10010010': 'X', '10010011': 'Y', '10010000': 'Z'}\n\n\n\n\n\ndef main():\n\n    for line in stdin:\n\n        buf = ''\n\n        for c in ''.join(code_table[c] for c in line.rstrip('\\r\\n')):\n\n            buf += c\n\n            plain = decrypt.get(buf)\n\n            if plain:\n\n                print(plain, end='')\n\n                buf = ''\n\n        print()\n\n    exit()\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "B", "improve_diff": 1.1491947414, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. W, H, N = list(map(int, input().split()))\n\nlx, rx, uy, dy = 0, W, H, 0\n\nfor i in range(N):\n\n    x, y, a = list(map(int, input().split()))\n\n    if a == 1:\n\n        lx = max(lx, x)\n\n    if a == 2:\n\n        rx = min(rx, x)\n\n    if a == 3:\n\n        dy = max(dy, y)\n\n    if a == 4:\n\n        uy = min(uy, y)\n\n# print(lx, rx, uy, dy)\n\nprint((max(0, uy - dy) * max(0, rx - lx)))\n \nB. W, H, N = list(map(int, input().split()))\n\ngraph = [[1] * W for _ in range(H)]\n\nfor _ in range(N):\n\n    x, y, a = list(map(int, input().split()))\n\n    if a == 1:\n\n        for i in range(H):\n\n            for j in range(x):\n\n                graph[i][j] = 0\n\n    if a == 2:\n\n        for i in range(H):\n\n            for j in range(x, W):\n\n                graph[i][j] = 0\n\n    if a == 3:\n\n        for i in range(y):\n\n            for j in range(W):\n\n                graph[i][j] = 0\n\n    if a == 4:\n\n        for i in range(y, H):\n\n            for j in range(W):\n\n                graph[i][j] = 0\n\nans = sum([sum(line) for line in graph])\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0438894509, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\n\n# AtCoder Beginner Contest\n\n# Problem B\n\n\n\nif __name__ == '__main__':\n\n    a, b, c = list(map(int, input().split()))\n\n    count = 1\n\n\n\n    while count < 10001:\n\n        if ((a * count) % b) == c:\n\n            print('YES')\n\n            exit()\n\n\n\n        count += 1\n\n\n\n    print('NO')\n \nB. # -*- coding: utf-8 -*-\n\n\n\n# AtCoder Beginner Contest\n\n# Problem B\n\n\n\nif __name__ == '__main__':\n\n    a, b, c = list(map(int, input().split()))\n\n    count = 1\n\n\n\n    while count < (b + 1):\n\n        if ((a * count) % b) == c:\n\n            print('YES')\n\n            exit()\n\n\n\n        count += 1\n\n\n\n    print('NO')\n", "output": "B", "improve_diff": 1.0357991186, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,y,a,b,c=list(map(int,input().split()))\n\np=list(map(int,input().split()))\n\nq=list(map(int,input().split()))\n\nr=list(map(int,input().split()))\n\np.sort()\n\np=p[-x:]\n\nq.sort()\n\nq=q[-y:]\n\np[len(p):len(p)]=q\n\np[len(p):len(p)]=r\n\np.sort()\n\np=p[-x-y:]\n\nprint((sum(p))) \nB. x,y,a,b,c=list(map(int,input().split()))\n\np=list([['red',int(x)] for x in input().split()])\n\nq=list([['green',int(x)] for x in input().split()])\n\nr=list([['nan',int(x)] for x in input().split()])\n\np.sort(key=lambda x:x[1])\n\np=p[-x:]\n\nq.sort(key=lambda x:x[1])\n\nq=q[-y:]\n\np[len(p):len(p)]=q\n\np[len(p):len(p)]=r\n\np.sort(key=lambda x:x[1])\n\np=p[-x-y:]\n\nprint((sum([pi[1] for pi in p])))\n\n  \n", "output": "A", "improve_diff": 1.0185690948, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\ns = [0]*(N+1)\n\nfor i in range(N):\n\n    s[i+1] = s[i] + A[i]\n\n    \n\ncnt = 0\n\nfor j in range(N):\n\n    cnt =  (cnt + (A[j]*(s[N] - s[j+1])))%(10**9+7)\n\nprint(cnt) \nB. N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA_sum = sum(A[1:])\n\n\n\ntot = 0\n\nfor i in range(N-1):\n\n    tot += (A[i]*A_sum)%(10**9+7)\n\n    tot = tot%(10**9+7)\n\n    A_sum -= A[i+1]\n\n    \n\nprint(tot)", "output": "B", "improve_diff": 1.0202900644, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\nans = 0\n\n\n\ni = 2\n\nnum = n\n\nwhile i * i <= n:\n\n  cnta = 0\n\n  cntb = 0\n\n  while num % i == 0:\n\n    num //= i\n\n    if cnta == cntb:\n\n      ans += 1\n\n      cnta = 0\n\n      cntb += 1\n\n    else:\n\n      cnta += 1\n\n  i += 1\n\n  \n\nif (ans == 0 and n != 1) or num != 1:\n\n  ans += 1\n\nprint(ans)\n \nB. n = int(eval(input()))\n\nif n == 1:\n\n    print((0))\n\n    exit()\n\nF = {}\n\ntmp = n\n\ni = 2\n\nwhile i**2 <= tmp:\n\n    cnt = 0\n\n    while tmp % i == 0:\n\n        cnt += 1\n\n        tmp //= i\n\n    if cnt > 0:\n\n        F[i] = cnt\n\n    i += 1\n\nif tmp != 1 or F == {}:\n\n    F[tmp] = 1\n\nans = 0\n\nfor p in F:\n\n    a = 1\n\n    while F[p] >= a:\n\n        F[p] -= a\n\n        ans += 1\n\n        a += 1\n\nprint(ans)", "output": "B", "improve_diff": 3.2612929664, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=str(eval(input()))\n\nif int(N[0])==7 or int(N[1])==7 or int(N[2])==7:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\") \nB. N=str(eval(input()))\n\nif int(N[0])==7:\n\n    print(\"Yes\")\n\nelif int(N[1])==7:\n\n    print(\"Yes\")\n\nelif int(N[2])==7:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n", "output": "A", "improve_diff": 1.0217134394, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nfrom bisect import bisect_left\n\n\n\n\n\ndef primes():\n\n    p = []\n\n    c = np.ones(10**5 + 10)\n\n    c[0] = c[1] = 0\n\n    for i, f in enumerate(c):\n\n        if f:\n\n            p.append(i)\n\n            c[2 * i:10**5 + 10:i] = 0\n\n    return p\n\n\n\n\n\ndef solve(string):\n\n    x = int(string)\n\n    ps = primes()\n\n    return str(ps[bisect_left(ps, x)])\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n \nB. def solve(string):\n\n    x = int(string)\n\n    for i in range(x, 2 * x):\n\n        for j in range(2, int(i**0.5)):\n\n            if i % j == 0:\n\n                break\n\n        else:\n\n            return str(i)\n\n\n\n\n\nif __name__ == '__main__':\n\n    import sys\n\n    print((solve(sys.stdin.read().strip())))\n", "output": "B", "improve_diff": 12.3240064221, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!usr/bin/env python3\n\n\n\nfrom collections import defaultdict\n\n\n\n\n\ndef main():\n\n    #Read stdin\n\n\n\n    fl = input().split(\" \")\n\n    V = int(fl[0])\n\n    E = int(fl[1])\n\n    R = int(fl[2])\n\n    #Adjacency list\n\n    G = defaultdict(list)\n\n    for i in range(int(E)):\n\n        s, t, w = [int(x) for x in input().split(\" \")]\n\n        G[s].append((t,w))\n\n    #initialized\n\n    d = {}\n\n    INF = float('inf')\n\n    #INF = 10001\n\n    for i in range(V):\n\n        d[i] = INF\n\n    d[R] = 0\n\n    q = [R]\n\n    while q:\n\n        u = q.pop(0)\n\n        for v in G[u]:\n\n            if d[v[0]] > d[u] + v[1]:\n\n                d[v[0]] = d[u] + v[1]\n\n\n\n                q.append(v[0])\n\n\n\n    for k in range(V):\n\n        if d[k] == float('inf'):\n\n            \n\n            print(\"INF\")\n\n        else:\n\n            print((d[k]))\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. from collections import defaultdict\n\nfrom collections import deque\n\n#import time\n\n\n\ndef main():\n\n    # Read stdin\n\n    #start = time.clock()\n\n    fl = input().split(\" \")\n\n    V = int(fl[0])\n\n    E = int(fl[1])\n\n    R = int(fl[2])\n\n    # Adjacency list\n\n    G = defaultdict(list)\n\n    for i in range(int(E)):\n\n        s, t, w = [int(x) for x in input().split(\" \")]\n\n        G[s].append((t, w))\n\n    # initialized\n\n    d = {}\n\n    INF = float('inf')\n\n    # INF = 10001\n\n    for i in range(V):\n\n        d[i] = INF\n\n    d[R] = 0\n\n    q = deque([R])\n\n    while q:\n\n        # u = heappop(q)\n\n        u = q.popleft()\n\n        for v in G[u]:\n\n            if d[v[0]] > d[u] + v[1]:\n\n                d[v[0]] = d[u] + v[1]\n\n                # heappush(q, v[0])\n\n                q.append(v[0])\n\n    #end = time.clock() - start\n\n    for k in range(V):\n\n        if d[k] == float('inf'):\n\n            print(\"INF\")\n\n        else:\n\n            print((d[k]))\n\n    #print('Computation time : {}'.format(end))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "B", "improve_diff": 1.1168190664, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nalist = list(map(int, input().split()))\n\n\n\nblist = []\n\n\n\nfor i in range(N):\n\n    blist.append(alist[i]-i-1)\n\n\n\nblist.sort()\n\nmid = blist[N//2]\n\n\n\nprint((sum([abs(b-mid) for b in blist])))\n \nB. N = int(eval(input()))\n\nalist = list(map(int, input().split()))\n\n\n\nblist = []\n\nfor i in range(N):\n\n    blist.append(alist[i]-i-1)\n\n\n\nblist.sort()\n\nmid = blist[len(blist)//2]\n\n\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += abs(blist[i]-mid)\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0426398833, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\nwhile not any(i&1 for i in a):\n\n    ans += 1\n\n    a = [i//2 for i in a]\n\n\n\nprint(ans) \nB. n = int(eval(input()))\n\na = {int(i) for i in input().split()}\n\nans = 0\n\nwhile not any(i&1 for i in a):\n\n    ans += 1\n\n    a = {i//2 for i in a}\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0174816272, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\nstair_m=[True]*(110000)\n\nfor i in range(m):\n\n    a=int(eval(input()))\n\n    stair_m[a]=False\n\ndp=[0]*(110000)\n\ndp[0]=1\n\nfor i in range(1,n+1):\n\n    if stair_m[i]:\n\n        dp[i]=dp[i-1]+dp[i-2]\n\n    else:\n\n        dp[i]=0\n\nprint((dp[n]%1000000007)) \nB. n,m=list(map(int,input().split()))\n\nstair=[False]*(n+1)\n\nfor i in range(m):\n\n    a=int(eval(input()))\n\n    stair[a]=True\n\n\n\n\n\ndp=[0]*(n+1)\n\ndp[0]=1\n\n\n\nfor i in range(1,n+1):\n\n    if stair[i]:\n\n        dp[i]=0\n\n    else:\n\n        dp[i]=(dp[i-1]+dp[i-2])%(10**9+7)\n\nprint((dp[n]))", "output": "B", "improve_diff": 1.2188562298, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n  import sys\n\n  input = sys.stdin.readline\n\n  n,m=list(map(int,input().split()))\n\n  mod=pow(10,9)+7\n\n  ans=[1]*(n+1)\n\n  for _ in [0]*m:\n\n    ans[int(eval(input()))]=0\n\n  for i in range(2,n+1):\n\n    if ans[i]>0:\n\n      ans[i]=(ans[i-1]+ans[i-2])%mod\n\n  print((ans[-1]))\n\nif __name__ == '__main__':\n\n    main() \nB. def main():\n\n  import sys\n\n  input = sys.stdin.readline\n\n  n,m=list(map(int,input().split()))\n\n  mod=pow(10,9)+7\n\n  ans=[1]*(n+1)\n\n  for _ in [0]*m:\n\n    ans[int(eval(input()))]=0\n\n  for i in range(n+1):\n\n    ans[i]=ans[i] if ans[i]==0 or i<2 else (ans[i-1]+ans[i-2])%mod\n\n  print((ans[-1]))\n\nif __name__ == '__main__':\n\n    main()", "output": "A", "improve_diff": 1.1032491724, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nD, E = [], []\n\nt,l = 0, 0\n\nres = 0\n\nfor _ in range(N):\n\n    S = input().rstrip()\n\n    x,y = 0,0\n\n    for s in S:\n\n        if s==\"(\": x+=1\n\n        else: x=max(x-1,0)\n\n    for s in reversed(S):\n\n        if s==\")\": y+=1\n\n        else: y=max(y-1,0)\n\n    D.append((x,y))\n\nD.sort(key=lambda x:x[1])\n\nt = 0\n\nfor x,y in D:\n\n    if x-y>=0:\n\n        if t>=y: t+=x-y\n\n        else: print(\"No\"); exit()\n\nD.sort(key=lambda x:x[0])\n\ns = 0\n\nfor x,y in D:\n\n    if y-x>=0:\n\n        if s>=x: s+=y-x\n\n        else: print(\"No\"); exit()\n\nif t!=s: print(\"No\")\n\nelse: print(\"Yes\")\n \nB. import sys\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nD, E = [], []\n\nt,l = 0, 0\n\nres = 0\n\nfor _ in range(N):\n\n    S = input().rstrip()\n\n    x,y = 0,0\n\n    for s in S:\n\n        if s==\"(\": x+=1\n\n        else: x=max(x-1,0)\n\n    for s in reversed(S):\n\n        if s==\")\": y+=1\n\n        else: y=max(y-1,0)\n\n    D.append((x,y))\n\nD.sort(key=lambda x:x[1])\n\nt = 0\n\nfor x,y in D:\n\n    if x-y>=0:\n\n        if t>=y: t+=x-y\n\n        else: print(\"No\"); exit()\n\nD.sort(key=lambda x:x[0])\n\ns = 0\n\nfor x,y in D:\n\n    if y-x>=0:\n\n        if s>=x: s+=y-x\n\n        else: print(\"No\"); exit()\n\nif t!=s: print(\"No\")\n\nelse: print(\"Yes\")\n", "output": "A", "improve_diff": 1.0405649727, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nbin_A=[bin(c) for c in A]\n\nflags=[True]*N\n\n\n\ncount=0\n\nfor keta in range(60):\n\n   count_0=0\n\n   count_1=0\n\n   for i in range(N):\n\n      if flags[i]:\n\n         if bin_A[i][-1*(keta+1)]==\"b\":\n\n            count_0+=1\n\n            flags[i]=False\n\n         elif bin_A[i][-1*(keta+1)]==\"0\":\n\n            count_0+=1\n\n         else:\n\n            count_1+=1\n\n      elif flags[i]==False:\n\n         count_0+=1\n\n   count+=count_0*count_1*2**keta\n\n\n\nprint((count%(10**9+7))) \nB. from sys import stdin\n\nimport numpy as np\n\ndef main():\n\n    #\n\n    readline=stdin.readline\n\n    mod=10**9+7\n\n    n=int(readline())\n\n    a=list(map(int,readline().split()))\n\n    a=np.array(a,dtype=np.int64)\n\n\n\n    b=np.array([((a>>i)&1).sum() for i in range(61)],dtype=np.int64)\n\n    c=np.full(61,n,dtype=np.int64)-b\n\n    d=b*c\n\n    d%=mod\n\n\n\n    ans=0\n\n    now=1\n\n    for i in range(60):\n\n        ans+=d[i]*now\n\n        ans%=mod\n\n        now*=2\n\n        now%=mod\n\n\n\n    print(ans)\n\n\n\nif __name__==\"__main__\":\n\n    main()", "output": "A", "improve_diff": 9.1861750352, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\nimport bisect\n\nimport heapq\n\nimport math\n\nimport random\n\nimport sys\n\nfrom collections import Counter, defaultdict, deque\n\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\n\nfrom functools import lru_cache, reduce\n\nfrom itertools import combinations, combinations_with_replacement, product, permutations\n\nfrom operator import add, mul, sub\n\n\n\nsys.setrecursionlimit(100000)\n\n\n\n\n\ndef read_int():\n\n    return int(input())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(input())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, input().split()))\n\n\n\n\n\ndef read_str():\n\n    return input().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return list(map(str, input().split()))\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\nclass Mod:\n\n    def __init__(self, m):\n\n        self.m = m\n\n    \n\n    def add(self, a, b):\n\n        return (a + b ) % self.m\n\n\n\n    def sub(self, a, b):\n\n        return (a - b) % self.m\n\n    \n\n    def mul(self, a, b):\n\n        return ((a % self.m) * (b % self.m)) % self.m\n\n\n\n    def div(self, a, b):\n\n        return self.mul(a, self.pow(b, self.m-2))\n\n\n\n    def pow(self, x, y):\n\n        if y == 0: \n\n            return 1\n\n        elif y == 1: \n\n            return x % self.m\n\n        elif y % 2 == 0: \n\n            return self.pow(x, y//2)**2 % self.m\n\n        else: \n\n            return self.pow(x, y//2)**2 * x % self.m\n\n\n\n\n\n@mt\n\ndef slv(N):\n\n    if N==3:\n\n        return 61\n\n\n\n    m = Mod(10**9+7)\n\n    dp = {}\n\n    iv = [\n\n        'agc',\n\n        'acg',\n\n        'gac',\n\n        'aggc'\n\n        'acgc',\n\n        'atgc',\n\n        'agac',\n\n        'aggc',\n\n        'agtc',\n\n    ]\n\n    for s in product('agct', repeat=4):\n\n        s = ''.join(s)\n\n        if not any(map(lambda x: x in s, iv)):\n\n            dp[s] = 1\n\n\n\n    for _ in range(N-4):\n\n        dp_ = Counter()\n\n        for k, v in dp.items():\n\n            for c in 'agct':\n\n                s = k + c\n\n                if not any(map(lambda x: x in s, iv)):\n\n                    dp_[s[1:]] = m.add(v, dp_[s[1:]])\n\n        dp = dp_\n\n    \n\n    ans = 0\n\n    for k, v in d \nB. # -*- coding: utf-8 -*-\n\nimport bisect\n\nimport heapq\n\nimport math\n\nimport random\n\nimport sys\n\nfrom collections import Counter, defaultdict, deque\n\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\n\nfrom functools import lru_cache, reduce\n\nfrom itertools import combinations, combinations_with_replacement, product, permutations\n\nfrom operator import add, mul, sub\n\n\n\nsys.setrecursionlimit(100000)\n\n\n\n\n\ndef read_int():\n\n    return int(input())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(input())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, input().split()))\n\n\n\n\n\ndef read_str():\n\n    return input().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return list(map(str, input().split()))\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\nclass Mod:\n\n    def __init__(self, m):\n\n        self.m = m\n\n    \n\n    def add(self, a, b):\n\n        return (a + b ) % self.m\n\n\n\n    def sub(self, a, b):\n\n        return (a - b) % self.m\n\n    \n\n    def mul(self, a, b):\n\n        return ((a % self.m) * (b % self.m)) % self.m\n\n\n\n    def div(self, a, b):\n\n        return self.mul(a, self.pow(b, self.m-2))\n\n\n\n    def pow(self, x, y):\n\n        if y == 0: \n\n            return 1\n\n        elif y == 1: \n\n            return x % self.m\n\n        elif y % 2 == 0: \n\n            return self.pow(x, y//2)**2 % self.m\n\n        else: \n\n            return self.pow(x, y//2)**2 * x % self.m\n\n\n\n\n\n@mt\n\ndef slv(N):\n\n    if N==3:\n\n        return 61\n\n\n\n    m = Mod(10**9+7)\n\n    dp = {}\n\n    iv = [\n\n        'agc',\n\n        'acg',\n\n        'gac',\n\n        'aggc'\n\n        'acgc',\n\n        'atgc',\n\n        'agac',\n\n        'aggc',\n\n        'agtc',\n\n    ]\n\n    for s in product('agct', repeat=4):\n\n        s = ''.join(s)\n\n        if not any(map(lambda x: x in s, iv)):\n\n            dp[s] = 1\n\n\n\n    for _ in range(N-4):\n\n        dp_ = Counter()\n\n        for k, v in dp.items():\n\n            for c in 'agct':\n\n                s = k + c\n\n                s = s[1:]\n\n                if s in dp:\n\n                    dp_[s] = m.add(v, dp_[s])\n\n        dp = dp_\n\n    \n\n    ans = 0\n\n    for k, v in d", "output": "B", "improve_diff": 1.7705125873, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from heapq import heapify,heappush, heappop\n\n\n\nN=eval(input())\n\nA=list(map(int, input().split())) \n\n\n\nhq1=A[:N]\n\nheapify(hq1)\n\nsum1=sum(hq1)\n\n\n\n\n\nT1=[]\n\nT1.append(sum1)\n\n\n\nfor i in range(N, 2*N):\n\n\tx=A[i]\n\n\tif hq1[0]<x:\n\n\t\tu=heappop(hq1)\n\n\t\theappush(hq1,x)\n\n\t\tsum1+=(x-u)\n\n\tT1.append(sum1)\n\n\n\n\n\nhq2=[x*-1 for x in A[2*N:]]\n\nsum2=-1*sum(hq2)\n\nheapify(hq2)\n\n\n\n\n\n\n\nT2=[]\n\nT2.append(sum2)\n\n\n\nfor i in range(2*N-1,N-1,-1):\n\n\tx=A[i]\n\n\tif x*-1 > hq2[0]<x:\n\n\t\t\tu=heappop(hq2)\n\n\t\t\theappush(hq2,x*-1)\n\n\t\t\tsum2+=u+x\n\n\n\n\tT2.append(sum2)\n\n\n\n\n\nT2.reverse()\n\n\n\n\n\nans=float(\"-inf\")\n\nfor x, y in zip(T1, T2):\n\n\tans=max(ans , x-y)\n\nprint(ans)\n \nB. from heapq import heapify,heappush, heappop\n\n\n\nN=eval(input())\n\nA=list(map( int, input().split() )) \n\n\n\nq=A[:N]\n\nheapify(q)\n\nq_sum=sum(q)\n\n\n\nB=[ float(\"-inf\") for i in range(3*N)]\n\nB[N-1]=q_sum\n\n\n\nfor i in range(N,2*N):\n\n\tx=A[i]\n\n\tif x>q[0]:\n\n\t\ttmp=heappop(q)\n\n\t\tq_sum-=tmp\n\n\t\tq_sum+=x\n\n\t\theappush(q,x)\n\n\tB[i]=q_sum\n\n\n\nq=[x*-1 for x in A[2*N:]]\n\nheapify(q)\n\n\n\nq_sum=sum(q)*-1\n\nB[2*N-1]-=q_sum\n\n\n\nfor i in range(2*N-1,N-1,-1):\n\n\tx=A[i]*-1\n\n\tif q[0]<x:\n\n\t\ttmp=heappop(q)\n\n\t\tq_sum-=tmp*-1\n\n\t\tq_sum+=x*-1\n\n\t\theappush(q,x)\n\n\tB[i-1]-=q_sum\n\n\n\nprint(max(B))", "output": "B", "improve_diff": 1.0319906609, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m,r=list(map(int,input().split()))\n\na,b=sorted([n-1,r-m*n])\n\nif a<1:print((0))\n\nelse:\n\n d=1\n\n for i in range(a):d*=i+1\n\n u=1\n\n for i in range(b,a+b):u*=i+1\n\n print((u//d))\n \nB. n,m,r=list(map(int,input().split()))\n\nr-=n*m\n\nif r<0:print((0))\n\nelse:\n\n from math import*\n\n print((factorial(n+r-1)//factorial(r)//factorial(n-1)))\n", "output": "A", "improve_diff": 1.3812719217, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nR = list(range(N))\n\nL = list(range(N))\n\nI = [-1] * (N+1)\n\nfor i, p in enumerate(P):\n\n    I[p] = i\n\n\n\nans = 0\n\nfor n, idx in enumerate(I[1:], 1):\n\n    l = idx-1\n\n    while l>=0 and l!=L[l]:\n\n        l = L[l]\n\n    r = idx+1\n\n    while r<N and r!=R[r]:\n\n        r = R[r]\n\n    L[idx] = l\n\n    R[idx] = r\n\n\n\n    if l != -1:\n\n        l2 = l-1\n\n        while l2>=0 and l2!=L[l2]:\n\n            l2 = L[l2]\n\n        ans += n * (l-l2) * (r-idx)\n\n    if r != N:\n\n        r2 = r+1\n\n        while r2<N and r2!=R[r2]:\n\n            r2 = R[r2]\n\n        ans += n * (idx-l) * (r2-r)\n\nprint(ans)\n \nB. N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nR = list(range(N))\n\nL = list(range(N))\n\nI = [-1] * (N+1)\n\nfor i, p in enumerate(P):\n\n    I[p] = i\n\n\n\nans = 0\n\nfor n, idx in enumerate(I[1:], 1):\n\n    l = idx-1\n\n    if l>=0:\n\n        l = L[l]\n\n    r = idx+1\n\n    if r<N:\n\n        r = R[r]\n\n    L[r-1] = l\n\n    R[l+1] = r\n\n\n\n    if l>=0:\n\n        l2 = l-1\n\n        if l2>=0:\n\n            l2 = L[l2]\n\n        ans += n * (l-l2) * (r-idx)\n\n    if r<N:\n\n        r2 = r+1\n\n        if r2<N:\n\n            r2 = R[r2]\n\n        ans += n * (idx-l) * (r2-r)\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0280028897, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport math\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nsys.setrecursionlimit(10**7)\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\n\n\nmod = 10**9 + 7\n\n\n\ndef I(): return int(eval(input()))\n\ndef LI(): return list(map(int, input().split()))\n\ndef LIR(row,col):\n\n    if row <= 0:\n\n        return [[] for _ in range(col)]\n\n    elif col == 1:\n\n        return [I() for _ in range(row)]\n\n    else:\n\n        read_all = [LI() for _ in range(row)]\n\n        return list(map(list, list(zip(*read_all))))\n\n\n\n#################\n\n\n\nfrom decimal import getcontext,Decimal\n\ngetcontext().prec = 28\n\n\n\nA,B = list(map(str, input().split()))\n\nA = int(A)\n\nB = Decimal(B)\n\n\n\nprint((int(A*B))) \nB. import sys\n\nimport math\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nsys.setrecursionlimit(10**7)\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\n\n\nmod = 10**9 + 7\n\n\n\ndef I(): return int(eval(input()))\n\ndef LI(): return list(map(int, input().split()))\n\ndef LIR(row,col):\n\n    if row <= 0:\n\n        return [[] for _ in range(col)]\n\n    elif col == 1:\n\n        return [I() for _ in range(row)]\n\n    else:\n\n        read_all = [LI() for _ in range(row)]\n\n        return list(map(list, list(zip(*read_all))))\n\n\n\n#################\n\n\n\nA,B = list(map(str, input().split()))\n\nA = int(A)\n\nB = 100*int(B[0])+10*int(B[2])+int(B[3])\n\n\n\nprint((A*B//100))", "output": "B", "improve_diff": 1.0889880788, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    num = int(eval(input()))\n\n    counter = [0] * (num + 1)\n\n    # func(41, 41, 41) = 10086\n\n    # func(99, 1, 1) = 10002\n\n    for x in range(1, 100):\n\n        for y in range(1, 100):\n\n            for z in range(1, 123 - x - y + 1):\n\n                tmp = (x + y + z) ** 2 - x * y - y * z - z * x\n\n                if tmp > num:\n\n                    break\n\n                counter[tmp] += 1\n\n    for count in counter[1:]:\n\n        print(count)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    num = int(eval(input()))\n\n    counter = [0] * (num + 1)\n\n    # func(41, 41, 41) = 10086\n\n    # func(99, 1, 1) = 10002\n\n    for x in range(1, 100):\n\n        for y in range(1, 100):\n\n            for z in range(1, 123 - x - y + 1):\n\n                tmp = (x + y + z) ** 2 - x * y - y * z - z * x\n\n                if tmp <= num:\n\n                    counter[tmp] += 1\n\n    for count in counter[1:]:\n\n        print(count)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 4.1230497282, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nn, q = map(int, sys.stdin.readline().split())\n\ng = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n\n    a, b = map(int, sys.stdin.readline().split())\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\npx = zip(*[map(int, sys.stdin.read().split())] * 2)\n\n\n\ndef main():\n\n    value = [0] * (n + 1)\n\n    for p, x in px:\n\n        value[p] += x\n\n    \n\n    stack = [1]\n\n    par = [None] * (n + 1)\n\n    while stack:\n\n        u = stack.pop()\n\n        for v in g[u]:\n\n            if v != par[u]:\n\n                par[v] = u\n\n                value[v] += value[u]\n\n                stack.append(v)\n\n    \n\n    return value[1:]\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep=' ')\n \nB. # 2019-11-17 10:52:21(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# import re\n\n# import heapq\n\n# import array\n\n# from scipy.misc import comb # (default: exact=False)\n\n# import numpy as np \n\n\n\n\n\ndef main():\n\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n\n    AB = [[] for _ in range(n+1)]\n\n    for _ in range(n-1):\n\n        a, b = [int(x) for x in sys.stdin.readline().split()]\n\n        AB[a].append(b)\n\n        AB[b].append(a)\n\n    # \n\n\n\n    ans = [0 for _ in range(n+1)]\n\n    for _ in range(q):\n\n        p, x = [int(x) for x in sys.stdin.readline().split()]\n\n        ans[p] += x\n\n    \n\n    stack = [1]\n\n    parent = [0 for _ in range(n+1)]\n\n    while stack:\n\n        x = stack.pop()\n\n        for y in AB[x]:\n\n            if y != parent[x]: # yx\n\n                parent[y] = x # xy\n\n                stack.append(y)\n\n                ans[y] += ans[x]\n\n \n\n    \n\n    print((' '.join(map(str, ans[1:]))))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n\n", "output": "A", "improve_diff": 1.029080382, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na,b,c = [sorted(list(map(int,input().split())),reverse=True) for i in range(3)]\n\ncomp1 = []\n\ni,j = 0,0\n\ncnt = 0\n\nwhile i<n:\n\n    while j<n and b[j]>a[i]:\n\n        cnt+=1\n\n        j+=1\n\n    comp1.append(cnt)\n\n    i+=1\n\ncomp2 = []\n\ni,j = 0,0\n\ncnt = 0\n\nwhile i<n:\n\n    while j<n and c[j]>b[i]:\n\n        cnt+=1\n\n        j+=1\n\n    comp2.append(cnt)\n\n    i+=1\n\nx = [0]\n\nfor i in range(n):\n\n    x.append(x[i]+comp2[i])\n\nans = 0\n\nfor i in comp1:\n\n    ans += x[i]\n\nprint(ans) \nB. import bisect\n\nn = int(eval(input()))\n\na,b,c = [sorted(list(map(int,input().split()))) for i in range(3)]\n\nans = 0\n\ncnt = [0]\n\n[cnt.append(cnt[i]+bisect.bisect_left(a,b[i])) for i in range(n)]\n\nfor i in range(n):\n\n    index = bisect.bisect_left(b,c[i])\n\n    ans += cnt[index] \n\nprint(ans)", "output": "A", "improve_diff": 1.4189690539, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    from collections import Counter\n\n    c = Counter(A)\n\n    even = len([v for v in list(c.values()) if v % 2 == 0])\n\n    ans = len(list(c.keys()))\n\n    if even % 2 == 1:\n\n        ans -= 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    \"\"\"\n\n    12\n\n    \n\n    \"\"\"\n\n    _ = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    from collections import Counter\n\n    c = Counter(A)\n\n    even = len([v for v in list(c.values()) if v % 2 == 0])\n\n    ans = len(list(c.keys()))\n\n    if even % 2 == 1:\n\n        ans -= 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0107159851, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nm = Counter(a)\n\nfor x, y in list(m.items()):\n\n    if x == y:\n\n        continue\n\n    elif x < y:\n\n        ans += abs(y-x)\n\n    else:\n\n        ans += y\n\nprint(ans) \nB. from collections import Counter\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nb = Counter(a)\n\nans = 0\n\nfor x in b:\n\n    if b[x] > x:\n\n        ans += b[x] - x\n\n    elif b[x] < x:\n\n        ans += b[x]\n\nprint(ans)", "output": "B", "improve_diff": 1.0127020987, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\nN, M = list(map(int, input().split()))\n\n\n\ndivisor = []\n\nfor i in range(1, int(M ** 0.5) + 1):\n\n    if M % i == 0:\n\n        divisor.append(i)\n\n        if i != M // i:\n\n            divisor.append(M // i)\n\n\n\nprint((max([x for x in divisor if x <= M // N])))\n \nB. \n\nN, M = list(map(int, input().split()))\n\n\n\nif M % N == 0:\n\n    print((M // N))\n\nelse:\n\n    ans = 1\n\n    for n in range(1, M // N + 1):\n\n        res = M - n * N\n\n        if res % n == 0:\n\n            ans = n\n\n\n\n    print(ans)\n", "output": "B", "improve_diff": 1.0409546373, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nd = defaultdict(int)\n\nfor i in range(1, N + 1):\n\n    s = str(i)\n\n    f = int(s[0])\n\n    b = int(s[-1])\n\n    d[(f, b)] += 1\n\n\n\nans = 0\n\nfor a in range(1, 10):\n\n    for b in range(1, 10):\n\n        ans += d[(a, b)] * d[(b, a)]\n\nprint(ans) \nB. N = int(eval(input()))\n\n\n\nd = [[0]*9 for _ in range(9)]\n\n\n\nfor i in range(1, N + 1):\n\n    if i % 10 == 0:\n\n        continue\n\n    s = str(i)\n\n    x = int(s[-1])\n\n    y = int(s[0])\n\n    d[x-1][y-1] += 1\n\n\n\nans = 0\n\nfor i in range(9):\n\n    for j in range(9):\n\n        ans += d[i][j] * d[j][i]\n\nprint(ans)\n", "output": "B", "improve_diff": 1.345306692, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m, x = list(map(int, input().split()))\n\nc_list = [] \n\na_list = []\n\nfor i in range(0, n):\n\n  c, *a = list(map(int, input().split()))\n\n  c_list.append(c)\n\n  a_list.append(a)\n\nans = float(\"inf\")\n\n\n\nfor x1 in [0, 1]:\n\n  for x2 in [0, 1]:\n\n    for x3 in [0, 1]:\n\n      for x4 in [0, 1]:\n\n        for x5 in [0, 1]:\n\n          for x6 in [0, 1]:\n\n            for x7 in [0, 1]:\n\n              for x8 in [0, 1]:\n\n                for x9 in [0, 1]:\n\n                  for x10 in [0, 1]:\n\n                    for x11 in [0, 1]:\n\n                      for x12 in [0, 1]:\n\n                        if n == 1:\n\n                          x_list = [x1]\n\n                        elif n == 2:\n\n                          x_list = [x1, x2]\n\n                        elif n == 3:\n\n                          x_list = [x1, x2, x3]\n\n                        elif n == 4:\n\n                          x_list = [x1, x2, x3, x4]\n\n                        elif n == 5:\n\n                          x_list = [x1, x2, x3, x4 ,x5]\n\n                        elif n == 6:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6]\n\n                        elif n == 7:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7]\n\n                        elif n == 8:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7, x8]\n\n                        elif n == 9:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7, x8, x9]\n\n                        elif n == 10:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7, x8, x9, x10]\n\n                        elif n == 11:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7, x8, x9, x10, x11]\n\n                        elif n == 12:\n\n                          x_list = [x1, x2, x3, x4 ,x5, x6, x7, x8, x9, x10, x11, x12]\n\n                        cost = 0\n\n                        gaku_list = [0] * m\n\n                        for i in range(0, n):\n\n                          if x_list[i] == 1:\n\n                            for j in range(0, m):\n\n                              gaku_list[j] += a_list[i][j]\n\n                            cost += c_list[i]\n\n                        flag = 1\n\n                        for gaku in gaku_list:\n\n                          if gaku < x:\n\n                            flag = 0\n\n                            break\n\n                        if flag == 1 and cost < ans:\n\n                          ans = cost\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print(ans) \nB. #!/usr/bin/python3\n\n# -*- coding: utf-8 -*-\n\nimport numpy as np\n\ndef func(ans, b_list, a_list, c_list, k, x):\n\n    if k == 0:\n\n        b_list = np.asarray(b_list)\n\n        x_list = np.dot(b_list, a_list)\n\n        if np.all(x_list >= x):\n\n            return np.inner(c_list, b_list)\n\n        else:\n\n            return ans\n\n    ans = min(ans, func(ans, b_list + [1], a_list, c_list, k - 1, x))\n\n    ans = min(ans, func(ans, b_list + [0], a_list, c_list, k - 1, x))\n\n    return ans\n\n\n\nn, m, x = list(map(int, input().split()))\n\nc_list = [] \n\na_list = []\n\nfor i in range(0, n):\n\n    c, *a = list(map(int, input().split()))\n\n    c_list.append(c)\n\n    a_list.append(a)\n\nans = float(\"inf\")\n\nc_list = np.asarray(c_list)\n\na_list = np.asarray(a_list)\n\nans = min(ans, func(ans, [1], a_list, c_list, n - 1, x))\n\nans = min(ans, func(ans, [0], a_list, c_list, n - 1, x))\n\n\n\nif ans == float(\"inf\"):\n\n    print((-1))\n\nelse:\n\n    print(ans)\n", "output": "A", "improve_diff": 5.5880535478, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n \n\n \n\ndef comb(n, r):\n\n    return math.factorial(n) / math.factorial(r) / math.factorial(n - r)\n\n \n\n \n\ndef main():\n\n    n, p = list(map(int, input().split()))\n\n    a = tuple([int(x) % 2 for x in input().split()])\n\n \n\n    if n == 1 and a[0] % 2 != p:\n\n        print((0))\n\n        return 0\n\n \n\n    t = len(tuple([x for x in a if x == 1]))\n\n    f = n - t\n\n \n\n    f_comb = 0\n\n    for j in range(f + 1):\n\n        f_comb += comb(f, j)\n\n \n\n    t_comb = 0\n\n    if p == 0:\n\n        for i in range(t + 1):\n\n            if i % 2 == 0:\n\n                t_comb += comb(t, i)\n\n    else:\n\n        for i in range(t + 1):\n\n            if i % 2 == 1:\n\n                t_comb += comb(t, i)\n\n \n\n    print((int(t_comb * f_comb)))\n\n \n\n    return 0\n\n \n\n \n\nif __name__ == '__main__':\n\n    main() \nB. n, p = list(map(int, input().split()))\n\n\n\ncount = {0: 0, 1: 0}\n\nfor a in input().split():\n\n    count[int(a) % 2] += 1\n\n\n\nif count[1] == 0:\n\n    if p == 0:\n\n        print((pow(2, n)))\n\n    else:\n\n        print((0))\n\nelse:\n\n    print((pow(2, n - 1)))", "output": "B", "improve_diff": 1.3883644087, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\na = [int(ai) for ai in input().split()]\n\n\n\ncount = 0\n\nfor i in range(0, N-1):\n\n    if a[i] == a[i+1]:\n\n        count += 1\n\n        a[i+1] = float('inf')\n\nprint(count) \nB. import random\n\nN = int(eval(input()))\n\na = [int(ai) for ai in input().split()]\n\n\n\nrandom.seed(42)\n\ncount = 0\n\nfor i in range(0, N-1):\n\n    if a[i] == a[i+1]:\n\n        count += 1\n\n    while a[i] == a[i+1]:\n\n        a[i+1] = random.randint(1, N)\n\n        if i < N - 2:\n\n            while a[i+1] == a[i+2]:\n\n                a[i+1] = random.randint(1, N)\n\n\n\nprint(count)", "output": "A", "improve_diff": 1.6982304397, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k = list(map(int, input().split()))\n\npositions = [int(i) for i in input().split()]\n\nscores = [int(i) for i in input().split()]\n\nif max(scores) <= 0:\n\n  print((max(scores)))\n\nelse:\n\n  positions = [0] + positions\n\n  scores = [0] + scores\n\n  max_point = -pow(10, 9)\n\n  #print(max_point)\n\n  for i in range(1, n + 1):\n\n    s = []\n\n    f_pos = positions[i]\n\n    score = scores[f_pos]\n\n    s.append(score)\n\n    while f_pos != i:\n\n      f_pos = positions[f_pos]\n\n      score += scores[f_pos]\n\n      s.append(score)\n\n    loop = len(s)\n\n    if loop >= k:\n\n      point = max(s[:k])\n\n    elif s[-1] <= 0:\n\n      point = max(s)\n\n    else:\n\n      loop_c = k // loop\n\n      r = k % loop\n\n      point1 = s[-1] * loop_c\n\n      if r != 0:\n\n        point1 += max(s[:r])\n\n      point2 = s[-1] * (loop_c - 1)\n\n      point2 += max(0, max(s))\n\n      point = max(point1, point2)\n\n    max_point = max(max_point, point)\n\n  print(max_point)\n \nB. n, k = list(map(int, input().split()))\n\npositions = [int(i) for i in input().split()]\n\nscores = [int(i) for i in input().split()]\n\nif max(scores) <= 0:\n\n  print((max(scores)))\n\nelse:\n\n  positions = [0] + positions\n\n  scores = [0] + scores\n\n  max_point = -pow(10, 9)\n\n  #print(max_point)\n\n  dic = {}\n\n  for i in range(1, n + 1):\n\n    f_pos = i\n\n    #print('f_pos',f_pos)\n\n    if f_pos not in dic:\n\n      point_loop = 0\n\n      loop = 0\n\n      pos_set = set([f_pos])\n\n      while True:\n\n        f_pos = positions[f_pos]\n\n        point_loop += scores[f_pos]\n\n        #print('pos', f_pos)\n\n        #print(point)\n\n        loop += 1\n\n        if f_pos in pos_set:\n\n          for j in pos_set:\n\n            dic[j] = [loop, point_loop]\n\n          break\n\n        pos_set.add(f_pos)\n\n    else:\n\n      loop, point_loop = dic[f_pos]\n\n    #print(loop, point)\n\n    loop_c = k // loop\n\n    r = k % loop\n\n    if loop_c == 0 or point_loop <= 0:\n\n      if point_loop <= 0:\n\n        if loop_c > 0:\n\n          r = loop\n\n      point = 0\n\n      for _ in range(r):\n\n        f_pos = positions[f_pos]\n\n        point += scores[f_pos]\n\n        max_point = max(max_point, point)\n\n    else:\n\n      point1, point2 = 0, 0\n\n      point1 = loop_c * point_loop\n\n      max_point1 = point1\n\n      for _ in range(r):\n\n        f_pos = positions[f_pos]\n\n        point1 += scores[f_pos]\n\n        max_point1 = max(point1, max_point1)\n\n      f_pos = i\n\n      point2 = (loop_c - 1) * point_loop\n\n      max_point2 = point2\n\n      for _ in range(loop):\n\n        f_pos = positions[f_pos]\n\n        point2 += scores[f_pos]\n\n        max_point2 = max(point2, max_point2)\n\n      max_point = max(max_point, max(max_point1, max_point2))\n\n  print(max_point)\n", "output": "A", "improve_diff": 1.050442375, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\ninput = stdin.readline\n\n\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\n\n\nN, K = [int(i) for i in input().split()]\n\n\n\nmemo = [0] * 100010\n\nfor _ in range(N):\n\n    a, b = [int(i) for i in input().split()]\n\n    memo[a] += b\n\n\n\nprint((bisect_left(list(accumulate(memo)), K))) \nB. from itertools import accumulate\n\nfrom bisect import bisect_left\n\n\n\nN, K = [int(i) for i in input().split()]\n\n\n\nmemo = [0] * 100010\n\nfor _ in range(N):\n\n    a, b = [int(i) for i in input().split()]\n\n    memo[a] += b\n\n\n\nprint((bisect_left(list(accumulate(memo)), K)))", "output": "B", "improve_diff": 1.0210260693, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nN,K=[int(s) for s in input().split()]\n\nsum=0\n\nfor i in range(N):\n\n  a=max([math.log(K/(i+1), 2),0])\n\n  a=math.ceil(a)\n\n  sum=sum+0.5**a\n\nprint((sum/N)) \nB. import math\n\nN,K=[int(s) for s in input().split()]\n\na=0\n\nfor i in range(N):\n\n  a+=2**(-max([0,math.ceil(math.log2(K/(i+1)))]))\n\nprint((a/N))", "output": "B", "improve_diff": 1.2207546406, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nN = int(eval(input()))\n\nX = list(map(int, input().split()))\n\n\n\nX_sort = sorted(X)\n\nsmall, big = X_sort[N//2-1], X_sort[N//2]\n\n\n\nfor x in X:\n\n    if x >= big:\n\n        print(small)\n\n    else:\n\n        print(big) \nB. N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\n\n\nX_sort = sorted(X)\n\nsmall, big = X_sort[N//2-1], X_sort[N//2]\n\n\n\nfor x in X:\n\n    if x >= big:\n\n        print(small)\n\n    else:\n\n        print(big)", "output": "B", "improve_diff": 11.2800532138, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m = list(map(int, input().split()))\n\n\n\ncard = [[] for _ in range(n)]\n\n\n\nfor _ in range(m):\n\n    x, y, _ = list(map(int, input().split()))\n\n    card[x-1].append(y-1)\n\n    card[y-1].append(x-1)\n\n\n\nchecked = [False] * n\n\n\n\ncount = 0\n\nimport queue\n\nq = queue.Queue()\n\nfor i in range(n):\n\n    if checked[i]:\n\n        continue\n\n    count += 1\n\n    q.put(i)\n\n    while not q.empty():\n\n        j = q.get()\n\n        checked[j] = True\n\n        for k in card[j]:\n\n            if not checked[k]:\n\n                q.put(k)\n\n\n\nprint (count)\n\n\n\n\n\n    \n\n\n \nB. n, m = list(map(int, input().split()))\n\n\n\ncard = [[] for _ in range(n)]\n\n\n\nfor _ in range(m):\n\n    x, y, _ = list(map(int, input().split()))\n\n    card[x-1].append(y-1)\n\n    card[y-1].append(x-1)\n\n\n\nchecked = [False] * n\n\n\n\ncount = 0\n\nfrom collections import deque\n\nfor i in range(n):\n\n    if checked[i]:\n\n        continue\n\n    count += 1\n\n    q = deque([i])\n\n    while q:\n\n        j = q.popleft()\n\n        checked[j] = True\n\n        for k in card[j]:\n\n            if not checked[k]:\n\n                q.append(k)\n\nprint (count) \n\n\n", "output": "B", "improve_diff": 2.4492108321, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    l = [i for i in range(1, N+1)]\n\n    l = list(itertools.permutations(l))\n\n    \n\n    a = 0\n\n    for k, v in enumerate(l):\n\n        if A == list(v):\n\n            a = k+1\n\n        \n\n    b = 0\n\n    for k, v in enumerate(l):\n\n        if B == list(v):\n\n            b = k+1\n\n    return abs(a-b)\n\n\n\nprint((solve())) \nB. import itertools\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    l = [i for i in range(1, N+1)]\n\n    l = list(itertools.permutations(l))\n\n    \n\n    a = 0\n\n    b = 0\n\n    for k, v in enumerate(l):\n\n        v = list(v)\n\n        if v == A:\n\n            a = k+1\n\n        if v == B:\n\n            b = k+1\n\n    \n\n    return abs(a-b)\n\n\n\nprint((solve()))", "output": "A", "improve_diff": 1.0751356168, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_left as b\n\nn,m= list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.sort()\n\nwhile m>0:\n\n  i=a.pop(-1)//2\n\n  a.insert(b(a,i),i)\n\n  m-=1\n\nprint((sum(a))) \nB. import heapq\n\n\n\nN, M = list(map(int,input().split()))\n\nA = list([int(x) * (-1) for x in input().split()])\n\nheapq.heapify(A)\n\n\n\nfor _ in range(M):\n\n  tmp_min = heapq.heappop(A)\n\n  heapq.heappush(A, (-1) * (-tmp_min // 2))\n\n\n\nprint((-sum(A)))", "output": "B", "improve_diff": 1.1166948703, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. W, H, x, y, r = list(map(int, input().split()))\n\n \n\nif x - r < 0 or x + r > W or y - r < 0 or y + r > H:\n\n  print (\"No\")\n\nelse:\n\n  print (\"Yes\") \nB. W, H, x, y, r = (int(i) for i in input().split())\n\n \n\nif x - r < 0 :\n\n    print(\"No\")\n\nelif x + r > W:\n\n    print(\"No\")\n\nelif  y - r < 0:\n\n    print(\"No\")\n\nelif y + r > H:\n\n  print (\"No\")\n\nelse:\n\n  print (\"Yes\")", "output": "B", "improve_diff": 1.0154259909, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nfrom operator import itemgetter\n\nsys.setrecursionlimit(10000000)\n\nINF = 10**30\n\n\n\nans = 0\n\nc = ['3', '5', '7']\n\nN = 0\n\n\n\ndef check(l):\n\n    return len(set(l)) == 3\n\n\n\ndef nummaker(k, n):\n\n    global ans\n\n    if k == 0:\n\n        q = int(''.join(n))\n\n        if q > N:\n\n            print(ans)\n\n            sys.exit(0)\n\n        if check(n):\n\n            ans += 1\n\n        return\n\n    for i in c:\n\n        m = n[:]\n\n        m.append(i)\n\n        nummaker(k-1, m)\n\n\n\ndef main():\n\n    global N\n\n    N = int(input().strip())\n\n    for i in range(1, 11):\n\n        nummaker(i, [])\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\n\n\nc = 0\n\nnum = 0\n\ndef check(n):\n\n\tstrn = str(n)\n\n\tl = [0, 0, 0]\n\n\tfor c in strn:\n\n\t\tif c == '3':\n\n\t\t\tl[0] = 1\n\n\t\telif c == '5':\n\n\t\t\tl[1] = 1\n\n\t\telif c == '7':\n\n\t\t\tl[2] = 1\n\n\treturn all(l) or False\n\n\n\ndef gen(n):\n\n\tglobal c\n\n\t# print(n)\n\n\tif n > num:\n\n\t\treturn\n\n\tif check(n):\n\n\t\t# print(n)\n\n\t\tc += 1\n\n\tfor i in [3, 5, 7]:\n\n\t\tk = 10 * n + i\n\n\t\tgen(k)\n\n\n\ndef main():\n\n\tglobal num\n\n\tnum = int(input().strip())\n\n\tgen(0)\n\n\tprint(c)\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n", "output": "B", "improve_diff": 1.1359911641, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nL = list(map(int,input().split()))\n\nL.sort()\n\n\n\nans=0\n\nfor i in range(N-2):\n\n    for j in range(i+1,N):\n\n        ng=N\n\n        ok=j\n\n        while abs(ok-ng)!=1:\n\n            med =(ok+ng)//2\n\n            if L[med]<L[i]+L[j]:\n\n                ok=med\n\n            else:\n\n                ng=med\n\n        ans+=ok-j\n\nprint(ans) \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    import bisect\n\n    \n\n    mod=10**9+7\n\n    N=I()\n\n    L=LI()\n\n    L.sort()\n\n    ans=0\n\n    for i in range(N):\n\n        for j in range(i+1,N):\n\n            a=L[i]\n\n            b=L[j]\n\n            ab=a+b\n\n            num=bisect.bisect_left(L,ab)\n\n            \n\n            # print(i,j,num-j)\n\n            ans+=num-j-1\n\n            \n\n                \n\n    print(ans)\n\n    \n\n\n\nmain()\n", "output": "A", "improve_diff": 1.4116757623, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import combinations_with_replacement\n\n\n\nN, M, Q = list(map(int, input().split()))\n\nABCD = [list(map(int, input().split())) for i in range(Q)]\n\nans = 0\n\n\n\nfor A in combinations_with_replacement(list(range(M)), N):\n\n    temp = 0\n\n    for abcd in ABCD:\n\n        if A[abcd[1]-1]+1 == A[abcd[0]-1]+1 + abcd[2]:\n\n            temp += abcd[3]\n\n    if temp > ans:\n\n        ans = temp\n\nprint(ans) \nB. from itertools import combinations_with_replacement\n\n\n\ndef main():\n\n    N, M, Q = list(map(int, input().split()))\n\n    ABCD = [list(map(int, input().split())) for i in range(Q)]\n\n    ans = 0\n\n\n\n    for A in combinations_with_replacement(list(range(M)), N):\n\n        temp = 0\n\n        for abcd in ABCD:\n\n            if A[abcd[1]-1]+1 == A[abcd[0]-1]+1 + abcd[2]:\n\n                temp += abcd[3]\n\n        if temp > ans:\n\n            ans = temp\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.2274678534, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(h):\n\n    if h == 1:\n\n        return 1\n\n    return 1 + dfs(h // 2) * 2\n\n\n\n\n\ndef main():\n\n    h = int(eval(input()))\n\n    print((dfs(h)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n#\n\n# input = sys.stdin.readline\n\n# rstrip()\n\n# int(input())\n\n# map(int, input().split())\n \nB. H = int(eval(input()))\n\n\n\nret = 0\n\nmon = 1\n\nwhile H:\n\n    H //= 2\n\n    ret += mon\n\n    mon <<= 1\n\nprint(ret)\n", "output": "B", "improve_diff": 1.6491876436, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N, K = (int(i) for i in input().split())\n\n    h = [0] + [int(i) for i in input().split()]\n\n    memo = [float('inf')] * (N+1)\n\n\n\n    memo[1] = 0\n\n    for j in range(2, N+1):\n\n        for i in range(j-K, j):\n\n            if i < 0:\n\n                continue\n\n            memo[j] = min(memo[j], memo[i] + abs(h[j] - h[i]))\n\n\n\n    print((memo[N]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. n, k = list(map(int,input().split()))\n\nh = list(map(int,input().split()))\n\n\n\ndp = [float(\"inf\")] * n\n\ndp[0] = 0\n\n\n\nfor i in range(n-1):\n\n    for j in range(1,k+1):\n\n        if i+j <= n-1:\n\n            dp[i+j] = min(dp[i] + abs(h[i] - h[i+j]), dp[i+j])\n\nprint((dp[n-1]))", "output": "B", "improve_diff": 1.005498364, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nprint(((10**n-2*9**n+8**n)%(10**9+7))) \nB. m = 10**9 + 7\n\ndef powmod(x,y):\n\n  a=1\n\n  for i in range(y):\n\n    a=(a*x)%m\n\n  return a\n\nn=int(eval(input()))\n\ns=powmod(10,n)-2*powmod(9,n)+powmod(8,n)\n\nprint(((s+m)%m))", "output": "B", "improve_diff": 1.6827421302, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN, M = list(map(int, input().split()))\n\ncnt = [0] * (N + 1)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    cnt[a] ^= 1\n\n    cnt[b] ^= 1\n\n\n\nif all(x == 0 for x in cnt):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\") \nB. N, M = list(map(int, input().split()))\n\n# OK?\n\n# \n\n\n\nedge = [0] * (N + 1)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edge[a] += 1\n\n    edge[b] -= 1\n\n\n\nans = \"YES\"\n\nfor i in range(N):\n\n    edge[i + 1] += edge[i]\n\n    if edge[i + 1] % 2 == 1:\n\n        ans = \"NO\"\n\n        break\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0216455438, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nans = 10**9+7\n\nfor i in range(N+1):\n\n  j = N-i\n\n  cnt = 0\n\n  while i > 0:\n\n    cnt += i%6\n\n    i //= 6\n\n  while j > 0:\n\n    cnt += j%9\n\n    j //= 9\n\n  ans = min(ans, cnt)\n\nprint(ans) \nB. N = int(eval(input()))\n\n\n\nsixs = [6**i for i in range(1,7)]\n\nnines = [9**i for i in range(1,6)]\n\ntmp = {}\n\n\n\ndef dfs(n):\n\n  if(n < 6):\n\n    return n\n\n\n\n  if(n in tmp):\n\n    return tmp[n]\n\n\n\n  m = 10**9+7\n\n  if(n >= 9):\n\n    max_nine = max(nine for nine in nines if nine <= n)\n\n    if(n%max_nine == 0):\n\n      m = min(m, n // max_nine)\n\n    else:\n\n      m = min(m, dfs(n - max_nine) + 1)\n\n\n\n  max_six = max(six for six in sixs if six <= n)\n\n  if(n%max_six == 0):\n\n    m = min(m, n // max_six)\n\n\n\n  tmp[n] = min(m, dfs(n - max_six) + 1)\n\n  return tmp[n]\n\n\n\nprint((dfs(N)))", "output": "B", "improve_diff": 2.746550525, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import permutations\n\nfrom math import sqrt, pow, factorial\n\n\n\nn = int(eval(input()))\n\nxy = [list(map(int, input().split())) for _ in range(n)]\n\n\n\ndef calc(a,b):\n\n    [x1, y1] = a\n\n    [x2, y2] = b\n\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))\n\n\n\nsum = 0\n\nfor i in permutations(list(range(n))):\n\n    distance = 0\n\n    for j in range(1, n):\n\n        distance = calc(xy[i[j]], xy[i[j-1]])\n\n        sum += distance\n\nprint((sum/factorial(n)))\n\n\n\n\n\n\n\n\n \nB. import numpy as np\n\nfrom itertools import combinations\n\nfrom itertools import permutations\n\nfrom math import factorial\n\n\n\n\n\nN = int(eval(input()))\n\nxy = np.array([list(map(int, input().split())) for _ in range(N)])\n\ncnt = 0\n\n\n\nfor i in xy:\n\n    for j in xy:\n\n        cnt += np.linalg.norm(i - j)\n\nprint((cnt / N))", "output": "A", "improve_diff": 7.8806636477, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn=int(eval(input()))\n\na=list(map(int,input().split()))\n\n\n\nlista=0\n\nfor i in range(n):\n\n    lista=lista+1/a[i]\n\nprint((1/lista))\n \nB. n=int(eval(input()))\n\na=list(map(int,input().split()))\n\n \n\nlista=0\n\nfor i in range(n):\n\n    lista=lista+1/a[i]\n\nprint((1/lista))\n", "output": "B", "improve_diff": 10.992636791, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nprint((-(-(N-1)//(K-1)))) \nB. import collections\n\nN,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = collections.Counter(A)[min(A)]\n\nprint((-(-(N-B)//(K-1))))", "output": "A", "improve_diff": 1.4636512139, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def findSumDigit(num):\n\n    global total\n\n    total = 0\n\n    while num > 0:\n\n        total += num % 10\n\n        num //= 10\n\n    return total\n\n\n\ndef main():\n\n    n,a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(1,n+1):\n\n        tmp = findSumDigit(i)\n\n        if a <= tmp <= b:\n\n            ans += i\n\n    print(ans)\n\n    \n\nif __name__ == '__main__':\n\n    main() \nB. n,a,b = list(map(int, input().split()))\n\nans = 0\n\n\n\ndef sum(k):\n\n  s = 0\n\n  for j in range(len(k)):\n\n    s+=int(k[j])\n\n  return s\n\n\n\nfor i in range(1,n+1):\n\n  if a<=sum(str(i))<=b:\n\n    ans+=i\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0382353509, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. '''\n\n \u2227_,,\u2227    WAAC\uff01\uff01\n\n\uff08`\u03c9)\u2501\u2606*\n\n\u2282  +.\n\n \u2019\u00b4\uff2a* \n\n'''\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef sieve(n):\n\n    is_prime = [True for _ in range(n+1)]\n\n    is_prime[0] = False\n\n\n\n    for i in range(2, n+1):\n\n        if is_prime[i-1]:\n\n            j = 2 * i\n\n            while j <= n:\n\n                is_prime[j-1] = False\n\n                j += i\n\n    #table = [ i for i in range(1, n+1) if is_prime[i-1]]\n\n    return is_prime\n\nn=10**5+2\n\na=sieve(n)\n\nans=[0]*(n//2)\n\nfor i in range(0,n,2):\n\n    if a[i] and a[i//2]:\n\n        ans[i//2]=1\n\n#print(ans[:20])\n\nfor i in range(1,n//2):\n\n    ans[i]+=ans[i-1]\n\n#print(ans[:20])\n\nq=int(eval(input()))\n\nfor i in range(q):\n\n    l,r=list(map(int,input().split()))\n\n    if l==1:\n\n        l=2\n\n    if r==1:\n\n        r=2\n\n    print((ans[r//2]-ans[l//2 -1])) \nB. import sys\n\ninput = sys.stdin.readline\n\nfrom math import sqrt\n\n\n\n\n\ndef Eratosthenes(n):\n\n    \"\"\"n(>=6) \"\"\"\n\n    n, correction = n - n % 6 + 6, 2 - (n % 6 > 1)\n\n    sieve = [True] * (n // 3)\n\n    for i in range(1, int(sqrt(n)) // 3 + 1):\n\n        if sieve[i]:\n\n            k = 3 * i + 1 | 1\n\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n\n            sieve[k * (k - 2 * (i & 1) + 4) // 3::2 * k] = [False] * ((n // 6 - k * (k - 2 * (i & 1) + 4) // 6 - 1) // k + 1)\n\n    # return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\n    # x \n\n    return {2, 3}.union({3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]})\n\n\n\n\n\nsieve = Eratosthenes(10 ** 5 + 1)\n\nans = [0] * (10 ** 5 + 1)\n\nfor i in range(3, 10 ** 5, 2):\n\n    if i in sieve and (i + 1) // 2 in sieve:\n\n        ans[i] += 1\n\nfor i in range(3, 10 ** 5):\n\n    ans[i + 1] += ans[i]\n\nq = int(eval(input()))\n\nfor i in range(q):\n\n    l, r = list(map(int, input().split()))\n\n    print((ans[r] - ans[l - 1]))\n", "output": "B", "improve_diff": 1.1447827219, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nN, M, L = list(map(int, input().split()))\n\nd = [[10 ** 16 * (i != j) for j in range(N + 1)] for i in range(N + 1)]\n\nfor _ in range(M):\n\n  x, y, c = list(map(int, input().split()))\n\n  d[x][y] = c\n\n  d[y][x] = c\n\nfor k in range(N + 1):\n\n  for i in range(N + 1):\n\n    for j in range(N + 1): d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n\n\ndd = [[(d[i][j] <= L) + (d[i][j] > L) * 10 ** 16 for j in range(N + 1)] for i in range(N + 1)]\n\nfor k in range(N + 1):\n\n  for i in range(N + 1):\n\n    for j in range(N + 1): dd[i][j] = min(dd[i][j], dd[i][k] + dd[k][j])\n\n\n\nfor _ in range(int(eval(input()))):\n\n  s, t = list(map(int, input().split()))\n\n  if dd[s][t] != 10 ** 16: print((dd[s][t] - 1))\n\n  else: print((-1)) \nB. import sys\n\ninput = sys.stdin.buffer.readline\n\nN, M, L = list(map(int, input().split()))\n\nd = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n\nfor _ in range(M):\n\n  u, v, c = list(map(int, input().split()))\n\n  d[u][v] = c\n\n  d[v][u] = c\n\nQ = int(eval(input()))\n\nfor k in range(1, N + 1):\n\n  for i in range(1, N + 1):\n\n    for j in range(1, N + 1):\n\n      if d[i][j] > d[i][k] + d[k][j]:\n\n        d[i][j] = d[i][k] + d[k][j]\n\n\n\nnd = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n\n\n\nfor i in range(1, N + 1):\n\n  for j in range(1, N + 1):\n\n    if d[i][j] <= L:\n\n      nd[i][j] = 1\n\nfor k in range(1, N + 1):\n\n  for i in range(1, N + 1):\n\n    for j in range(1, N + 1):\n\n      if nd[i][j] > nd[i][k] + nd[k][j]:\n\n        nd[i][j] = nd[i][k] + nd[k][j]\n\n\n\nfor _ in range(Q):\n\n  s, t = list(map(int, input().split()))\n\n  if nd[s][t] == float(\"inf\"):\n\n    print((-1))\n\n  else:\n\n    print((nd[s][t] - 1))", "output": "B", "improve_diff": 1.0254303137, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X = int(eval(input()))\n\nans = 1\n\nfor b in range(1, X+1):\n\n    for p in range(2, X+1):\n\n        if b**p > X:\n\n            break\n\n        if b**p > ans and b**p <= X:\n\n            ans = b**p\n\nprint(ans) \nB. X = int(eval(input()))\n\nans = 1\n\nt = min(X, 100)\n\nfor b in range(1, t):\n\n    for p in range(1, t):\n\n        if b**p > ans and b**p <= X:\n\n            ans = b**p\n\nprint(ans)\n", "output": "A", "improve_diff": 1.1289852043, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=int(eval(input()))\n\nK=int(eval(input()))\n\ns=str(N)\n\nN=len(s)\n\n\n\n# dp[i][smaller][k] :=i0k\n\n# smaller1N0N\n\ndp=[[[0]*(K+2) for j in range(2)] for i in range(N+1)]\n\ndp[0][0][0]=1\n\nfor i in range(N):\n\n  for k in range(K+1):\n\n    ni=int(s[i])\n\n    # iNi+1\n\n    dp[i+1][1][k+1]+=dp[i][1][k]*9 # i+10\n\n    dp[i+1][1][k]+=dp[i][1][k]     # i+10\n\n    # iNi+1N\n\n    if ni>0:\n\n      dp[i+1][1][k+1]+=dp[i][0][k]*(ni-1) # i+10\n\n      dp[i+1][1][k]+=dp[i][0][k]          # i+10\n\n    # iNi+1N\n\n    if ni>0:\n\n      dp[i+1][0][k+1]=dp[i][0][k] # i+10\n\n    else:\n\n      dp[i+1][0][k]=dp[i][0][k]   # i+10\n\nprint((dp[N][0][K]+dp[N][1][K]))\n \nB. N=int(eval(input()))\n\nK=int(eval(input()))\n\ns=str(N)\n\nN=len(s)\n\n\n\ndp=[[[0]*2 for j in range(K+1)] for i in range(N+1)]\n\ndp[0][0][0]=1\n\n\n\nfor i in range(N):\n\n    for j in range(K+1):\n\n        for k in range(2):\n\n            cd=int(s[i])\n\n            for nd in range(10):\n\n                ni=i+1\n\n                nj=j\n\n                nk=k\n\n                if nd!=0:nj+=1\n\n                if nj>K:continue\n\n                if k==0:\n\n                    if nd>cd:continue\n\n                    if nd<cd:nk=1\n\n                dp[ni][nj][nk]+=dp[i][j][k]\n\nprint((dp[N][K][0]+dp[N][K][1]))\n", "output": "A", "improve_diff": 1.0591752312, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K = int(eval(input()))\n\nnum = 0\n\nfor i in range(1000001):\n\n    num += 7 * pow(10, i, K)\n\n    num %= K\n\n    if num == 0:\n\n        print((i + 1))\n\n        break\n\nelse:\n\n    print((-1))\n \nB. def solve(K):\n\n    cur = 0\n\n    tens = 1\n\n    for i in range(1_000_001):\n\n        cur += 7 * tens\n\n        cur %= K\n\n        if cur == 0:\n\n            return i + 1\n\n        tens *= 10\n\n        tens %= K\n\n    else:\n\n        return -1\n\n\n\n\n\nprint((solve(int(eval(input())))))\n", "output": "B", "improve_diff": 6.6239415321, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nXL = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nt = [(x + l, x - l) for x, l in XL]\n\nt.sort()\n\nmax_r = -float('inf')\n\nresult = 0\n\nfor i in range(N):\n\n    r, l = t[i]\n\n    if max_r <= l:\n\n        result += 1\n\n        max_r = r\n\nprint(result) \nB. from operator import itemgetter\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    X = []\n\n    for i in range(N):\n\n        xx, ll = list(map(int, input().split()))\n\n        X.append((xx-ll, xx+ll))\n\n    X.sort(key=itemgetter(1))\n\n    count = 0\n\n    cur = -float('inf')\n\n    for i in range(N):\n\n        c, d = X[i]\n\n        if cur <= c:\n\n            count += 1\n\n            cur = d\n\n    return count\n\n\n\nprint((solve()))\n", "output": "A", "improve_diff": 1.3874139035, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput=sys.stdin.readline\n\n\n\n\n\ndef get_candidate(K):\n\n    l = []\n\n    b = 0\n\n    for i in range(30)[::-1]:\n\n        if K&(1<<i):\n\n            l.append(b + (1<<i) - 1)\n\n            b += (1<<i)\n\n    return l+[K]\n\n\n\n\n\ndef get_ans(K, l):\n\n    ans = 0\n\n    for i, j in l:\n\n        if i|K==K:\n\n            ans += j\n\n    return ans\n\n\n\n\n\ndef solve():\n\n    N, K = list(map(int, input().split()))\n\n    l = [tuple(map(int, input().split())) for _ in range(N)]\n\n    ans = 0\n\n    for k in get_candidate(K):\n\n        ans = max(ans, get_ans(k, l))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n \nB. import sys\n\ninput=sys.stdin.readline\n\n\n\n\n\ndef get_candidate(K):\n\n    l = []\n\n    b = 0\n\n    for i in range(30)[::-1]:\n\n        if (K&(1<<i)):\n\n            l.append(b + (1<<i) - 1)\n\n            b += (1<<i)\n\n    return l+[K]\n\n\n\n\n\ndef get_ans(K, l):\n\n    bit = [None]*30\n\n    for i in range(30):\n\n        bit[i] = (K&(1<<i))>>i\n\n\n\n    ans = 0\n\n    for i, j in l:\n\n        for k in range(30):\n\n            b = (i&(1<<k))>>k\n\n            if not ((bit[k]==1) or (b==0 and bit[k]==0)):\n\n                break\n\n        else:\n\n            ans += j\n\n    return ans\n\n\n\n\n\ndef solve():\n\n    N, K = list(map(int, input().split()))\n\n    l = [tuple(map(int, input().split())) for _ in range(N)]\n\n    ans = 0\n\n    for k in get_candidate(K):\n\n        ans = max(ans, get_ans(k, l))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "output": "B", "improve_diff": 1.0616823834, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nN = int(eval(input()))\n\nNL = [str(i) for i in range(1,N+1)]\n\nP = input().replace(' ', '')\n\nQ = input().replace(' ', '')\n\nNLL = sorted(list(itertools.permutations(NL,N)))\n\na = 0\n\nb = 0\n\nfor i in range(len(NLL)):\n\n    if ''.join(list(NLL[i])) == P:\n\n        a = i+1\n\n    if ''.join(list(NLL[i])) == Q:\n\n        b = i+1\n\nprint((abs(a-b))) \nB. import itertools\n\nimport math\n\nN = int(eval(input()))\n\nP = ''.join(input().split())\n\nQ = ''.join(input().split())\n\nnp = sorted(list([''.join(x) for x in itertools.permutations([str(i+1) for i in range(N)])]))\n\nprint((abs((np.index(P)+1)-(np.index(Q)+1))))", "output": "A", "improve_diff": 1.3942011477, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = list(map(int, input().split()))\n\nprint((N*M)) \nB. a,b = list(map(float,input().split()))\n\na = int(a)\n\nb = int(b*1000)\n\nprint((int(a*b)//1000))", "output": "B", "improve_diff": 1.0120727931, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # https://atcoder.jp/contests/abc106/tasks/abc106_d\n\n# [p,q]\uff1f\n\n# p,q11\n\n# p,qxy[p,q]\n\n# query\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\nimport numpy as np\n\n\n\nN, M, Q = read_ints()\n\nLR = read_tuple(M)\n\npq = read_tuple(Q)\n\n\n\n# numpy #python\n\nLR2d = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor L, R in LR:\n\n    LR2d[L][R] += 1\n\nLR2d = np.array(LR2d, np.int64)\n\n\n\nLR2d_accum = np.zeros((N + 2, N + 2), np.int64)\n\nLR2d_accum[1:, 1:] = LR2d.cumsum(axis=0).cumsum(axis=1)  # 1\n\n# i,ji,j\n\n\n\n# query\n\nfor p, q in pq:\n\n    print((LR2d_accum[q + 1, q + 1] - LR2d_accum[q + 1, p] -\n\n          LR2d_accum[p, q + 1] + LR2d_accum[p, p]))\n \nB. # https://atcoder.jp/contests/abc106/tasks/abc106_d\n\n# [p,q]\uff1f\n\n# p,q11\n\n# p,qxy[p,q]\n\n# query\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\nimport numpy as np\n\n\n\nN, M, Q = read_ints()\n\nLR = read_tuple(M)\n\npq = read_tuple(Q)\n\n\n\n# numpy #python\n\nLR2d = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor L, R in LR:\n\n    LR2d[L][R] += 1\n\nLR2d = np.array(LR2d, np.int64)\n\n\n\nLR2d_accum = np.zeros((N + 2, N + 2), np.int64)\n\nLR2d_accum[1:, 1:] = LR2d.cumsum(axis=0).cumsum(axis=1)  # 1\n\n# i,ji,j\n\n\n\n# query\n\nans = []\n\nfor p, q in pq:\n\n    ans.append(LR2d_accum[q + 1, q + 1] - LR2d_accum[q + 1, p] -\n\n               LR2d_accum[p, q + 1] + LR2d_accum[p, p])\n\n\n\nprint(*ans, sep='\\n')\n", "output": "A", "improve_diff": 1.0168600886, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) // math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n\n\n    ret = 0\n\n    for a in range(1, N):\n\n        b = N // a\n\n        if N - (a * b) <= 0:\n\n            ret += b - 1\n\n        else:\n\n            ret += b\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nimport os\n\nimport math\n\nimport bisect\n\nimport itertools\n\nimport collections\n\nimport heapq\n\nimport queue\n\nimport array\n\n\n\n# \n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\n# \n\nsys.setrecursionlimit(10000000)\n\n\n\n\n\ndef ii(): return int(sys.stdin.buffer.readline().rstrip())\n\ndef il(): return list(map(int, sys.stdin.buffer.readline().split()))\n\ndef fl(): return list(map(float, sys.stdin.buffer.readline().split()))\n\ndef iln(n): return [int(sys.stdin.buffer.readline().rstrip())\n\n                    for _ in range(n)]\n\n\n\n\n\ndef iss(): return sys.stdin.buffer.readline().decode().rstrip()\n\ndef sl(): return list(map(str, sys.stdin.buffer.readline().decode().split()))\n\ndef isn(n): return [sys.stdin.buffer.readline().decode().rstrip()\n\n                    for _ in range(n)]\n\n\n\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n\n\n    ret = 0\n\n    for i in range(1, N):\n\n        ret += (N - 1) // i\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.2629418541, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A = int(eval(input())) #500\n\nB = int(eval(input())) #100\n\nC = int(eval(input())) #50\n\nX = int(eval(input())) #sum\n\ncount = 0\n\n\n\nfor a in range(A + 1):\n\n    for b in range(B + 1):\n\n        for c in range(C + 1):\n\n            if 500 * a + 100 * b + 50 * c == X:\n\n                count += 1\n\n\n\nprint(count)\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\nA = int(eval(input())) #500\n\nB = int(eval(input())) #100\n\nC = int(eval(input())) #50\n\nX = int(eval(input())) #sum\n\ncount = 0\n\n\n\nfor a in range(A + 1):\n\n    for b in range(B + 1):\n\n        if 500 * a + 100 * b <= X <= 500 * a + 100 * b + 50 * C:\n\n            count += 1\n\n\n\nprint(count)\n", "output": "B", "improve_diff": 1.1924887631, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, a, b = list(map(int, input().split()))\n\nprint(('Alice' if (b - a) % 2 == 0 else 'Borys')) \nB. n, a, b = list(map(int, input().split()))\n\nif (b - a) % 2 == 0:\n\n    print('Alice')\n\nelse:\n\n    print('Borys')\n", "output": "B", "improve_diff": 1.0287143909, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import cmath\n\npi = cmath.pi\n\nexp = cmath.exp\n\n\n\nN=2**18\n\n\n\ndef make_exp_t(N, base):\n\n    exp_t = {0: 1}\n\n    temp = N\n\n    while temp:\n\n        exp_t[temp] = exp(base / temp)\n\n        temp >>= 1\n\n    return exp_t\n\n\n\nfft_exp_t = make_exp_t(N, -2j*pi)\n\nifft_exp_t = make_exp_t(N, 2j*pi)\n\n\n\ndef fft_dfs(f, s, N, st, exp_t):\n\n    if N==2:\n\n        a = f[s]; b = f[s+st]\n\n        return [a+b, a-b]\n\n    N2 = N//2; st2 = st*2\n\n    F0 = fft_dfs(f, s   , N2, st2, exp_t)\n\n    F1 = fft_dfs(f, s+st, N2, st2, exp_t)\n\n    w = exp_t[N]; wk = 1.0\n\n    for k in range(N2):\n\n        U = F0[k]; V = wk * F1[k]\n\n        F0[k] = U + V\n\n        F1[k] = U - V\n\n        wk *= w\n\n    F0.extend(F1)\n\n    return F0\n\n\n\ndef fft(f, N):\n\n    if N==1:\n\n        return f\n\n    return fft_dfs(f, 0, N, 1, fft_exp_t)\n\n\n\ndef ifft(F, N):\n\n    if N==1:\n\n        return F\n\n    f = fft_dfs(F, 0, N, 1, ifft_exp_t)\n\n    for i in range(N):\n\n        f[i] /= N\n\n    return f\n\n\n\nn,m,*a=list(map(int,open(0).read().split()))\n\nb=[0]*N\n\nfor i in a:b[i]+=1\n\ni=N\n\nc=0\n\nfor a in ifft([t*t for t in fft(b,N)],N)[::-1]:\n\n  a=int(a.real+.5)\n\n  i-=1\n\n  if a:\n\n    t=min(m,a)\n\n    c+=i*t\n\n    m-=t\n\n    if not m:break\n\nprint(c) \nB. from scipy.signal import*\n\nn,m,*a=list(map(int,open(0).read().split()))\n\nb=[0]*2**17\n\nfor i in a:b[i]+=1\n\ni=2**18-1\n\nc=0\n\nfor a in(fftconvolve(b,b)+.5).astype(int)[::-1]:\n\n  i-=1\n\n  if a:\n\n    t=min(m,a)\n\n    c+=i*t\n\n    m-=t\n\n    if not m:break\n\nprint(c)", "output": "B", "improve_diff": 1.7477509748, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. M=10**9+7\n\nn,k=list(map(int,input().split()))\n\na=0\n\nfor i in range(k,n+2):\n\n    l=i*~-i//2\n\n    r=n*-~n//2-(n-i)*(n-i+1)//2\n\n    a=(a+r+1-l)%M\n\nprint(a) \nB. n,k=list(map(int,input().split()))\n\nprint((sum(-~i+i*(n-i)for i in range(k,n+2))%(10**9+7)))", "output": "B", "improve_diff": 2.0081855491, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\ngrid = [list(map(int, input().split())), list(map(int, input().split()))]\n\ndist = [[0 for _ in range(n)] for _ in range(2)]\n\ndist[0][0] = grid[0][0]\n\nfor i in range(2):\n\n  for j in range(n):\n\n    if j < n - 1:\n\n      dist[i][j + 1] = max(dist[i][j + 1], dist[i][j] + grid[i][j + 1])\n\n    if i == 0:\n\n      dist[1][j] = max(dist[1][j], dist[0][j] + grid[1][j])\n\nprint((dist[-1][-1])) \nB. from heapq import heappop, heappush\n\nn = int(eval(input()))\n\ngrid = [list(map(int, input().split())), list(map(int, input().split()))]\n\n\n\n\n\ndef biggest(grid, start, cost=0):\n\n    dist = [[0 for _ in range(n)] for _ in range(2)]\n\n    dx = [1, 0]\n\n    dy = [0, 1]\n\n    st = [(cost, start)]\n\n    dist[start[0]][start[1]] = grid[start[0]][start[1]] + cost\n\n    while(st):\n\n        c, [sx, sy] = heappop(st)\n\n        for a, b in zip(dx, dy):\n\n            x = sx + a\n\n            y = sy + b\n\n            if x >= 2 or y >= n:\n\n              continue\n\n            dxy = dist[sx][sy] + grid[x][y]\n\n            if dist[x][y] >= dxy:\n\n                continue\n\n            dist[x][y] = dxy\n\n            heappush(st, (dist[x][y], [x, y]))\n\n    return dist[-1][-1]\n\n\n\n\n\ndist = biggest(grid, [0, 0], cost=0)\n\nprint(dist)", "output": "A", "improve_diff": 1.4512010442, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nX, Y= [0]*n,[0]*n\n\n\n\nfor i in range(n):\n\n    x,y = list(map(int,input().split()))\n\n    X[i]=x\n\n    Y[i]=y\n\n    \n\n\n\ndef kaijo(x):\n\n    if x==1:\n\n        return 1\n\n    else:\n\n        return x*kaijo(x-1)\n\n\n\ndis = 0.0\n\nfor i in range(n):\n\n    for j in range(n):\n\n        dis += (((X[i]-X[j])**2+(Y[i]-Y[j])**2)**0.5)*kaijo(n-1)\n\n\n\n\n\nprint((dis/kaijo(n))) \nB. import numpy as np\n\nn = int(eval(input()))\n\ntowns = []\n\nfor _ in range(n):\n\n    x,y = list(map(int,input().split()))\n\n    towns.append((x,y))\n\ndist = []\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        x1,y1 = towns[i]\n\n        x2,y2 = towns[j]\n\n        dist.append(np.sqrt((x1-x2)**2+(y1-y2)**2))\n\nprint(((sum(dist)/len(dist)) * (n-1)))", "output": "A", "improve_diff": 11.1430089134, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\n\n\ndef rec(x, n):\n\n    # print(pos)\n\n    if pos[x] is None:\n\n        pos[x] = n\n\n    else:\n\n        if pos[x] == n:\n\n            return True\n\n        else:\n\n            # print(pos[x], n)\n\n            return False\n\n\n\n    for nx, d in g[x]:\n\n        if not rec(nx, n + d):\n\n            return False\n\n    else:\n\n        return True\n\n\n\nINF = 1 << 30\n\n\n\nN, M = list(map(int, input().split()))\n\ng = [[] for _ in range(N)]\n\nfor _ in range(M):\n\n    L, R, D = list(map(int, input().split()))\n\n    L -= 1\n\n    R -= 1\n\n    g[L].append((R, D))\n\n    g[R].append((L, -D))\n\n\n\npos = [None for _ in range(N)]\n\n\n\nfor v in range(N):\n\n    # print(pos)\n\n    if pos[v] is None:\n\n        if not rec(v, 0):\n\n            print('No')\n\n            break\n\nelse:\n\n    print('Yes')\n \nB. def main():\n\n    from collections import deque\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    g = tuple(set() for _ in range(N))\n\n    h = [0] * N  # \n\n    for _ in range(M):\n\n        L, R, D = list(map(int, input().split()))\n\n        L -= 1\n\n        R -= 1\n\n        g[L].add((R, D))\n\n        h[R] += 1\n\n\n\n    dist = [-1] * N\n\n\n\n    def dfs(s):\n\n        dist[s] = 0\n\n        dq = deque([s])\n\n        while dq:\n\n            v = dq.popleft()\n\n            for u, d in g[v]:\n\n                if ~dist[u]:\n\n                    if dist[u] != dist[v] + d:\n\n                        return False\n\n                else:\n\n                    dist[u] = dist[v] + d\n\n                    dq.append(u)\n\n        return True\n\n\n\n    # \n\n    for s in range(N):\n\n        if h[s]: continue  # ss\n\n        if ~dist[s]: continue\n\n        if not dfs(s):\n\n            print('No')\n\n            return\n\n\n\n    # \uff08\uff09\n\n    for s in range(N):\n\n        if ~dist[s]: continue\n\n        if not dfs(s):\n\n            print('No')\n\n            return\n\n\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.5721596581, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X = int(eval(input()))\n\n\n\ni, x = 1, 0\n\nwhile x < X:\n\n    x += i\n\n    i += 1\n\nprint((i - 1)) \nB. import math\n\nX = int(eval(input()))\n\nprint((math.ceil((-1 + (1 + 8 * X) ** 0.5) / 2)))", "output": "A", "improve_diff": 1.3698305572, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import exit, stdin\n\n\n\ninput = stdin.readline\n\nimport copy\n\n\n\n# from collections import deque,Counter\n\n# import numpy as np\n\n\n\n(N,) = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nans = (pow(10, N, mod) + pow(8, N, mod) - 2 * pow(9, N, mod)) % mod\n\n\n\nprint(ans)\n \nB. from sys import exit, stdin\n\n\n\ninput = stdin.readline\n\nimport copy\n\n\n\n# from collections import deque,Counter\n\n# import numpy as np\n\n\n\n\n\ndef pow_mod(a, n, d):\n\n    tmp = 1\n\n    for _ in range(n):\n\n        tmp = (tmp * a) % d\n\n    return tmp\n\n\n\n\n\n(N,) = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nans = (pow_mod(10, N, mod) + pow_mod(8, N, mod) - 2 * pow_mod(9, N, mod)) % mod\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 3.7099390775, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n    k = int(eval(input()))\n\n    res = 0\n\n    memo = np.zeros((k+1, k+1), int)\n\n    for i in range(1, k+1):\n\n        for j in range(i, k+1):\n\n            tmp = np.gcd(i,j)\n\n            memo[i][j] = tmp\n\n            memo[j][i] = tmp\n\n\n\n    for i in range(1, k+1):\n\n        res += i \n\n\n\n    for c in combinations(list(range(1,k+1)),2):\n\n        ab = memo[c[0], c[1]]\n\n        res += ab * 6\n\n\n\n    for c in combinations(list(range(1,k+1)), 3):\n\n        ab = memo[c[0], c[1]]\n\n        abc = memo[ab, c[2]]\n\n        res += abc * 6\n\n    print(res)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n \nB. import math\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n    k = int(eval(input()))\n\n    res = 0\n\n    memo = [[0 for _ in range(k+1)] for _ in range(k+1)]\n\n    for i in range(1, k+1):\n\n        for j in range(i, k+1):\n\n            tmp = math.gcd(i,j)\n\n            memo[i][j] = tmp\n\n            memo[j][i] = tmp\n\n\n\n    for i in range(1, k+1):\n\n        res += i \n\n\n\n    for c in combinations(list(range(1,k+1)),2):\n\n        ab = memo[c[0]][c[1]]\n\n        res += ab * 6\n\n\n\n    for c in combinations(list(range(1,k+1)), 3):\n\n        ab = memo[c[0]][c[1]]\n\n        abc = memo[ab][c[2]]\n\n        res += abc * 6\n\n    print(res)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "output": "B", "improve_diff": 7.8715125001, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef gcd(a, b):\n\n  while b:\n\n    a, b = b, a % b\n\n  return a\n\n\n\nMOD = 10**9+7\n\nN = int(eval(input()))\n\nF = []\n\nzero_v = 0\n\ninf = 0\n\nzero = 0\n\nfor _ in range(N):\n\n  x,y = list(map(int,input().split()))\n\n  if x==0 and y==0:\n\n    zero_v += 1\n\n  elif x==0:\n\n    inf += 1\n\n  elif y==0:\n\n    zero += 1\n\n  else:\n\n    G = gcd(abs(x),abs(y))\n\n    F.append((x//G,y//G))\n\n\n\nall_keys = set()\n\n\n\nfor x,y in F:\n\n  if x*y >0:\n\n    if x>0:\n\n      all_keys.add((x,y))\n\n    else:\n\n      all_keys.add((-x,-y))\n\n  x,y = -y,x\n\n  if x*y >0:\n\n    if x>0:\n\n      all_keys.add((x,y))\n\n    else:\n\n      all_keys.add((-x,-y))\n\n\n\nall_dic = {k:[0,0] for k in all_keys}\n\n\n\nfor x,y in F:\n\n  if x*y > 0:\n\n    if x>0:\n\n      all_dic[(x,y)][0] += 1\n\n    else:\n\n      all_dic[(-x,-y)][0] += 1\n\n  else:\n\n    if x>0:\n\n      all_dic[(-y,x)][1] += 1\n\n    else:\n\n      all_dic[(y,-x)][1] += 1\n\n\n\nans = (pow(2,inf,MOD)) + (pow(2,zero,MOD))-1\n\nans %= MOD\n\n\n\nfor k in all_keys:\n\n  P,N = all_dic[k]\n\n  ans *= (pow(2,P,MOD)) + (pow(2,N,MOD))-1\n\n  ans %= MOD\n\n\n\n\n\nans += zero_v-1\n\n\n\nprint((ans%MOD))\n \nB. import sys\n\ninput = sys.stdin.readline\n\nimport math\n\n\n\nMOD = 10**9+7\n\nN = int(eval(input()))\n\nF = []\n\nzero_v = 0\n\ninf = 0\n\nzero = 0\n\nfor _ in range(N):\n\n  x,y = list(map(int,input().split()))\n\n  if x==0 and y==0:\n\n    zero_v += 1\n\n  elif x==0:\n\n    inf += 1\n\n  elif y==0:\n\n    zero += 1\n\n  else:\n\n    G = math.gcd(abs(x),abs(y))\n\n    F.append((x//G,y//G))\n\n\n\nall_keys = set()\n\n\n\nfor x,y in F:\n\n  if x*y >0:\n\n    if x>0:\n\n      all_keys.add((x,y))\n\n    else:\n\n      all_keys.add((-x,-y))\n\n  x,y = -y,x\n\n  if x*y >0:\n\n    if x>0:\n\n      all_keys.add((x,y))\n\n    else:\n\n      all_keys.add((-x,-y))\n\n\n\nall_dic = {k:[0,0] for k in all_keys}\n\n\n\nfor x,y in F:\n\n  if x*y > 0:\n\n    if x>0:\n\n      all_dic[(x,y)][0] += 1\n\n    else:\n\n      all_dic[(-x,-y)][0] += 1\n\n  else:\n\n    if x>0:\n\n      all_dic[(-y,x)][1] += 1\n\n    else:\n\n      all_dic[(y,-x)][1] += 1\n\n\n\nans = (pow(2,inf,MOD)) + (pow(2,zero,MOD))-1\n\nans %= MOD\n\n\n\nfor k in all_keys:\n\n  P,N = all_dic[k]\n\n  ans *= (pow(2,P,MOD)) + (pow(2,N,MOD))-1\n\n  ans %= MOD\n\n\n\n\n\nans += zero_v-1\n\n\n\nprint((ans%MOD))\n", "output": "A", "improve_diff": 1.3610935681, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. icase=0\n\nif icase==0:\n\n    n=int(eval(input()))\n\n\n\n    f=[]\n\n    for i in range(n):\n\n        fi=list(map(int,input().split()))\n\n        f.append(fi)\n\n    p=[]\n\n    for i in range(n):\n\n        pi=list(map(int,input().split()))\n\n        p.append(pi)\n\nelif icase==1: \n\n    n=1\n\n    f=[[1, 1, 0, 1, 0, 0, 0, 1, 0, 1]]\n\n    p=[[3, 4, 5, 6, 7, 8, 9, -2, -3, 4, -2]]\n\nelif icase==2: \n\n    n=2\n\n    f=[[1, 1, 1, 1, 1, 0, 0, 0, 0, 0],\n\n       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\n\n    p=[[0, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1],\n\n       [0, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1]]\n\nelif icase==3: \n\n    n=3\n\n    f=[[1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n\n       [0, 1, 0, 1, 1, 1, 1, 0, 1, 0],\n\n       [1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]\n\n    p=[[-8, 6, -2, -8, -8, 4, 8, 7, -6, 2, 2],\n\n       [-9, 2, 0, 1, 7, -5, 0, -2, -6, 5, 5],\n\n       [6, -6, 7, -9, 6, -5, 8, 0, -9, -7, -7]]\n\n    \n\nimport itertools\n\nsumpmax=-10**11\n\nfor i in itertools.product([0,1], repeat=10):\n\n    r=list(i)\n\n    sump=0\n\n    if sum(r)!=0:\n\n        for jj in range(n):\n\n            ci=0\n\n            for j in range(10):\n\n                ci=ci+r[j]*f[jj][j]\n\n            sump=sump+p[jj][ci]\n\n#            print(sump,r)\n\n        sumpmax=max(sump,sumpmax)\n\nprint(sumpmax) \nB. import itertools\n\n\n\nn=int(eval(input()))\n\nf=[[]]*n\n\nfor i in range(n):\n\n    fij=list(map(int,input().split()))\n\n#    f[i].append(fij)\n\n    f[i]=fij\n\np=[[]]*n\n\nfor i in range(n):\n\n    pij=list(map(int,input().split()))\n\n    p[i]=pij\n\n    \n\npmax=-10**11\n\nfor a in itertools.product([0,1], repeat=10):\n\n    if sum(a)==0:\n\n        continue\n\n    psum=0\n\n    for ni in range(n):\n\n        k=0\n\n        for i in range(10):\n\n            if f[ni][i]==1 and a[i]==1:\n\n                k+=1\n\n        psum=psum+p[ni][k] \n\n    pmax=max(pmax,psum)   \n\n\n\nprint(pmax)\n", "output": "B", "improve_diff": 1.0502451557, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\n\n\nN = int(eval(input()))\n\n\n\ndef prime_factorize(n):\n\n  ret = []\n\n  for i in range(2, int(n ** (1 / 2)) + 1):\n\n    if i > n:break\n\n    cnt = 0\n\n    while n % i == 0:\n\n      n //= i\n\n      cnt += 1\n\n    if cnt > 0:  \n\n      ret.append((i, cnt))\n\n  if n != 1:\n\n    ret.append((n, 1))\n\n  return ret\n\n\n\nlis = prime_factorize(N)\n\n\n\nans = 0\n\n\n\nfor v, cnt in lis:\n\n    i = 1\n\n    while cnt >= i:\n\n        cnt -= i\n\n        i += 1   \n\n    ans += i - 1\n\nprint(ans)  \nB. import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import defaultdict\n\n\n\nN = int(eval(input()))\n\n\n\ndef prime_factorize(n):\n\n  ret = []\n\n  for i in range(2, int(n ** (1 / 2)) + 1):\n\n    if i > n:break\n\n    while n % i == 0:\n\n      n //= i\n\n      ret.append(i)\n\n  if n != 1:\n\n    ret.append(n)\n\n  return ret\n\n\n\ndic = defaultdict(int)\n\nlis = prime_factorize(N)\n\nfor num in lis:\n\n    dic[num] += 1\n\n\n\nans = 0\n\n\n\nfor v in list(dic.values()):\n\n    i = 1\n\n    while v >= i:\n\n        v -= i\n\n        i += 1   \n\n    ans += i - 1\n\nprint(ans)", "output": "A", "improve_diff": 1.5685851073, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nfrom itertools import combinations\n\n\n\ndef readlines(n):\n\n    for _ in range(n):\n\n        yield list(map(int,input().split()))\n\n\n\ndef bene(me, f, p):\n\n    a = sum(1 if f[m] == 1 else 0 for m in me)\n\n    return p[a]\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    F = list(readlines(n))\n\n    P = list(readlines(n))\n\n\n\n    for i in range(1, 11):\n\n        for comb in combinations(list(range(10)), i):\n\n            yield sum(bene(comb, f, p) for f, p in zip(F,P))\n\n\n\n    \n\nprint((max(main()))) \nB. import sys\n\ninput = sys.stdin.readline\n\nfrom itertools import combinations\n\n\n\ndef readlines(n):\n\n    for _ in range(n):\n\n        yield list(map(int,input().split()))\n\n\n\ndef bene(me, f, p):\n\n    a = len([0 for m in me if f[m] == 1])\n\n    return p[a]\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    F = list(readlines(n))\n\n    P = list(readlines(n))\n\n\n\n    for i in range(1, 11):\n\n        for comb in combinations(list(range(10)), i):\n\n            yield sum(bene(comb, f, p) for f, p in zip(F,P))\n\n\n\n    \n\nprint((max(main())))", "output": "B", "improve_diff": 1.0440169444, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k, q = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(q)]\n\n\n\nB = [k-q]*n\n\nfor i in range(q):\n\n    B[A[i]-1] += 1\n\n\n\nfor i in range(n):\n\n    if B[i] <= 0:\n\n        print('No')\n\n    else:\n\n        print('Yes')\n \nB. n, k, q = list(map(int, input().split()))\n\nx = [0]*n\n\nfor i in range(q):\n\n  a = int(eval(input()))\n\n  a -= 1\n\n  x[a] += 1\n\n\n\ny = [k]*n\n\nfor i in range(n):\n\n  y[i] -= (q-x[i])\n\n  if y[i] <= 0:\n\n    print('No')\n\n  else:\n\n    print('Yes')\n\n  ", "output": "B", "improve_diff": 1.0158989409, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def check(p):\n\n  _N = N\n\n  while _N%p == 0:\n\n    _N //= p\n\n  return (_N-1)%p == 0\n\n\n\ndef calc_divisors(n):\n\n    m = int(n**0.5)\n\n    left = []\n\n    right = []\n\n    for i in range(1, m+1):\n\n        if n%i == 0:\n\n            left.append(i)\n\n            right.append(n//i)\n\n    if left[-1] == right[-1]:\n\n        right.pop()\n\n    return left + right[::-1]\n\n\n\nN = int(eval(input()))\n\nP0 = calc_divisors(N)[1:] # [:1]1\n\nP1 = calc_divisors(N-1)[1:] # \n\nans = len(P1)\n\nfor p in P0:\n\n  ans += check(p)\n\n\n\nprint(ans) \nB. N = int(eval(input()))\n\n\n\ndef check(p):\n\n  _N = N\n\n  while _N%p == 0:\n\n    _N //= p\n\n  return (_N-1)%p == 0\n\n\n\nn = int(N**0.5) + 1\n\nP0 = set([N])\n\nP1 = set([N-1])\n\nfor i in range(2, n+1):\n\n  if (N-1)%i == 0:\n\n    P1.add(i)\n\n    P1.add((N-1)//i)\n\n  if N%i == 0:\n\n    P0.add(i)\n\n    P0.add(N//i)\n\n\n\nP0.discard(1)\n\nP1.discard(1)\n\nans = len(P1)\n\nfor p in P0:\n\n  ans += check(p)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.3803744524, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. class SegmentTree:\n\n    def __init__(self, a: list, e: 'default' = 0, f: 'function' = max):\n\n        size = len(a)\n\n        n = 1 << (size - 1).bit_length()\n\n        seg = [e] * (n * 2 - 1)\n\n        for i, a_ in enumerate(a, n - 1):\n\n            seg[i] = a_\n\n        for i in range(n - 2, -1, -1):\n\n            seg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2])\n\n        self.size = size\n\n        self.n = n\n\n        self.seg = seg\n\n        self.a = a\n\n        self.e = e\n\n        self.f = f\n\n\n\n    def update(self, k, x):\n\n        n = self.n\n\n        seg = self.seg\n\n        f = self.f\n\n\n\n        k += n - 1\n\n        seg[k] = x\n\n        while k > 0:\n\n            k = (k - 1) // 2\n\n            seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2])\n\n\n\n    def query(self, a, b, k=0, l=0, r=-1):\n\n        if r < 0:\n\n            r = self.n\n\n        if r <= a or b <= l:\n\n            return self.e\n\n        if a <= l and r <= b:\n\n            return self.seg[k]\n\n        m = (l + r) // 2\n\n        vl = self.query(a, b, k * 2 + 1, l, m)\n\n        vr = self.query(a, b, k * 2 + 2, m, r)\n\n        return self.f(vl, vr)\n\n\n\n\n\nn = int(eval(input()))\n\nh = tuple(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\ndp = [0] * (n + 1)\n\n# dp[j] := j\n\n\n\nseg = SegmentTree(a=dp, e=0, f=max)\n\n\n\nfor h_, a_ in zip(h, a):\n\n    # i\n\n    max_ = seg.query(0, h_) + a_\n\n    seg.update(h_, max_)\n\nprint((seg.query(0, n + 1))) \nB. # seg = SegmentTree(init_val=dp, segfunc=max, ide_ele=0)\n\nclass SegmentTree:\n\n    # original: @solzard_\n\n    def __init__(self,\n\n                 init_val: 'initial value: iterable',\n\n                 segfunc: 'operation unique in case',\n\n                 ide_ele: 'identity element corresponding init_val' = 0,\n\n                 ):\n\n        self.segfunc = segfunc\n\n        self.ide_ele = ide_ele\n\n        self.size = 1 << (len(init_val) - 1).bit_length()\n\n        self.tree = self._build(init_val)\n\n\n\n    def _build(self, init_val) -> 'tree':\n\n        segfunc = self.segfunc\n\n\n\n        tree = [self.ide_ele] * (self.size * 2 - 1)\n\n\n\n        for idx, val in enumerate(init_val, self.size - 1):  # set\n\n            # modify val if needed (e.g. str -> ord())\n\n            tree[idx] = val\n\n\n\n        for idx in range(self.size - 2, -1, -1):  # build\n\n            tree[idx] = segfunc(tree[idx * 2 + 1], tree[idx * 2 + 2])\n\n\n\n        return tree\n\n\n\n    def update(self, idx: int, val) -> None:\n\n        tree = self.tree\n\n        segfunc = self.segfunc\n\n\n\n        idx += self.size - 1\n\n        # modify val if needed as same as in _build()\n\n        tree[idx] = val\n\n        while idx > 0:\n\n            idx = (idx - 1) // 2\n\n            tree[idx] = segfunc(tree[idx * 2 + 1], tree[idx * 2 + 2])\n\n\n\n    def query(self, left: int, right: int) -> 'result':\n\n        left += self.size\n\n        right += self.size\n\n        ret = self.ide_ele  # left >= right: return self.ide_ele\n\n        segfunc = self.segfunc\n\n        tree = self.tree\n\n        while left < right:\n\n            if left & 1:  # odd\n\n                ret = segfunc(ret, tree[left - 1])\n\n                left += 1\n\n            if right & 1:  # odd\n\n                right -= 1\n\n                ret = segfunc(ret, tree[right - 1])\n\n            left >>= 1\n\n            right >>= 1\n\n        return ret\n\n\n\n\n\nn = int(eval(input()))\n\nh = tuple(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\ndp = [0] * (n + 1)\n\n# dp[j] := j\n\n\n\nseg = SegmentTree(init_val=dp, segfunc=max, ide_ele=0)\n\n\n\nfor h_, a_ in zip(h, a):\n\n    # i\n\n    max_ = seg.query(0, h_) + a_\n\n    seg.update(h_, max_)\n\nprint((seg.query(0, n + 1)))\n", "output": "B", "improve_diff": 1.0504258091, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = [int(i) for i in input().split()]\n\n\n\ndef prime_decomposition(n):\n\n  table = []\n\n  i = 2\n\n  while i * i <= n:\n\n    count = 0\n\n    while n % i == 0:\n\n      n //= i\n\n      count += 1\n\n    if count != 0:\n\n        table.append((i, count))\n\n    i += 1\n\n  if n > 1:\n\n    table.append((n, 1))\n\n  return table\n\n\n\ndef cmb(n, r):\n\n    N, R = n, r\n\n    for i in range(1, r):\n\n        N *= n - i\n\n        R *= r - i\n\n    return N // R\n\n\n\nmod = 10 ** 9 + 7\n\nA = prime_decomposition(M)\n\nresult = 1\n\nfor _, a in A:\n\n    result = result * cmb(a + N - 1, a) % mod\n\n\n\nprint(result) \nB. N, M = [int(i) for i in input().split()]\n\n\n\ndef prime_decomposition(n):\n\n  i = 2\n\n  table = []\n\n  while i * i <= n:\n\n    while n % i == 0:\n\n      n //= i\n\n      table.append(i)\n\n    i += 1\n\n  if n > 1:\n\n    table.append(n)\n\n  return table\n\n\n\ndef cmb(n, r):\n\n    N, R = n, r\n\n    for i in range(1, r):\n\n        N *= n - i\n\n        R *= r - i\n\n    return N // R\n\n\n\nfrom collections import Counter\n\nA = Counter(prime_decomposition(M))\n\n\n\nmod = 10 ** 9 + 7\n\nresult = 1\n\nfor a in list(A.values()):\n\n    result = result * cmb(a + N - 1, a) % mod\n\n\n\nprint(result)", "output": "A", "improve_diff": 1.6137501444, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import decimal\n\ndef resolve():    \n\n\n\n    a, b = list(map(decimal.Decimal, input().split()))\n\n    print((a * b // 1))\n\n    \n\nif __name__ == \"__main__\":\n\n    resolve() \nB. \n\ndef resolve():\n\n    a, b = input().split()\n\n    a = int(a)\n\n    b = int(float(b) * 100 + .5)\n\n    \n\n    ans = a*b\n\n    print((ans//100))\n\nif __name__ == \"__main__\":\n\n    resolve()", "output": "B", "improve_diff": 1.7247178403, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m, c=list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na = []\n\nfor i in range(n):\n\n    a.append(list(map(int, input().split())))\n\n\n\nab=0\n\nans=0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        ab+=a[i][j]*b[j]\n\n    if ab+c>0:\n\n        ans+=1\n\n        ab = 0\n\n    else:\n\n         ab = 0\n\nprint(ans) \nB. import numpy as np\n\nn,m,c = list(map(int, input().split()))\n\ncond = list(map(int,input().split()))\n\nchar = []\n\nfor i in range(n):\n\n    char.append(list(map(int, input().split())))\n\nnpcond = np.asarray(cond)\n\nnpchar = np.asarray(char)\n\n\n\nnpstat = npchar * npcond\n\nnpstat1 = np.sum(npstat, axis = 1) + c\n\n\n\nprint((np.count_nonzero(npstat1 > 0)))", "output": "A", "improve_diff": 10.9479537937, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    # 1.input\n\n    a,b,c,d = list(map(int, input().split()))\n\n    \n\n    \n\n    #2. judge\n\n    if abs(a-c) <= d:\n\n        print(\"Yes\")\n\n    elif abs(a-b) <= d and abs(b-c) <= d:\n\n        print(\"Yes\")\n\n    else:\n\n        print(\"No\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. a,b,c,d = list(map(int, input().split()))\n\n\n\nif abs(c-a)<=d or (abs(b-a)<=d and abs(c-b)<=d):\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "output": "A", "improve_diff": 1.0198059148, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport collections\n\nfrom collections import defaultdict\n\n\n\nsys.setrecursionlimit(10 ** 8)\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    A = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\n    q = [collections.deque() for j in range(N)]\n\n\n\n    for i, a in enumerate(A):\n\n        for aa in a:\n\n            q[i].append(aa)\n\n\n\n    ans = 0\n\n\n\n    current = defaultdict(int)\n\n    for i, v in enumerate(q):\n\n        current[i + 1] = v[0]\n\n\n\n    while True:\n\n        v = set()\n\n        for k in list(current.keys()):\n\n            if k == q[current[k] - 1][0]:\n\n                v.add(k)\n\n                v.add(current[k])\n\n\n\n        current = defaultdict(int)\n\n\n\n        if len(v) == 0:\n\n            break\n\n\n\n        for vv in v:\n\n            q[vv - 1].popleft()\n\n            if len(q[vv - 1]):\n\n                current[vv] = q[vv - 1][0]\n\n\n\n        ans += 1\n\n\n\n    # \n\n    size = 0\n\n    for i in range(N):\n\n        size += len(q[i])\n\n\n\n    if size == 0:\n\n        print(ans)\n\n    else:\n\n        print((-1))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nimport collections\n\nimport copy\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    A = [collections.deque([int(x) for x in input().split()]) for _ in range(N)]\n\n\n\n    day = 0\n\n    c = 0\n\n    nxt = [x for x in range(N)]\n\n    oppo = [0] * N\n\n\n\n    while c != N * (N - 1):\n\n        day += 1\n\n\n\n        for i in nxt:\n\n            oppo[i] = A[i].popleft() if A[i] else -1\n\n\n\n        tmp = set()\n\n        for i in nxt:\n\n            if i == -1 or i in tmp:\n\n                continue\n\n            if i == oppo[oppo[i] - 1] - 1:\n\n                tmp.add(i)\n\n                tmp.add(oppo[i] - 1)\n\n                c += 2\n\n        if not tmp:\n\n            print((-1))\n\n            return\n\n\n\n        nxt = tmp\n\n\n\n    print(day)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0996882945, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nA = tuple(map(int,input().split()))\n\nif 0 in A:\n\n    print((0))\n\nelse:\n\n    p = 1\n\n    for a in A:\n\n        p *= a\n\n        if p > 10**18:\n\n            p = -1\n\n            break\n\n\n\n    print(p) \nB. N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nif 0 in A:\n\n    print((0))\n\nelse:\n\n    r = 1\n\n    for a in A:\n\n        r *= a\n\n        if r > 10**18:\n\n            r = -1\n\n            break\n\n    print(r)", "output": "B", "improve_diff": 1.037513348, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nN, M, Q = list(map(int, input().split()))\n\n\n\n#input\n\nlst = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor _ in range(M):\n\n    L, R = list(map(int, input().split()))\n\n    lst[R][L] += 1\n\n\n\nlst = np.array(lst)\n\n# print (lst)\n\n\n\n#2\n\nfor i in range(1, N + 1):\n\n    lst[:,i] += lst[:, i - 1]\n\nfor j in range(1, N + 1):\n\n    lst[j,:] += lst[j - 1, :]\n\n\n\n\n\n#output\n\nfor _ in range(Q):\n\n    p, q = list(map(int, input().split()))\n\n    print((lst[q, q] - lst[p-1, q] - lst[q, p-1] + lst[p-1, p-1]))\n\n\n\n# print (lst)\n \nB. n,m,q=list(map(int,input().split()))\n\natlas=[[0]*(n+1) for _ in range(n+1)]\n\nfor _ in range(m):\n\n    l,r=list(map(int,input().split()))\n\n    atlas[l][r] +=1\n\nfor i in range(n+1):\n\n    for j in range(1,n+1):\n\n        atlas[i][j] +=atlas[i][j-1]\n\n\n\nfor i in range(n+1):\n\n    for j in range(1,n+1):\n\n        atlas[i][j] +=atlas[i-1][j]\n\n\n\nfor p,q in [list(map(int,input().split())) for _ in range(q)]:\n\n    print((atlas[q][q]-atlas[q][p-1]-atlas[p-1][q]+atlas[p-1][p-1]))", "output": "B", "improve_diff": 13.1524081545, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(input())\n\nX = []\n\nfor i, x in enumerate(map(int, input().split())):\n\n    X.append((x, i))\n\n\n\nX.sort()\n\nY = [0] * N\n\nfor j, (x, i) in enumerate(X):\n\n    Y[i] = j\n\n\n\nmid = N / 2\n\nl = X[N // 2 - 1][0]\n\nr = X[N // 2][0]\n\nans = []\n\nfor j in Y:\n\n    if j < mid:\n\n        ans.append(r)\n\n    else:\n\n        ans.append(l)\n\n\n\nprint(*ans, sep='\\n')\n \nB. N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\norder = {}\n\nfor idx, x in enumerate(X):\n\n    order[idx] = x\n\n\n\nX.sort()\n\nm = N // 2\n\nl = X[m - 1]\n\nr = X[m]\n\n\n\nfor idx in range(N):\n\n    x = order[idx]\n\n    if x <= l:\n\n        print(r)\n\n    else:\n\n        print(l)\n", "output": "A", "improve_diff": 1.0316654017, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def cmb(n, r):\n\n    if n - r < r: r = n - r\n\n    if n <= 0: return 0\n\n    if r == 0: return 1\n\n    if r == 1: return n\n\n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n\n    denominator = [k + 1 for k in range(r)]\n\n\n\n    for p in range(2,r+1):\n\n        pivot = denominator[p - 1]\n\n        if pivot > 1:\n\n            offset = (n - r) % p;\n\n            for k in range(p-1,r,p):\n\n                numerator[k - offset] //= pivot\n\n                denominator[k] //= pivot\n\n\n\n    result = 1\n\n    for k in range(r):\n\n        if numerator[k] > 1:\n\n            result *= int(numerator[k])\n\n\n\n    return result\n\n\n\na = int(eval(input()))\n\n\n\nb = [0 for i in range(15)]\n\nj = 0\n\nc = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]\n\nd = [0 for i in range(101)]\n\np = 0\n\npp = 0\n\ng = 0\n\ngg = 0\n\nggg = 0\n\nco = 0\n\nfor i in range(1,101):\n\n  k = i\n\n  while True:\n\n    if k % c[j] == 0 and k >= c[j]:\n\n      b[j] += 1\n\n      k //= c[j]\n\n    else:\n\n      j += 1\n\n      if j == 15:\n\n        j = 0\n\n        break\n\n  for k in range(15):\n\n    if b[k] >= 74:\n\n      g += 1\n\n    if b[k] >= 24:\n\n      gg += 1\n\n    if b[k] >= 14:\n\n      ggg += 1\n\n    if b[k] >= 4:\n\n      p += 1\n\n    if b[k] >= 2:\n\n      pp += 1\n\n  if i >= 10:\n\n    d[i] = cmb(p, 2)*cmb((pp-2), 1) + cmb(g, 1) + cmb(gg, 1)*cmb((pp-1), 1) + cmb(ggg, 1)*cmb((p-1), 1)\n\n  p = 0\n\n  pp = 0\n\n  g = 0\n\n  gg = 0\n\n  ggg = 0\n\nprint((d[a]))\n \nB. from operator import mul\n\nfrom functools import reduce\n\n\n\nnCr = {}\n\ndef cmb(n, r):\n\n    if r == 0 or r == n: return 1\n\n    if r == 1: return n\n\n    if (n,r) in nCr: return nCr[(n,r)]\n\n    nCr[(n,r)] = cmb(n-1,r) + cmb(n-1,r-1)\n\n    return nCr[(n,r)]\n\n\n\n\n\na = int(eval(input()))\n\n\n\nb = [0 for i in range(15)]\n\nj = 0\n\nc = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]\n\nd = [0 for i in range(101)]\n\np = 0\n\npp = 0\n\ng = 0\n\ngg = 0\n\nggg = 0\n\nco = 0\n\nfor i in range(1,101):\n\n  k = i\n\n  while True:\n\n    if k % c[j] == 0 and k >= c[j]:\n\n      b[j] += 1\n\n      k //= c[j]\n\n    else:\n\n      j += 1\n\n      if j == 15:\n\n        j = 0\n\n        break\n\n  for k in range(15):\n\n    if b[k] >= 74:\n\n      g += 1\n\n    if b[k] >= 24:\n\n      gg += 1\n\n    if b[k] >= 14:\n\n      ggg += 1\n\n    if b[k] >= 4:\n\n      p += 1\n\n    if b[k] >= 2:\n\n      pp += 1\n\n  if i >= 10:\n\n    d[i] = cmb(p, 2)*cmb((pp-2), 1) + cmb(g, 1) + cmb(gg, 1)*cmb((pp-1), 1) + cmb(ggg, 1)*cmb((p-1), 1)\n\n  p = 0\n\n  pp = 0\n\n  g = 0\n\n  gg = 0\n\n  ggg = 0\n\nprint((d[a]))", "output": "A", "improve_diff": 1.5740157187, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\nimport sys\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\ng = [[] for _ in range(n)]\n\nindeg = [0 for _ in range(n)]\n\n\n\nfor _ in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    g[x-1].append(y-1)\n\n    indeg[y-1] += 1\n\n\n\ndp = [0 for _ in range(n)]\n\nq = deque([])\n\n\n\nfor i in range(n):\n\n    if indeg[i] == 0:\n\n        q.append(i)\n\n\n\nwhile q:\n\n    v = q.popleft()\n\n    for w in g[v]:\n\n        indeg[w] -= 1\n\n        if indeg[w] == 0:\n\n            q.append(w)\n\n            dp[w] = max(dp[w], dp[v]+1)\n\n\n\nprint((max(dp)))\n \nB. import sys\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\ng = [[] for _ in range(n)]\n\nindeg = [0 for _ in range(n)]\n\n\n\nfor _ in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    g[x-1].append(y-1)\n\n    indeg[y-1] += 1\n\n\n\ndp = [-1 for _ in range(n)]\n\n\n\n\n\ndef LP(v):\n\n    if dp[v] != -1:\n\n        return dp[v]\n\n    ans = 0\n\n    for w in g[v]:\n\n        ans = max(ans, LP(w)+1)\n\n    dp[v] = ans\n\n    return dp[v]\n\n\n\n\n\nfor i in range(n):\n\n    LP(i)\n\n\n\nprint((max(dp)))\n", "output": "B", "improve_diff": 1.4163938233, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,X,Y=list(map(int,input().split()))\n\nA=[0 for i in range(N)]\n\nfor i in range(1,N):\n\n    for j in range(i+1,N+1):\n\n        A[int(min(j-i,abs(X-i)+abs(Y-j)+1))]+=1  \n\ndel A[0]\n\nprint(*A,sep=('\\n'))\n \nB. N,X,Y=list(map(int,input().split()))\n\nA=[[] for i in range(N+1)]\n\nfor i in range(1,N):\n\n    for j in range(i,N+1):\n\n        A[int(min(j-i,abs(X-i)+abs(Y-j)+1))].append(1)\n\n        \n\nfor i in range(N):\n\n    if i!=0:\n\n        print((sum(A[i])))", "output": "A", "improve_diff": 1.233754089, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nl = []\n\nfor i in range(n):\n\n  if (i+1)%3 != 0 and (i+1)%5 != 0:\n\n    l.append(i+1)\n\n  else:\n\n    l.append(0)\n\nprint((sum(l))) \nB. n = int(eval(input()))\n\nans = 0\n\nfor i in range(n+1):\n\n  if i%3 == 0 or i%5 == 0:\n\n    ans += 0\n\n  else:\n\n    ans += i\n\nprint(ans)", "output": "B", "improve_diff": 1.1479499875, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n\tn,k=list(map(int,input().split()))\n\n\ta=[0]+list(map(int,input().split()))\n\n\tp=[]\n\n\tfor i in range(n):\n\n\t\ta[i+1]+=a[i]\n\n\tfor i in range(n+1):\n\n\t\tfor j in range(i):\n\n\t\t\tp.append(a[i]-a[j])\n\n\tp.sort()\n\n\tans=0\n\n\tfrom math import log,ceil\n\n\tr=ceil(log(sum(p))+10**-3)\n\n\tfor i in range(r+2,-1,-1):\n\n\t\tcnt=0\n\n\t\tfor j in range(len(p)):\n\n\t\t\tif (ans+2**i)&p[j]==ans+2**i:\n\n\t\t\t\tcnt+=1\n\n\t\t\t\tif cnt==k:\n\n\t\t\t\t\tbreak\n\n\t\tif cnt==k:\n\n\t\t\tans+=2**i\n\n\tprint(ans)\n\nif __name__ == '__main__':\n\n\tmain() \nB. n,k=list(map(int,input().split()))\n\na=[0]+list(map(int,input().split()))\n\np=[]\n\nfor i in range(n):\n\n\ta[i+1]+=a[i]\n\nfor i in range(n+1):\n\n\tfor j in range(i):\n\n\t\tp.append(a[i]-a[j])\n\np.sort(reverse=True)\n\nans=0\n\nfrom math import log,ceil\n\nr=ceil(log(sum(p))+10**-3)\n\nfor i in range(r+3,-1,-1):\n\n\tcnt=0\n\n\tfor j in range(len(p)):\n\n\t\tif (ans+2**i)&p[j]==ans+2**i:\n\n\t\t\tcnt+=1\n\n\t\tif cnt==k:\n\n\t\t\tbreak\n\n\tif cnt==k:\n\n\t\tans+=2**i\n\nprint(ans)", "output": "A", "improve_diff": 1.0146867137, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import combinations\n\n\n\nN, X, Y = list(map(int, input().split()))\n\n\n\nA = [0] * N\n\nfor i, j in combinations(list(range(1, N + 1)), 2):\n\n    A[min(abs(i - j), abs(X - i) + abs(Y - j) + 1, abs(X - j) + abs(Y - i) + 1)] += 1\n\n\n\nfor a in A[1:]:\n\n    print(a) \nB. from itertools import combinations\n\nfrom collections import Counter\n\n\n\nN, X, Y = list(map(int, input().split()))\n\n\n\nC = Counter(min(abs(i - j), abs(X - i) + abs(Y - j) + 1, abs(X - j) + abs(Y - i) + 1) for i, j in combinations(list(range(1, N + 1)), 2))\n\n\n\nprint((\"\\n\".join(str(C[k]) for k in range(1, N))))", "output": "A", "improve_diff": 1.4604004923, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nmod = 10**9+7 #\n\nN = 10**6 + 10\n\ng1 = [1, 1] # \n\ng2 = [1, 1] #\n\ninverse = [0, 1] #\n\n\n\nfor i in range( 2, N + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nx, y = list(map(int, input().split()))\n\n\n\nn = (2 * x - y) / 3\n\nm = (2 * y - x) / 3\n\nmod = 10 ** 9 + 7\n\n\n\nif int(n) == n and int(m) == m:\n\n    n = int(n)\n\n    m = int(m)\n\n    ans = cmb(n + m, n, mod)\n\n    ans %= mod\n\n    print(ans)\n\n\n\nelse:\n\n    print((0))\n \nB. x, y = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\ncnt1 = cnt2 = 0\n\nfor i in range(x + 1):\n\n    x_left = x - i\n\n    y_left = y - 2 * i\n\n    if x_left == y_left * 2:\n\n        cnt1 = i\n\n        cnt2 = y_left\n\n\n\nif cnt1 == cnt2 == 0:\n\n    ans = 0\n\nelse:\n\n    ans = 1\n\n    for i in range(1, cnt1 + 1):\n\n        ans *= (cnt1 + cnt2 - i + 1)\n\n        ans %= mod\n\n        ans *= pow(i, mod - 2, mod)\n\n        ans %= mod\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 3.2603688168, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(10**8)\n\ndef ii(): return int(sys.stdin.readline())\n\ndef mi(): return list(map(int, sys.stdin.readline().split()))\n\ndef li(): return list(map(int, sys.stdin.readline().split()))\n\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n\n#import bisect #bisect.bisect_left(B, a)\n\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n\n#from collections import Counter # a = Counter(A).most_common()\n\nfrom itertools import accumulate #list(accumulate(A))\n\n\n\n\n\ndef segfunc(a,b):\n\n    return a+b\n\n\n\ndef init(init_val):\n\n    #set_val\n\n    for i in range(n):\n\n        seg[i+num-1]=init_val[i]    \n\n    #built\n\n    for i in range(num-2,-1,-1) :\n\n        seg[i]=segfunc(seg[2*i+1],seg[2*i+2]) \n\n    \n\ndef update(k,x):\n\n    k += num-1\n\n    seg[k] = x\n\n    while k:\n\n        k = (k-1)//2\n\n        seg[k] = segfunc(seg[k*2+1],seg[k*2+2])\n\n    \n\ndef query(p,q):\n\n    if q<=p:\n\n        return ide_ele\n\n    p += num-1\n\n    q += num-2\n\n    res=ide_ele\n\n    while q-p>1:\n\n        if p&1 == 0:\n\n            res = segfunc(res,seg[p])\n\n        if q&1 == 1:\n\n            res = segfunc(res,seg[q])\n\n            q -= 1\n\n        p = p//2\n\n        q = (q-1)//2\n\n    if p == q:\n\n        res = segfunc(res,seg[p])\n\n    else:\n\n        res = segfunc(segfunc(res,seg[p]),seg[q])\n\n    return res\n\n\n\n\n\nn, M, Q = mi()\n\n\n\n###########\n\nide_ele = 0\n\n#num:n2\n\nnum =2**(n-1).bit_length()\n\nseg=[ide_ele]*2*num\n\n\n\nL = [0]*n\n\ninit(L)\n\n\n\nlrpq = dp2(0, 3, M+Q)\n\n\n\nfor i in range(M):\n\n    l, r = mi()\n\n    lrpq[i][1] = l-1\n\n    lrpq[i][2] = r-1\n\n\n\nfor i in range(M, M+Q):\n\n    p, q = mi()\n\n    lrpq[i][0] = i\n\n    lrpq[i][1] = p-1\n\n    lrpq[i][2] = q-1\n\n\n\nlrpq = sorted(lrpq, key=lambda x:(x[2], x[0]))\n\n\n\nans = [0]*(Q)\n\n\n\nfor i in range(M+Q):\n\n    if lrpq[i][0] == 0:\n\n        #L[lrpq[i][1]] += 1\n\n        update(lrpq[i][1], seg[lrpq[i][1]+num-1]+1)\n\n    else:\n\n        ans[lrpq[i][0]-M] = query(lrpq[i][1] \nB. import sys\n\nsys.setrecursionlimit(10**8)\n\ndef ii(): return int(sys.stdin.readline())\n\ndef mi(): return list(map(int, sys.stdin.readline().split()))\n\ndef li(): return list(map(int, sys.stdin.readline().split()))\n\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n\n#import bisect #bisect.bisect_left(B, a)\n\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n\n#from collections import Counter # a = Counter(A).most_common()\n\nfrom itertools import accumulate #list(accumulate(A))\n\n\n\n# \n\n\n\ndef segfunc(a,b):\n\n    return a+b\n\n\n\ndef init(init_val):\n\n    #set_val\n\n    for i in range(n):\n\n        seg[i+num-1]=init_val[i]    \n\n    #built\n\n    for i in range(num-2,-1,-1) :\n\n        seg[i]=segfunc(seg[2*i+1],seg[2*i+2]) \n\n    \n\ndef update(k,x):\n\n    k += num-1\n\n    seg[k] = x\n\n    while k:\n\n        k = (k-1)//2\n\n        seg[k] = segfunc(seg[k*2+1],seg[k*2+2])\n\n    \n\ndef query(p,q):\n\n    if q<=p:\n\n        return ide_ele\n\n    p += num-1\n\n    q += num-2\n\n    res=ide_ele\n\n    while q-p>1:\n\n        if p&1 == 0:\n\n            res = segfunc(res,seg[p])\n\n        if q&1 == 1:\n\n            res = segfunc(res,seg[q])\n\n            q -= 1\n\n        p = p//2\n\n        q = (q-1)//2\n\n    if p == q:\n\n        res = segfunc(res,seg[p])\n\n    else:\n\n        res = segfunc(segfunc(res,seg[p]),seg[q])\n\n    return res\n\n\n\n\n\nn, M, Q = mi()\n\n\n\n###########\n\nide_ele = 0\n\n#num:n2\n\nnum =2**(n-1).bit_length()\n\nseg=[ide_ele]*2*num\n\n\n\nL = [0]*n\n\ninit(L)\n\n\n\nlrpq = dp2(0, 3, M+Q)\n\n\n\nfor i in range(M):\n\n    l, r = mi()\n\n    lrpq[i][1] = l-1\n\n    lrpq[i][2] = r-1\n\n\n\nfor i in range(M, M+Q):\n\n    p, q = mi()\n\n    lrpq[i][0] = i\n\n    lrpq[i][1] = p-1\n\n    lrpq[i][2] = q-1\n\n\n\nlrpq = sorted(lrpq, key=lambda x:(x[2], x[0]))\n\n\n\nans = [0]*(Q)\n\n\n\nfor i in range(M+Q):\n\n    if lrpq[i][0] == 0:\n\n        #L[lrpq[i][1]] += 1\n\n        update(lrpq[i][1], seg[lrpq[i][1]+num-1]+1)\n\n    else:\n\n        ans[lrpq[i][0]-M] = query(lrpq[i][1]", "output": "A", "improve_diff": 1.0230193084, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from operator import itemgetter\n\nn=int(eval(input()))\n\nA=[tuple(map(int,input().split())) for i in range(n)]\n\nB=[tuple(map(int,input().split())) for j in range(n)]\n\nA.sort()\n\nB.sort()\n\ncount=0\n\nfor i in range(n):\n\n    box=[A[j] for j in range(len(A)) if (A[j][0]<B[i][0]) and (A[j][1]<B[i][1])]\n\n    if any(box):\n\n        box=sorted(box, key=itemgetter(1))\n\n        A.remove(box[-1])\n\n        count +=1\n\nprint(count) \nB. from operator import itemgetter\n\nN = int(eval(input()))\n\nA = [tuple(map(int,input().split())) for i in range(N)]\n\nB = [tuple(map(int,input().split())) for i in range(N)]\n\nA.sort()\n\nB.sort()\n\nnum = 0\n\nfor i in range(N):\n\n    K = [A[k] for k in range(len(A)) if (A[k][0] <B[i][0]) and (A[k][1] < B[i][1])]\n\n    if K:\n\n        num += 1\n\n        t = sorted(K, key=itemgetter(1))[-1]\n\n        A.remove(t)\n\nprint(num)", "output": "B", "improve_diff": 1.0126257055, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. [n, m, l] = [int(x) for x in input().split()]\n\n\n\nA = []\n\nB = []\n\ncounter = 0\n\nwhile counter < n:\n\n    A.append([int(x) for x in input().split()])\n\n    counter += 1\n\n\n\ncounter = 0\n\nwhile counter < m:\n\n    B.append([int(x) for x in input().split()])\n\n    counter += 1\n\n\n\nB = list(zip(*B))\n\n\n\nfor i in range(n):\n\n    data = []\n\n    for j in range(l):\n\n        data.append(sum([x[0] * x[1] for x in zip(A[i], B[j])]))\n\n    print((' '.join([str(x) for x in data]))) \nB. [n, m, l] = [int(x) for x in input().split()]\n\n\n\nA = []\n\nB = []\n\nC = []\n\ncounter = 0\n\nwhile counter < n:\n\n    A.append([int(x) for x in input().split()])\n\n    counter += 1\n\n\n\ncounter = 0\n\nwhile counter < m:\n\n    B.append([int(x) for x in input().split()])\n\n    counter += 1\n\n\n\ncounter = 0\n\nwhile counter < n:\n\n    C.append([0] * l)\n\n    counter += 1\n\n\n\nfor i in range(n):\n\n    for j in range(l):\n\n        for k in range(m):\n\n            C[i][j] += (A[i][k] * B[k][j])\n\n\n\nfor data in C:\n\n    print((' '.join([str(x) for x in data])))", "output": "A", "improve_diff": 1.0926458918, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X, Y = list(map(int,input().split()))\n\nans = 'No'\n\nif 4*X < Y:\n\n    print(ans)\n\nelse:\n\n    for i in range(1,X+1):\n\n        crane = i\n\n        turtle = X - i\n\n        crane2 = X - i\n\n        turtle2 = i\n\n        if 2*crane + 4*turtle == Y or 2*crane2 + 4*turtle2 == Y:\n\n            ans = 'Yes'\n\n            break\n\n    print(ans) \nB. X, Y = list(map(int,input().split()))\n\nans = 'No'\n\nif 4*X < Y:\n\n    print(ans)\n\nelse:\n\n    for i in range(X+1):\n\n        crane = i\n\n        turtle = X - i\n\n        if 2*crane + 4*turtle == Y:\n\n            ans = 'Yes'\n\n            break\n\n    print(ans)", "output": "B", "improve_diff": 1.1368675137, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k//7 if k % 7 == 0 else k)\n\n    if l % 2 == 0 or l % 5 == 0:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(-pow(l, 1/2))):\n\n        if r % i == 0:\n\n            phi = phi//i*(i-1)\n\n            while r % i:\n\n                r //= i\n\n\n\n    a = 10 % l\n\n    ret = 1\n\n    while(a != 1):\n\n        a = a*10 % l\n\n        ret += 1\n\n        if phi < ret:\n\n            ret = -1\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n \nB. # coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    ret = 1\n\n    a = 7 % k\n\n    while(a):\n\n        a = (a*10+7) % k\n\n        ret += 1\n\n        if k < ret:\n\n            ret = -1\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n", "output": "A", "improve_diff": 1.0742929915, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. class Node:\n\n    def __init__(self, num, parent, *children):\n\n        self.id = num\n\n        self.parent = parent\n\n        self.children = list(children)\n\n        self.depth = 0\n\n        \n\n    def show_info(self):\n\n        print('node {0}: '.format(self.id), end = '')\n\n        print('parent = {0}, '.format(self.parent), end = '')\n\n        print('depth = {0}, '.format(self.depth), end = '')\n\n        if self.children and self.parent != -1:\n\n            print('internal node, ', end = '')\n\n        elif self.parent != -1:\n\n            print('leaf, ', end = '')\n\n        else:\n\n            print('root, ', end = '')\n\n        print(self.children)\n\n\n\n\n\ndef set_node(i_p):\n\n    i_p = list(map(int, i_p.split()))\n\n    num = i_p[0]\n\n    children = i_p[2:]\n\n    if children:\n\n        T[num].children = children\n\n        for n in children:\n\n            T[n].parent = num\n\n\n\ndef find_root(node):\n\n    while node.parent != -1:\n\n        node = T[node.parent]\n\n    return node\n\n\n\ndef set_depth(node, depth):\n\n    node.depth = depth\n\n    for n in node.children:\n\n        set_depth(T[n], depth + 1)\n\n\n\n\n\n\n\nimport sys\n\n\n\nn = int(sys.stdin.readline())\n\n\n\nT = [Node(i, -1) for i in range(n)]\n\n\n\nfor x in sys.stdin.readlines():\n\n    set_node(x)\n\n\n\nr_n = find_root(T[0])\n\n\n\nset_depth(r_n, 0)\n\n\n\nfor n in T:\n\n    n.show_info()\n \nB. \"\"\"Rooted Trees.\"\"\"\n\n\n\nclass Node:\n\n    def __init__(self, num, parent, *children):\n\n        self.id = num\n\n        self.parent = parent\n\n        self.children = list(children)\n\n        self.depth = 0\n\n        \n\n    def show_info(self):\n\n        print('node {0}: '.format(self.id), end = '')\n\n        print('parent = {0}, '.format(self.parent), end = '')\n\n        print('depth = {0}, '.format(self.depth), end = '')\n\n        if self.children and self.parent != -1:\n\n            print('internal node, ', end = '')\n\n        elif self.parent != -1:\n\n            print('leaf, ', end = '')\n\n        else:\n\n            print('root, ', end = '')\n\n        print(self.children)\n\n\n\n\n\nclass RootedTree():\n\n    def __init__(self, n):\n\n        self.nodes = [Node(i, -1) for i in range(n)]\n\n    \n\n    def set_node(self, i_p):\n\n        i_p = list(map(int, i_p.split()))\n\n        num = i_p[0]\n\n        children = i_p[2:]\n\n        if children:\n\n            self.nodes[num].children = children\n\n            for n in children:\n\n                self.nodes[n].parent = num\n\n\n\n    def set_depth(self):\n\n        for n in self.nodes:\n\n            t_n = n\n\n            while t_n.parent != -1:\n\n                n.depth += 1\n\n                t_n = self.nodes[t_n.parent]\n\n\n\n    def show_nodes_info(self):\n\n        for n in self.nodes:\n\n            n.show_info()\n\n\n\n\n\n\n\nimport sys\n\n\n\nn = int(sys.stdin.readline())\n\n\n\nT = RootedTree(n)\n\n\n\nfor x in sys.stdin.readlines():\n\n    T.set_node(x)\n\n\n\nT.set_depth()\n\n\n\nT.show_nodes_info()\n", "output": "A", "improve_diff": 1.0331561429, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2sss = lambda n: [list(sys.stdin.readline().rstrip()) for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\nfrom collections import deque  # \n\nfrom collections import defaultdict  # \n\nfrom heapq import heapify, heappush, heappop, heappushpop  # \n\nfrom bisect import bisect_left, bisect_right  # \n\nsys.setrecursionlimit(int(1e+6))\n\nMOD = int(1e+9) + 7\n\n#import numpy as np  # 1.8.2\n\n#import scipy  # 0.13.3\n\n\n\ndef main():\n\n    N = i2n()\n\n    H = i2nn()\n\n    op = 0\n\n    while True:\n\n        b = False\n\n        hmax = 0\n\n        for i in range(N):\n\n            if H[i] > 0:\n\n                if b == False:\n\n                    b = True\n\n                    op += 1\n\n                H[i] -= 1\n\n                if hmax < H[i]:\n\n                    hmax = H[i]\n\n            else:\n\n                b = False\n\n        if hmax == 0:\n\n            break\n\n    print(op)\n\n\n\nmain()\n \nB. # ContestName\n\n# URL\n\nimport sys\n\n#import numpy as np\n\n\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n\n\ndef main():\n\n    N = i2n()\n\n    H = i2nn()\n\n    n = 0\n\n    while True:\n\n        l = -1\n\n        r = -1\n\n        for i, h in enumerate(H):\n\n            if l == -1 and h > 0:\n\n                l = i\n\n            if l > -1 and r == -1 and h <= 0:\n\n                r = i\n\n        if l == -1:\n\n            break\n\n        if r == -1:\n\n            r = N\n\n        for i in range(l, r):\n\n            H[i] -= 1\n\n        n += 1\n\n    print(n)\n\n\n\nmain()\n", "output": "B", "improve_diff": 1.5368377238, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf=10**20\n\nmod=10**9+7\n\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\n\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef LS(): return sys.stdin.readline().split()\n\ndef S(): return eval(input())\n\n\n\nlimit=50\n\ngraph=[[False]*limit for _ in range(limit)]\n\nvisited=[False]*limit\n\n\n\ndef dfs(n,v):\n\n  visited[v]=True\n\n  for v2 in range(n):\n\n    if graph[v][v2]==False:\n\n      continue\n\n    if visited[v2]:\n\n      continue\n\n    dfs(n,v2)\n\n\n\ndef main():\n\n  n,m=LI()\n\n  a=[[] for _ in range(n*n)]\n\n  b=[[] for _ in range(n*n)]\n\n  for i in range(m):\n\n    _a,_b=LI()\n\n    _a-=1\n\n    _b-=1\n\n    a[i]=_a\n\n    b[i]=_b\n\n    graph[_a][_b]=True\n\n    graph[_b][_a]=True\n\n\n\n  ans=0\n\n  for i in range(m):\n\n    graph[a[i]][b[i]]=False\n\n    graph[b[i]][a[i]]=False\n\n\n\n    for j in range(n):\n\n      visited[j]=False\n\n    dfs(n,0)\n\n    no_visited=False\n\n    for j in range(n):\n\n      if visited[j]==False:\n\n        no_visited=True\n\n    if no_visited:\n\n      ans+=1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n\n\n  return ans\n\n\n\n# main()\n\nprint((main()))\n \nB. import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf=10**20\n\nmod=10**9+7\n\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\n\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS(): return sys.stdin.readline().split()\n\ndef S(): return eval(input())\n\n\n\nnmax=50\n\ngraph=[[False]*nmax for _ in range(nmax)]\n\nvisited=[False]*nmax\n\n\n\ndef dfs(n,v):\n\n  visited[v]=True\n\n  for v2 in range(n):\n\n    if graph[v][v2]==False:\n\n      continue\n\n    if visited[v2]:\n\n      continue\n\n    dfs(n,v2)\n\n\n\ndef main():\n\n  n,m=LI()\n\n  a=[]\n\n  b=[]\n\n  for _ in range(m):\n\n    _a,_b=LI()\n\n    a.append(_a-1)\n\n    b.append(_b-1)\n\n    graph[_a-1][_b-1]=True\n\n    graph[_b-1][_a-1]=True\n\n\n\n  ans=0\n\n  for i in range(m):\n\n    graph[a[i]][b[i]]=False\n\n    graph[b[i]][a[i]]=False\n\n\n\n    for j in range(n):\n\n      visited[j]=False\n\n\n\n    dfs(n,j)\n\n\n\n    bridge=False\n\n    for j in range(n):\n\n      if visited[j]==False:\n\n        bridge=True\n\n    if bridge:\n\n      ans+=1\n\n\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n\n\n  return ans\n\n\n\n# main()\n\nprint((main()))\n", "output": "A", "improve_diff": 1.0812027401, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC068C - Cat Snuke and a Voyage (ARC079C)\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    N, M = input().split()\n\n    A = tuple(input().split() for _ in range(int(M)))\n\n    S, D = set(), set()  # start, destination\n\n    for a, b in A:\n\n        if a == \"1\":\n\n            S |= {b}\n\n        if b == N:\n\n            D |= {a}\n\n    flg = S & D  # if the same X in both S & D -> possible\n\n    print((\"POSSIBLE\" if flg else \"IMPOSSIBLE\"))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. # ABC068C - Cat Snuke and a Voyage (ARC079C)\n\ndef main():\n\n    N, M = tuple(map(int, input().split()))\n\n    A = tuple(tuple(map(int, input().split())) for _ in range(M))\n\n    S, D = set(), set()  # start, destination\n\n    for a, b in A:\n\n        if a == 1:\n\n            S |= {b}\n\n        if b == N:\n\n            D |= {a}\n\n    flg = S & D  # if the same X in both S & D -> possible\n\n    print((\"POSSIBLE\" if flg else \"IMPOSSIBLE\"))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.0427185713, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\n\n\nn = int(eval(input()))\n\nhappy = []\n\nans = 0\n\nfor i in range(n):\n\n    a, b = tuple(map(int, input().split()))\n\n    heapq.heappush(happy, - (a + b))\n\n    ans += a\n\nwhile len(happy) != 0:\n\n    heapq.heappop(happy)\n\n    if len(happy) != 0:\n\n        h = heapq.heappop(happy)\n\n        ans += h\n\n    else:\n\n        break\n\nprint(ans)\n \nB. n = int(eval(input()))\n\nhappy = []\n\nans = 0\n\nfor i in range(n):\n\n    a, b = tuple(map(int, input().split()))\n\n    happy.append(a + b)\n\n    ans += a\n\nhappy.sort(reverse=True)\n\nfor i in range(1, n, 2):\n\n    ans -= happy[i]\n\nprint(ans)\n", "output": "B", "improve_diff": 1.3756971808, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # 10**5100ms\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    AB\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nMOD = 10**9 + 7\n\n\n\nX, Y = read_ints()\n\nif (X + Y) % 3 != 0:  # !=0\n\n    print((0))\n\n    exit()\n\n\n\npascal_depth = int((X + Y) / 3)  # n\n\nx, y = int((X + Y) * 2 / 3), (X + Y) / 3\n\npascal_k = x - X  # \n\n\n\nif pascal_k > pascal_depth / 2:\n\n    pascal_k = pascal_depth - pascal_k\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n - r)\n\n    g1 = [1, 1]  # \n\n    g2 = [1, 1]  # \n\n    inverse = [0, 1]  # \n\n\n\n    for i in range(2, n + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\n\n\n\na = cmb(pascal_depth, pascal_k, MOD)\n\nprint(a)\n \nB. # 10**5100ms\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    AB\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nMOD = 10**9 + 7\n\n\n\nX, Y = read_ints()\n\nif (X + Y) % 3 != 0:  # !=0\n\n    print((0))\n\n    exit()\n\n\n\npascal_depth = int((X + Y) / 3)  # n\n\nx, y = int((X + Y) * 2 / 3), (X + Y) / 3\n\npascal_k = x - X  # \n\n\n\nif pascal_k > pascal_depth / 2:\n\n    pascal_k = pascal_depth - pascal_k\n\n\n\n# ans = 1\n\n# # for k in range(int(pascal_k), 0, -1):\n\n# #     ans *= pascal_depth\n\n# #     # print(ans)\n\n# #     pascal_depth -= 1\n\n# #     if ans > MOD:\n\n# #         ans %= MOD\n\n\n\n# # for k in range(int(pascal_k), 0, -1):\n\n# # j\n\n# for i in range(1, int(pascal_depth) + 1):\n\n#     ans *= i\n\n#     if ans > MOD:\n\n#         ans %= MOD\n\n\n\n# from math import factorial\n\n# # k_fact = factorial(pascal_k)\n\n# k_fact = 1\n\n# # k_fact\n\n# for i in range(1, pascal_k + 1):\n\n#     k_fact *= i\n\n#     if k_fact > MOD:\n\n#         k_fact %= MOD\n\n# ans *= k_fact**(MOD - 2) % MOD\n\n# # nk_fact = factorial(pascal_depth - pascal_k)\n\n# nk_fact = 1\n\n# for i in range(1, int(pascal_depth - pascal_k) + 1):\n\n#     nk_fact *= i\n\n#     if nk_fact > MOD:\n\n#         nk_fact %= MOD\n\n\n\n# ans *= nk_fact**(MOD - 2) % MOD\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\n\n\n\nmod = 10**9 + 7  # \n\nN = pascal_depth\n\ng1 = [1, 1]  # \n\ng2 = [1, 1]  # \n\ninverse = [0, 1]  # \n\n\n\nfor i in range(2, N + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\na = cmb(pascal_depth, pascal_k, mod)\n\nprint(a)\n", "output": "A", "improve_diff": 1.5463011951, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while True:\n\n    [n, m] = [int(x) for x in input().split()]\n\n    if [n, m] == [0, 0]:\n\n        break\n\n\n\n    hoge = list(range(1, n + 1))\n\n\n\n    data = []\n\n    for x in range(n - 1, 1, -1):\n\n        for y in range(x - 1, 0, -1):\n\n            for z in range(y - 1, -1, -1):\n\n                # print((x, y, z))\n\n                s = hoge[x] + hoge[y] + hoge[z]\n\n                if s < m:\n\n                    break\n\n                if s == m:\n\n                    data.append(s)\n\n\n\n    print((len(data))) \nB. while True:\n\n    [n, m] = [int(x) for x in input().split()]\n\n    if [n, m] == [0, 0]:\n\n        break\n\n\n\n    hoge = list(range(1, n + 1))\n\n\n\n    data = []\n\n    for x in range(0, n - 2):\n\n        for y in range(x + 1, n - 1):\n\n            for z in range(y + 1, n):\n\n                s = hoge[x] + hoge[y] + hoge[z]\n\n                if s == m:\n\n                    data.append(s)\n\n\n\n    print((len(data)))", "output": "B", "improve_diff": 1.0379798434, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nN,K = list(map(int,input().split()))\n\np = list(map(int,input().split()))\n\n\n\nl = []\n\nfor i in range(N):\n\n    l.append((1+p[i])/2)\n\n\n\na = [0] * N\n\na[0] = l[0]\n\nfor i in range(1,len(l)):\n\n    a[i] = a[i-1] + l[i]\n\n\n\nans = 0\n\nfor i in range(K,len(l)):\n\n    ans = max(ans,a[i]-a[i-K])\n\n\n\nif N - K == 0:\n\n    print((max(a)))\n\nelse:\n\n    print(ans) \nB. N,K = list(map(int,input().split()))\n\np = list(map(int,input().split()))\n\n\n\nl = []\n\nfor i in range(N):\n\n    l.append(((1+p[i])*(p[i]/2))/p[i])\n\n\n\nque = [0]*(N+1)\n\nfor i in range(1,N+1):\n\n    que[i] = l[i-1]+que[i-1]\n\n\n\nans = 0\n\nfor i in range(K,len(l)):\n\n    ans = max(ans,que[i+1]-que[i+1-K])\n\n\n\nif N == K:\n\n    print((max(que)))\n\nelse:\n\n    print(ans)", "output": "B", "improve_diff": 10.493778999, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nA,P = list(map(int, input().split()))\n\nprint((int(np.floor((3*A+P)/2)))) \nB. import math\n\nA,P = list(map(int, input().split()))\n\nprint((int(math.floor((3*A+P)/2))))", "output": "B", "improve_diff": 7.9187041448, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding:utf-8\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef II(): return int(sys.stdin.readline())\n\ndef SI(): return eval(input())\n\n\n\n\n\ndef main():\n\n    n = II()\n\n    P = LF()\n\n\n\n    dp = np.zeros(n + 1, dtype=float)\n\n    dp[0] = 1\n\n\n\n    for p in P:\n\n        tmp = dp * (1 - p)\n\n        tmp[1:] += dp[:-1] * p\n\n        dp = tmp\n\n\n\n    return np.sum(dp[n // 2 + 1:])\n\n\n\n\n\nprint((main()))\n \nB. # coding:utf-8\n\n\n\nimport sys\n\n\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef II(): return int(sys.stdin.readline())\n\ndef SI(): return eval(input())\n\n\n\n\n\ndef main():\n\n    n = II()\n\n    P = LF()\n\n\n\n    # dp[i]: i\n\n    dp = [1]\n\n\n\n    # \n\n    # O(NlogN)\n\n    for i in range(n):\n\n        tmp = [0] * (i + 2)\n\n        p = P[i]\n\n        q = 1 - P[i]\n\n        for j in range(i + 1):\n\n            tmp[j] += dp[j] * q\n\n            tmp[j + 1] += dp[j] * p\n\n        dp = tmp\n\n\n\n    return sum(dp[n // 2 + 1:])\n\n\n\n\n\nprint((main()))\n", "output": "B", "improve_diff": 10.7835178755, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\nimport numpy as np\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN, M = map(int, input().split())\n\nAB = [tuple(map(int, input().split())) for _ in range(N + M - 1)]\n\ne_from = [[] for _ in range(N+1)]\n\ne_to = [[] for _ in range(N+1)]\n\nfor a, b in AB:\n\n    e_from[a].append(b)\n\n    e_to[b].append(a)\n\n\n\n\n\nadd = np.zeros(N+1, dtype=int)\n\nrank = [-1]*(N+1)\n\n\n\n# \n\nfor i in range(1, N+1):\n\n    add[i] = len(e_to[i])\n\n    if len(e_to[i]) == 0:\n\n        root = i\n\n\n\n# BFS\n\nrank[root] = 0\n\nnode = deque([root])\n\nwhile node:\n\n    s = node.popleft()\n\n    add[e_from[s]] -= 1\n\n    for t in e_from[s]:\n\n        if add[t] == 0:\n\n            rank[t] = s\n\n            node.append(t)\n\n\n\nprint(*rank[1:], sep=\"\\n\")\n \nB. from collections import deque\n\nimport numpy as np\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN, M = map(int, input().split())\n\nAB = [tuple(map(int, input().split())) for _ in range(N + M - 1)]\n\ne_from = [[] for _ in range(N+1)]\n\ne_to = [[] for _ in range(N+1)]\n\nfor a, b in AB:\n\n    e_from[a].append(b)\n\n    e_to[b].append(a)\n\n\n\n\n\nadd = np.zeros(N+1, dtype=int)\n\nrank = [-1]*(N+1)\n\n\n\n# \n\nfor i in range(1, N+1):\n\n    add[i] = len(e_to[i])\n\n    if len(e_to[i]) == 0:\n\n        root = i\n\n\n\n# BFS\n\nrank[root] = 0\n\nnode = deque([root])\n\nwhile node:\n\n    s = node.popleft()\n\n    add[e_from[s]] -= 1\n\n    for t in e_from[s]:\n\n        if add[t] == 0:\n\n            rank[t] = s\n\n            node.append(t)\n\n\n\nprint(*rank[1:], sep=\"\\n\")\n", "output": "B", "improve_diff": 1.0245509054, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from collections import deque\n\n\n\n    N, X, Y = map(int, input().split())\n\n    X -= 1\n\n    Y -= 1\n\n\n\n    g = tuple(set() for _ in range(N))\n\n    for v in range(N):\n\n        if v > 0:\n\n            g[v].add(v - 1)\n\n        if v < N - 1:\n\n            g[v].add(v + 1)\n\n\n\n    g[X].add(Y)\n\n    g[Y].add(X)\n\n\n\n    ctr = [0] * N\n\n    for v in range(N):\n\n        dist = [-1] * N\n\n\n\n        q = deque()\n\n        q.append((v, 0))\n\n\n\n        while q:\n\n            v, d = q.popleft()\n\n            if ~dist[v] and dist[v] < d: continue\n\n            dist[v] = d\n\n            for u in g[v]:\n\n                if ~dist[u]: continue\n\n                dist[u] = d + 1\n\n                q.append((u, d + 1))\n\n\n\n        for d in dist:\n\n            ctr[d] += 1\n\n\n\n    print(*map(lambda x: x // 2, ctr[1:]), sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. # https://atcoder.jp/contests/abc160/submissions/11310424\n\n\n\ndef main():\n\n    N, X, Y = map(int, input().split())\n\n    X -= 1\n\n    Y -= 1\n\n\n\n    def dist(a, b):\n\n        return min(\n\n            abs(a - b),\n\n            abs(a - X) + abs(b - Y) + 1,\n\n            abs(a - Y) + abs(b - X) + 1\n\n        )\n\n\n\n    ctr = [0] * N\n\n    for b in range(N):\n\n        for a in range(b):\n\n            d = dist(a, b)\n\n            ctr[d] += 1\n\n\n\n    print(*ctr[1:], sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.616591706, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\n\n# AtCoder Beginner Contest\n\n# Problem C\n\n\n\nif __name__ == '__main__':\n\n    from collections import Counter\n\n\n\n    ball_count, kind_count = list(map(int, input().split()))\n\n    ball_numbers = Counter(list(map(int, input().split())))\n\n    sorted_ball_numbers = sorted(ball_numbers.values())\n\n    print((sum(sorted_ball_numbers[:-kind_count])))\n \nB. # -*- coding: utf-8 -*-\n\n\n\n# AtCoder Beginner Contest\n\n# Problem C\n\n\n\nif __name__ == '__main__':\n\n    from collections import Counter\n\n\n\n    ball_count, kind_count = list(map(int, input().split()))\n\n    ball_numbers = Counter(list(map(int, input().split())))\n\n    sorted_ball_numbers = sorted(list(ball_numbers.items()), key=lambda x: x[1])\n\n    ball_number_key_count = len(list(ball_numbers.keys()))\n\n\n\n    need_rewritten_count = 0\n\n    diff_count = ball_number_key_count - kind_count\n\n\n\n    if diff_count > 0:\n\n        for i, (key, value) in enumerate(sorted_ball_numbers):\n\n            if diff_count > i:\n\n                need_rewritten_count += value\n\n\n\n    print(need_rewritten_count)\n", "output": "B", "improve_diff": 1.0288689347, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(10000000)\n\nMOD = 998244353\n\nINF = 10 ** 15\n\n\n\ndef main():\n\n    N,S = list(map(int,input().split()))\n\n    A = list(map(int,input().split()))\n\n\n\n    dp = [0] * (1 + S)\n\n    dp[0] = pow(2,N,MOD)\n\n    inv2 = pow(2,MOD - 2,MOD)\n\n    for a in A:\n\n        for s in range(S,a - 1,-1):\n\n            dp[s] = (dp[s] + dp[s - a] * inv2)%MOD\n\n    print((dp[S]))\n\nif __name__ == '__main__':\n\n    main() \nB. import sys\n\nsys.setrecursionlimit(10000000)\n\nMOD = 998244353\n\nINF = 10 ** 15\n\nimport numpy as np\n\n\n\ndef main():\n\n    N,S = list(map(int,input().split()))\n\n    A = list(map(int,input().split()))\n\n\n\n    dp = np.zeros(S + 1,np.int64)\n\n    dp[0] = pow(2,N,MOD)\n\n    inv2 = pow(2,MOD - 2,MOD)\n\n    for a in A:\n\n        dp[a:] = np.mod(dp[a:] + dp[:-a] * inv2,MOD)\n\n    print((dp[S]))\n\nif __name__ == '__main__':\n\n    main()", "output": "A", "improve_diff": 10.9752537715, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\ncum = [0]\n\nfor a in A:\n\n    cum.append(cum[-1] + a)\n\ncount = Counter(cum)\n\nans = 0\n\nfor v in list(count.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans) \nB. from collections import Counter\n\nn = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\ncum = [0] * (n + 1)\n\nfor i in range(n):\n\n    cum[i + 1] = cum[i] + a[i]\n\ncum = sorted(cum)\n\ncount = Counter(cum)\n\nans = 0\n\nfor v in list(count.values()):\n\n    ans += v * (v - 1) // 2\n\nprint(ans)", "output": "B", "improve_diff": 1.0277780398, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport itertools\n\n\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n\n\n\n\n# bit ci \n\n\n\ndef toBit(n): \n\n    return bin(eval('0b' + str(n)))\n\n\n\ndef main():\n\n\n\n    n = int(sys.stdin.readline().rstrip())\n\n\n\n    schedule = [toBit(''.join(str(x) for x in sys.stdin.readline().split())) for _ in range(n)]\n\n    profit_table = [[int(x) for x in sys.stdin.readline().split()] for _ in range(n)]\n\n\n\n    maximum_profit = -10**10\n\n    for open_pattern in itertools.product('01', repeat=10):\n\n        open_pattern = toBit(''.join(open_pattern))\n\n        if open_pattern == '0b0':\n\n            continue\n\n        profit = 0\n\n        for i in range(n):\n\n            checked = schedule[i]\n\n            number_of_periods = bin(eval(checked) & eval(open_pattern)).count('1')\n\n            profit += profit_table[i][number_of_periods]\n\n        maximum_profit = max(maximum_profit, profit)\n\n\n\n    print(maximum_profit)\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n \nB. import sys\n\nimport itertools\n\n\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n\n\n\n\n# bit ci \n\n\n\ndef toBit(n): \n\n    return eval('0b' + n)\n\n\n\ndef main():\n\n\n\n    n = int(sys.stdin.readline().rstrip())\n\n\n\n    schedule = [toBit(''.join(str(x) for x in sys.stdin.readline().split())) for _ in range(n)]\n\n    profit_table = [[int(x) for x in sys.stdin.readline().split()] for _ in range(n)]\n\n\n\n    maximum_profit = -10**10\n\n    for open_pattern in itertools.product('01', repeat=10):\n\n        open_pattern = toBit(''.join(open_pattern))\n\n        if open_pattern == 0:\n\n            continue\n\n        profit = 0\n\n        for i in range(n):\n\n            checked = schedule[i]\n\n            number_of_periods = bin(checked & open_pattern).count('1')\n\n            profit += profit_table[i][number_of_periods]\n\n        maximum_profit = max(maximum_profit, profit)\n\n\n\n    print(maximum_profit)\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n", "output": "B", "improve_diff": 2.0016671883, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k = [int(i) for i in input().split()]\n\nans = 0\n\nif k == 0:\n\n    ans = n*n\n\nelse:\n\n    for b in range(k+1, n+1):\n\n        # number of perfect cycle\n\n        ans += n // b * (b-k)\n\n        r = n % b\n\n        ans += max(r - k+1, 0)\n\nprint(ans) \nB. n, k = [int(i) for i in input().split()]\n\nans = 0\n\nif k == 0:\n\n    ans = n*n\n\nelse:\n\n    for b in range(k+1, n+1):\n\n        # number of perfect cycle\n\n        ans += max(n // b, 0) * (b-k)\n\n        r = n % b\n\n        ans += max(r - k+1, 0)\n\nprint(ans)", "output": "A", "improve_diff": 1.0596689824, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,y,z = list(map(int,input().split()))\n\nyz = y + z\n\nx -= z\n\nprint((x // yz)) \nB. x,y,z = list(map(int,input().split()))\n\np = y + z + z\n\nc = 0\n\n\n\nwhile p <= x:\n\n    c += 1\n\n    p = p + y + z\n\n\n\nprint(c)", "output": "A", "improve_diff": 1.1069500119, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nreadline = sys.stdin.readline\n\n\n\nN = int(readline())\n\nINF = 10 ** 10\n\ndp = [INF] * (N + 1)\n\ndp[0] = 0\n\n\n\nfor i in range(10,0,-1):\n\n  for j in range(N + 1):\n\n    if dp[j] != INF:\n\n      if j + 6 ** i <= N:\n\n        dp[j + 6 ** i] = min(dp[j + 6 ** i], dp[j] + 1)\n\n      if j + 9 ** i <= N:\n\n        dp[j + 9 ** i] = min(dp[j + 9 ** i], dp[j] + 1)\n\n\n\nans = INF\n\nfor i in range(len(dp) - 1, -1, -1):\n\n  money = dp[i] + N - i\n\n  if ans > money:\n\n    ans = money\n\n        \n\nprint(ans) \nB. # dp\n\n# N\n\n\n\nimport sys\n\nreadline = sys.stdin.readline\n\n\n\nN = int(readline())\n\n\n\ndp = [i for i in range(N + 1)]\n\n\n\nfor i in range(len(dp)):\n\n  n = 6\n\n  while i + n < len(dp):\n\n    if dp[i + n] > dp[i] + 1:\n\n      dp[i + n] = dp[i] + 1\n\n    n *= 6\n\n  n = 9\n\n  while i + n < len(dp):\n\n    if dp[i + n] > dp[i] + 1:\n\n      dp[i + n] = dp[i] + 1\n\n    n *= 9\n\nprint((dp[N]))\n", "output": "A", "improve_diff": 1.4324291004, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\n\n\ndef divisor(n): \n\n    i = 1\n\n    table = []\n\n    while i * i <= n:\n\n        if n%i == 0:\n\n            table.append(i)\n\n            table.append(n//i)\n\n        i += 1\n\n    table = list(set(table))\n\n    table = sorted(table)\n\n    return table\n\n\n\ndef make_prime(U):\n\n    is_prime = np.zeros(U,np.bool)\n\n    is_prime[2] = 1\n\n    is_prime[3::2] = 1\n\n    M = int(U**.5)+1\n\n    for p in range(3,M,2):\n\n        if is_prime[p]:\n\n            is_prime[p*p::p+p] = 0\n\n    return is_prime, is_prime.nonzero()[0]\n\nA, B = list(map(int, input().split()))\n\n\n\ndef is_prime(n):\n\n    if n == 1:\n\n        return False\n\n    for i in range(2,int(n**0.5)+1):\n\n        if n % i == 0:\n\n            return False\n\n    return True\n\n\n\nA_list = set(divisor(A))\n\nB_list = set(divisor(B))\n\n\n\nlist = A_list & B_list\n\n\n\n#_, primes = make_prime(10**8)\n\n\n\ncnt = 1\n\n\n\nfor i in list:\n\n    if is_prime(i):\n\n        cnt += 1\n\n\n\nprint(cnt) \nB. def divisor(n): \n\n    i = 1\n\n    table = []\n\n    while i * i <= n:\n\n        if n%i == 0:\n\n            table.append(i)\n\n            table.append(n//i)\n\n        i += 1\n\n    table = list(set(table))\n\n    table = sorted(table)\n\n    return table\n\n\n\ndef is_prime(n):\n\n    if n == 1:\n\n        return False\n\n    for i in range(2,int(n**0.5)+1):\n\n        if n % i == 0:\n\n            return False\n\n    return True\n\n\n\nA, B = list(map(int, input().split()))\n\n\n\nA_list = set(divisor(A))\n\nB_list = set(divisor(B))\n\n\n\nlist = A_list & B_list\n\n\n\ncnt = 1\n\n\n\nfor i in list:\n\n    if is_prime(i):\n\n        cnt += 1\n\n\n\nprint(cnt)", "output": "B", "improve_diff": 11.4891908606, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    s=[]\n\n    for i in range(M):\n\n        L=LI()\n\n        s.append(L[1:])\n\n    p=LI()\n\n    \n\n    import itertools\n\n    \n\n    ans=0\n\n    for ite in itertools.product([0,1], repeat=N):\n\n        flag=1\n\n        for i in range(M):\n\n            temp=0\n\n            for ss in s[i]:\n\n                if ite[ss-1]:\n\n                    temp+=1\n\n            if temp%2==p[i]:\n\n                pass\n\n            else:\n\n                flag=0\n\n        if flag:\n\n            ans+=1\n\n            \n\n    print(ans)\n\n                \n\n                \n\n            \n\n        \n\n\n\nmain()\n \nB. N,M=list(map(int,input().split()))\n\nk=[0]*M\n\ns=[[] for _ in range(M)]\n\n\n\nfor i in range(M):\n\n    a=list(map(int,input().split()))\n\n    k[i]=a[0]\n\n    s[i]=a[1:]\n\n    s[i].sort()\n\n\n\np=list(map(int,input().split()))\n\n    \n\nans=0\n\nfor i in range(pow(2,N)):\n\n    light=0\n\n    for j in range(M):\n\n        temp=0\n\n        for kk in range(k[j]):\n\n            a=i>>(s[j][kk]-1)\n\n            if a&1==1:\n\n                temp+=1\n\n        if temp%2!=p[j]:\n\n            break\n\n        light+=1\n\n    if light==M:\n\n        ans+=1\n\n               \n\nprint(ans)\n\n\n\n\n\n\n", "output": "B", "improve_diff": 1.008364017, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=int(eval(input()))\n\nA=[((i+1),int(eval(input()))) for i in range(N)]\n\ncount = 0\n\nb=1\n\nfor i in range(N+1):\n\n  b = A[b-1][1]\n\n  count+= 1\n\n  if b==2:\n\n    print(count)\n\n    break\n\nif count == N+1:\n\n  print((-1))\n\n     \nB. N=int(eval(input()))\n\nA=[(int(eval(input()))) for i in range(N)]\n\ncount = 0\n\nb=1\n\nfor i in range(N+1):\n\n  b = A[b-1]\n\n  count+= 1\n\n  if b==2:\n\n    print(count)\n\n    break\n\nif count == N+1:\n\n  print((-1))", "output": "A", "improve_diff": 1.0241925786, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nX = [[] for _ in range(N)]\n\nP = [-1] * N\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    X[a-1].append((i, b-1))\n\n    #print(X)\n\n    #P[b-1] = a-1\n\n#print(X)\n\n\n\nQ = deque([(0, -1)])\n\nANS = [-1] * (N-1)\n\ncmax = 0\n\nwhile Q:\n\n    x, c0 = Q.pop()\n\n    c = 1\n\n    for i, y in X[x]:\n\n        if c == c0: c += 1\n\n        ANS[i] = c\n\n        Q.appendleft((y, c))\n\n        c += 1\n\n    cmax = max(cmax, c-1)\n\n\n\nprint(cmax)\n\nfor ans in ANS:\n\n    print(ans) \nB. import sys\n\nfrom collections import deque\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nX = [deque() for _ in range(N)]\n\nP = [-1] * N\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    X[a-1].append((i, b-1))\n\n    #print(X)\n\n    #P[b-1] = a-1\n\n#print(X)\n\n\n\nQ = deque([(0, -1)])\n\nANS = [-1] * (N-1)\n\ncmax = 0\n\nwhile Q:\n\n    x, c0 = Q.pop()\n\n    c = 1\n\n    for i, y in X[x]:\n\n        if c == c0: c += 1\n\n        ANS[i] = c\n\n        Q.appendleft((y, c))\n\n        c += 1\n\n    cmax = max(cmax, c-1)\n\n\n\nprint(cmax)\n\nfor ans in ANS:\n\n    print(ans)", "output": "A", "improve_diff": 1.0237223282, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import copy\n\n\n\n\n\ndef actual(n, P):\n\n    nums_asc = sorted(P)\n\n\n\n    if nums_asc == P:\n\n        return 'YES'\n\n\n\n    N = len(P)\n\n    for i in range(N):\n\n        for j in range(1, N):\n\n            swapped_nums = copy.deepcopy(P)\n\n\n\n            swapped_nums[i] = P[j]\n\n            swapped_nums[j] = P[i]\n\n\n\n            if swapped_nums == nums_asc:\n\n                return 'YES'\n\n\n\n    return 'NO'\n\n\n\nn = int(eval(input()))\n\nP = list(map(int, input().split()))\n\n\n\nprint((actual(n, P))) \nB. def actual(n, P):\n\n    # 21Swap\n\n    n_unmatched = [i == p for i, p in enumerate(P, start=1)].count(False)\n\n\n\n    if n_unmatched <= 2:\n\n        return 'YES'\n\n\n\n    return 'NO'\n\n\n\n\n\nn = int(eval(input()))\n\nP = list(map(int, input().split()))\n\n\n\nprint((actual(n, P)))", "output": "B", "improve_diff": 1.5761231719, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m,d = list(map(int, input().split()))\n\n\n\nif d == 0:\n\n    print(((m-1)/n))\n\nelse:\n\n    print((2*(n-d)*(m-1)/n/n)) \nB. # -*- coding: utf-8 -*-\n\nfrom math import log2\n\n\n\nline = list(map(int, input().split(\" \")))\n\nn = line[0]\n\nm = line[1]\n\nd = line[2]\n\n\n\nif 2*d<n and d>0:\n\n    ret1 = 1+(m-2)*log2(n)\n\n    ret2 = log2(n-d)\n\n    ret3 = log2(m-1)\n\n    ret4 = m*log2(n)\n\n    print((2**(ret1+ret2+ret3-ret4)))\n\nelse:\n\n    ret1 = (m-1)*log2(n)\n\n    ret2 = log2(m-1)\n\n    ret3 = m*log2(n)\n\n    print((2**(ret1+ret2-ret3)))\n", "output": "A", "improve_diff": 1.3905443858, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b,n=list(map(int,input().split()))\n\nf=lambda x:(a*x)//b-a*(x//b)\n\nprint((f(min(b-1,n)))) \nB. x, y, z = list(map(int, input().split()))\n\nif y - 1 >= z:\n\n\tprint(((x * z) // y - x * (z // y)))\n\nelse:\n\n\tw = (z // y) * y - 1\n\n\tprint((max((x * w) // y - x * (w // y), (x * z) // y - x * (z // y))))\n", "output": "B", "improve_diff": 1.0431825555, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict, deque, Counter\n\nfrom heapq import heappush, heappop, heapify\n\nimport math\n\nimport bisect\n\nimport random\n\nfrom itertools import permutations, accumulate, combinations, product\n\nimport sys\n\nimport string\n\nfrom bisect import bisect_left, bisect_right\n\nfrom math import factorial, ceil, floor\n\nfrom functools import reduce\n\n\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = 10 ** 15\n\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\n\ndef I(): return int(sys.stdin.buffer.readline())\n\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\n\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\n\ndef IR(n): return [I() for i in range(n)]\n\ndef LIR(n): return [LI() for i in range(n)]\n\ndef SR(n): return [S() for i in range(n)]\n\ndef LSR(n): return [LS() for i in range(n)]\n\ndef SRL(n): return [list(S()) for i in range(n)]\n\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\nmod = 1000000007\n\n\n\n\n\nn, m = LI()\n\ns, t = LI()\n\nG = [[] for _ in range(n)]\n\nfor i in range(m):\n\n    a, b, c = LI()\n\n    G[a - 1] += [(b - 1, c)]\n\n    G[b - 1] += [(a - 1, c)]\n\n\n\n\n\ndef dijkstra(graph, start=0):\n\n    route_cnt = [start] * n\n\n    route_cnt[start] = 1\n\n    que = [(0, start)]\n\n    dist = [INF] * n\n\n    dist[start] = 0\n\n    while que:\n\n        min_dist, u = heappop(que)\n\n        if min_dist > dist[u]:\n\n            continue\n\n        for v, c in graph[u]:\n\n            if dist[u] + c < dist[v]:\n\n                dist[v] = dist[u] + c\n\n                route_cnt[v] = route_cnt[u]\n\n                heappush(que, (dist[u] + c  , v))\n\n            elif dist[u] + c == dist[v]:\n\n                route_cnt[v] = (route_cnt[v] + route_cnt[u]) % mod\n\n    return route_cnt, dist\n\n\n\n\n\nroute_cnt, dist = dijkstra(G, s - 1)\n\nr_route_cnt, r_dist = dijkstra(G, t - 1)\n\ntotal_dist = dist[t - 1]\n\nret = 0\n\nfor i in range(n):\n\n    if dist[i] == r_dist[i]:\n\n        ret = ret + (route_cnt[i] * r_route_cnt[i] % mod) ** 2 % mod\n\n\n\n\n\nfor u in range(n):\n\n    for v, c in G[u]:\n\n        if dist[u] < total_dist / 2 < dist[v] and dist[u] + c + r_dist[v] == total_dist:\n\n            ret = (ret + route_cnt[u] ** 2 % mod * r_route_cnt[v] ** 2 % mod) % mod\n\n\n\n\n\nprint(((route_cnt[t - 1] ** 2 - ret) % mod)) \nB. from collections import defaultdict, deque, Counter\n\nfrom heapq import heappush, heappop, heapify\n\nimport math\n\nfrom bisect import bisect_left, bisect_right\n\nimport random\n\nfrom itertools import permutations, accumulate, combinations\n\nimport sys\n\nimport string\n\nfrom copy import deepcopy\n\n\n\nINF = 10 ** 20\n\n\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS(): return sys.stdin.readline().split()\n\ndef S(): return sys.stdin.readline().strip()\n\ndef IR(n): return [I() for i in range(n)]\n\ndef LIR(n): return [LI() for i in range(n)]\n\ndef SR(n): return [S() for i in range(n)]\n\ndef LSR(n): return [LS() for i in range(n)]\n\ndef SRL(n): return [list(S()) for i in range(n)]\n\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\nmod = 10 ** 9 + 7\n\n\n\ndef dijkstra(s):\n\n    hq=[(0,s)]\n\n    dist=[INF]*n\n\n    dp=[0]*n\n\n    dp[s]=1\n\n    dist[s]=0\n\n    checked=[0]*n\n\n    while hq:\n\n        min_dist,u=heappop(hq)\n\n        if checked[u]:\n\n            continue\n\n        checked[u]=1\n\n        for v,c in G[u]:\n\n            if dist[u]+c<dist[v]:\n\n                dist[v]=dist[u]+c\n\n                dp[v]=dp[u]\n\n                heappush(hq,(dist[v],v))\n\n            elif dist[u]+c==dist[v]:\n\n                dp[v]+=dp[u]\n\n                dp[v]%=mod\n\n    return dp, dist\n\n\n\nn, m = LI()\n\ns, t = LI()\n\nG = [[] for _ in range(n)]\n\nfor _ in range(m):\n\n    a,b, d = LI()\n\n    G[a - 1] += [(b - 1, d)]\n\n    G[b - 1] += [(a - 1, d)]\n\n\n\ndp1,dist1=dijkstra(s-1)\n\ndp2,dist2=dijkstra(t-1)\n\ntotal=dist1[t-1]\n\nans=dp1[t-1]*dp2[s-1]%mod\n\nfor i in range(n):\n\n    if dist1[i]==dist2[i]==total/2:\n\n        ans-=pow(dp1[i]*dp2[i]%mod,2,mod)\n\n\n\nfor j in range(n):\n\n    for k, ci in G[j]:\n\n        if dist1[j]+dist2[k]+ci==total and dist1[j]<total/2 and dist2[k]<total/2:\n\n            ans-=pow(dp1[j]*dp2[k]%mod,2,mod)\n\n\n\nprint((ans%mod))\n\n\n\n\n\n\n\n\n\n\n\n\n", "output": "A", "improve_diff": 1.0726061861, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport math\n\nimport itertools\n\nimport bisect\n\nfrom copy import copy\n\nfrom collections import deque,Counter\n\nfrom decimal import Decimal\n\ndef s(): return eval(input())\n\ndef i(): return int(eval(input()))\n\ndef S(): return input().split()\n\ndef I(): return list(map(int,input().split()))\n\ndef L(): return list(map(int,input().split()))\n\ndef l(): return list(map(int,input().split()))\n\ndef lcm(a,b): return a*b//math.gcd(a,b)\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10**9\n\nmod = 10**9+7\n\n\n\nN = i()\n\nL = []\n\nfor i in range(N):\n\n    A,B = I()\n\n    L.append([B,A])\n\nL.sort()\n\ncnt = 0\n\nfor i in range(N):\n\n    cnt += L[i][1]\n\n    if cnt > L[i][0]:\n\n        print('No')\n\n        exit()\n\nprint('Yes') \nB. from collections import deque\n\nN = int(eval(input()))\n\nA = deque()\n\nfor _ in range(N):\n\n    a,b = list(map(int,input().split()))\n\n    A.append([b,a])\n\nA = list(A)\n\nA.sort()\n\ntime = 0\n\nfor i in A:\n\n    time += i[1]\n\n    if time > i[0]:\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "output": "B", "improve_diff": 1.2864812292, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import permutations\n\nfrom heapq import *\n\nfrom collections import defaultdict\n\nfrom math import log\n\nfrom itertools import accumulate\n\nfrom collections import deque\n\n#maxv=[0]\n\nimport sys\n\nsys.setrecursionlimit(100100)\n\n\n\nimport math\n\nfrom math import ceil\n\nfrom copy import deepcopy\n\n\n\n\n\nN,M=list(map(int,input().split()))\n\nT=[[] for i in range(N)]\n\nfor i in range(M):\n\n    u,v=list(map(int,input().split()))\n\n    u,v=u-1,v-1\n\n    T[u].append(v)\n\n    T[v].append(u)\n\nlist=list(range(1,N))\n\nans=0\n\nfor l in permutations(list):\n\n    t=True\n\n    for i in range(N-1):\n\n        if i==0:\n\n            if not l[0] in T[0]:\n\n                t=False\n\n                break\n\n        else:\n\n            if not l[i] in T[l[i-1]]:\n\n                t=False\n\n                break\n\n    if t:\n\n        ans+=1\n\nprint(ans)\n \nB. import itertools\n\n\n\nN,M=list(map(int,input().split()))\n\nab=[]\n\nfor i in range(M):\n\n    a,b=list(map(int,input().split()))\n\n    ab.append([a,b])\n\n\n\nper=[i for i in range(2,N+1)]\n\npermu=[]\n\nfor i in itertools.permutations(per):\n\n    lst=[1]\n\n    lst.extend(i)\n\n    permu.append(lst)\n\nnum=0\n\nfor lst in permu:\n\n    can=True\n\n    for i in range(N-1):\n\n        if not([lst[i],lst[i+1]] in ab) and not([lst[i+1],lst[i]] in ab):\n\n            can=False\n\n            break\n\n    if can:\n\n        num+=1\n\nprint(num)\n", "output": "B", "improve_diff": 1.860331584, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nimport sys\n\nimport math\n\nimport numpy as np\n\nfrom collections import deque\n\nfrom itertools import combinations\n\nfrom functools import reduce\n\nfrom functools import lru_cache\n\nsys.setrecursionlimit(10**9)\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    print((math.ceil(N/2)))\n\n\n\nif __name__ == \"__main__\":\n\n  main()\n \nB. n = int(eval(input()))\n\nif n%2==0:\n\n  print((n//2))\n\nelse:\n\n  print(((n+1)//2))", "output": "B", "improve_diff": 11.0594875945, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nfrom collections import Counter\n\n\n\nn=int(eval(input()))\n\ns=[input()[0] for _ in range(n)]\n\nd=Counter(s)\n\nans=0\n\nfor i,j,k in itertools.combinations(\"MARCH\",3):\n\n    ans+=d[i]*d[j]*d[k]\n\nprint(ans) \nB. n = int(eval(input()))\n\nm,a,r,c,h = 0,0,0,0,0\n\nfor i in range(n):\n\n    s = input()[0]\n\n    if s=='M':m+=1\n\n    elif s=='A':a+=1\n\n    elif s=='R':r+=1\n\n    elif s=='C':c+=1\n\n    elif s=='H':h+=1\n\nx = [m,a,r,c,h]\n\nans = 0\n\nfor i in range(5):\n\n    for j in range(i):\n\n        for k in range(j):\n\n                ans += x[i]*x[j]*x[k]\n\nprint(ans)", "output": "B", "improve_diff": 1.5968714082, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\ndef calc(seq):\n\n  score = 0\n\n  for a,b,c,d in array:\n\n    if seq[b-1] - seq[a-1] == c:\n\n      score += d\n\n  return score\n\n  \n\nN,M,Q = list(map(int,input().split()))\n\narray = [ list(map(int,input().split())) for _ in range (Q) ]\n\nans = 0\n\nque = deque()\n\nfor i in range(1,M+1):\n\n  que.append([i])\n\n  \n\nwhile que:\n\n  seq = que.popleft()\n\n  if len(seq) == N:\n\n    score = calc(seq)\n\n    ans = max(ans,score)\n\n  else:\n\n    for i in range(seq[-1],M+1):\n\n      seq_next = seq + [i]\n\n      que.append(seq_next)\n\nprint(ans) \nB. from itertools import combinations_with_replacement as comb_rplc\n\nN,M,Q = list(map(int,input().split()))\n\narray = [ list(map(int,input().split())) for _ in range(Q) ]\n\nans = 0\n\nfor seq in comb_rplc(list(range(1, M + 1)), N):\n\n  score = 0\n\n  for a,b,c,d in array:\n\n    if seq[b-1] - seq [a-1] == c:\n\n      score += d\n\n  ans = max(score,ans)\n\nprint(ans)\n\n    \n", "output": "B", "improve_diff": 2.4570787594, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(10**7)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\ndef POW(x, y): return pow(x, y, MOD)\n\ndef INV(x, m=MOD): return pow(x, m - 2, m)\n\ndef DIV(x, y, m=MOD): return (x * INV(y, m)) % m\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef II(): return int(sys.stdin.readline())\n\ndef SI(): return eval(input())\n\n\n\n# factorials\n\n_nfact = 2 * (10 ** 5) + 10\n\nfacts = [0] * _nfact\n\nfacts[0] = 1\n\nfor i in range(1, _nfact):\n\n    facts[i] = (facts[i - 1] * i) % MOD\n\n\n\ndef binomial(m, n):\n\n    return DIV(facts[m], facts[n] * facts[m - n])\n\n\n\ndef main():\n\n    N, A, B, C = LI()\n\n    D = DIV(100, 100 - C)\n\n    ans = 0\n\n    ap, bp, abp = [1], [1], [POW(A + B, N)]\n\n    for _ in range(0, N + 1):\n\n        ap.append(ap[-1] * A % MOD)\n\n        bp.append(bp[-1] * B % MOD)\n\n        abp.append(abp[-1] * (A + B) % MOD)\n\n    for m in range(N, 2 * N):\n\n        x = binomial(m - 1, N - 1) * DIV(\n\n            ap[N] * bp[m - N] + ap[m - N] * bp[N],\n\n            abp[m - N]) % MOD\n\n        y = (m * D) % MOD\n\n        ans = (ans + (x * y) % MOD) % MOD\n\n    return ans\n\n\n\nprint((main())) \nB. import sys\n\nsys.setrecursionlimit(10**7)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\ndef POW(x, y): return pow(x, y, MOD)\n\ndef INV(x, m=MOD): return pow(x, m - 2, m)\n\ndef DIV(x, y, m=MOD): return (x * INV(y, m)) % m\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef II(): return int(sys.stdin.readline())\n\ndef SI(): return eval(input())\n\n\n\n# factorials\n\n_nfact = 2 * (10 ** 5) + 10\n\nfacts = [0] * _nfact\n\nfacts[0] = 1\n\nfor i in range(1, _nfact):\n\n    facts[i] = (facts[i - 1] * i) % MOD\n\nifacts = [0] * _nfact\n\nifacts[-1] = INV(facts[-1])\n\nfor i in range(_nfact - 1, 0, -1):\n\n    ifacts[i - 1] = (ifacts[i] * i) % MOD\n\n\n\ndef binomial(m, n):\n\n    return facts[m] * ifacts[n] * ifacts[m - n]\n\n\n\ndef main():\n\n    N, A, B, C = LI()\n\n    D = DIV(100, 100 - C)\n\n    ans = 0\n\n    ap, bp, abp = [1], [1], [POW(A + B, N)]\n\n    for _ in range(0, N + 1):\n\n        ap.append(ap[-1] * A % MOD)\n\n        bp.append(bp[-1] * B % MOD)\n\n        abp.append(abp[-1] * (A + B) % MOD)\n\n    for m in range(N, 2 * N):\n\n        x = binomial(m - 1, N - 1) * DIV(\n\n            ap[N] * bp[m - N] + ap[m - N] * bp[N],\n\n            abp[m - N]) % MOD\n\n        y = (m * D) % MOD\n\n        ans = (ans + (x * y) % MOD) % MOD\n\n    return ans\n\n\n\nprint((main()))", "output": "A", "improve_diff": 1.0278969112, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m = input().split()\n\n\n\np = set()\n\nq = set()\n\nfor _ in range(int(m)):\n\n    a, b = input().split()\n\n    if a == \"1\":\n\n        p.add(b)\n\n    elif b == n:\n\n        q.add(a)\n\nelse:\n\n    if p & q:\n\n        print(\"POSSIBLE\")\n\n    else:\n\n        print(\"IMPOSSIBLE\") \nB. n, m = list(map(int, input().split()))\n\n\n\np = set()\n\nq = set()\n\n\n\nfor _ in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    if a == 1:\n\n        p.add(b)\n\n    elif b == n:\n\n        q.add(a)\n\nelse:\n\n    print((\"POSSIBLE\" if p & q else \"IMPOSSIBLE\"))", "output": "A", "improve_diff": 1.0342386274, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b,c = list(map(int,input().split()))\n\n \n\nif (b-a) == (c-b):\n\n  print('YES')\n\nelse:\n\n  print('NO') \nB. a,b,c = list(map(int,input().split()))\n\nprint(('YES' if b-a == c-b else 'NO'))\n", "output": "A", "improve_diff": 1.0248394268, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m,k = list(map(int,input().split()))\n\na_list = list(map(int,input().split()))\n\nb_list = list(map(int,input().split()))\n\n\n\nfrom itertools import accumulate\n\nimport bisect\n\n\n\nsum_a_list = list(accumulate([0] + a_list))\n\nsum_b_list = list(accumulate([0] + b_list))\n\n\n\nans = 0\n\nb_idx = 0\n\nfor a_idx in range(n+1):\n\n    if sum_a_list[a_idx] > k:\n\n        continue\n\n\n\n    time_rest = k - sum_a_list[a_idx]\n\n    b_idx = bisect.bisect_right(sum_b_list,time_rest)\n\n\n\n    ans = max(ans, a_idx + b_idx - 1)\n\n\n\nprint(ans) \nB. N,M,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\n\n\nsumA = [0] * (N+1)\n\nsumB = [0] * (M+1)\n\nfor i in range(N):\n\n    sumA[i+1] = sumA[i] + A[i]\n\nfor i in range(M):\n\n    sumB[i+1] = sumB[i] + B[i]\n\n\n\nans = 0\n\nimport bisect\n\nfor i in range(N+1):\n\n    if K - sumA[i] >= 0:\n\n        idx = bisect.bisect_right(sumB,K-sumA[i])\n\n        ans = max(ans,i + idx - 1)\n\n#         print(idx-1)\n\nprint(ans)", "output": "B", "improve_diff": 1.009614512, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import copy\n\nn,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\ns,t=list(map(int,input().split()))\n\n\n\nconnection=[[] for i in range(3*n)]\n\nfor i in range(m):\n\n  connection[l[i][0]-1].append(l[i][1]-1+n)\n\n  connection[l[i][0]-1+n].append(l[i][1]-1+2*n)\n\n  connection[l[i][0]-1+2*n].append(l[i][1]-1)\n\ndistance=[-1 for i in range(3*n)]\n\ndistance[s-1]=0\n\nL=[s-1]\n\nL2=[]\n\nL3=[]\n\nct=1\n\nwhile len(L2)!=3*n and len(L)!=0:\n\n  for j in range(len(L)):\n\n    for k in range(len(connection[L[j]])):\n\n      if distance[connection[L[j]][k]]==-1:\n\n        distance[connection[L[j]][k]]=ct\n\n        L3.append(connection[L[j]][k])\n\n    L2.append(L[j])\n\n  L=copy.copy(L3)\n\n  L3=[]\n\n  ct+=1\n\nif distance[t-1]==-1:\n\n  print((-1))\n\nelse:\n\n  x=distance[t-1]-distance[s-1]\n\n  if x%3==0:\n\n    print((x//3))\n\n  else:\n\n    print((-1)) \nB. n,m=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(m)]\n\ns,t=list(map(int,input().split()))\n\n\n\nconnection=[[] for i in range(3*n)]\n\nfor i in range(m):\n\n  connection[l[i][0]-1].append(l[i][1]-1+n)\n\n  connection[l[i][0]-1+n].append(l[i][1]-1+2*n)\n\n  connection[l[i][0]-1+2*n].append(l[i][1]-1)\n\n\n\ndef bfs(v):\n\n  distance=[-1]*(3*n)\n\n  distance[v]=0\n\n  next=connection[v]\n\n  next2=set()\n\n  visited=[-1]*(3*n)\n\n  visited[v]=1\n\n  visitct=1\n\n  ct=0\n\n  while len(next)!=0 and visitct!=3*n:\n\n    ct+=1\n\n    for i in range(len(next)):\n\n      if visited[next[i]]==-1:\n\n        distance[next[i]]=ct\n\n        visited[next[i]]=1\n\n        visitct+=1\n\n        for j in range(len(connection[next[i]])):\n\n          if visited[connection[next[i]][j]]==-1:\n\n            next2.add(connection[next[i]][j])\n\n    next=list(next2)\n\n    next2=set()\n\n  return distance\n\n\n\nif bfs(s-1)[t-1]==-1 or bfs(s-1)[t-1]%3!=0:\n\n  print((-1))\n\nelse:\n\n  print((bfs(s-1)[t-1]//3))", "output": "B", "improve_diff": 1.6196237519, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N, A = list(map(int, input().split()))\n\n    x = list(map(int, input().split()))\n\n    dp = [[0] * (50*N + 1) for _ in range(N+1)]\n\n    dp[0][0] = 1\n\n    for k in range(N):\n\n        for i in reversed(list(range(k+1))):\n\n            for j in range(50 * N + 1 -x[k]):\n\n                dp[i+1][j+x[k]] += dp[i][j]\n\n    r = 0\n\n    for i in range(1, N+1):\n\n        r += dp[i][i*A]\n\n    return r\n\nprint((main()))\n \nB. import copy\n\ndef main():\n\n    N, A = list(map(int, input().split()))\n\n    x = list(map(int, input().split()))\n\n    dp = [[0] * (50*N + 1) for _ in range(N+1)]\n\n    dp[0][0] = 1\n\n    for k in range(N):\n\n        dpn = copy.deepcopy(dp)\n\n        for i in range(k+1):\n\n            for j in range(50 * N + 1 -x[k]):\n\n                dpn[i+1][j+x[k]] += dp[i][j]\n\n        dp = dpn\n\n    r = 0\n\n    for i in range(1, N+1):\n\n        r += dp[i][i*A]\n\n    return r\n\nprint((main()))\n", "output": "A", "improve_diff": 1.636716682, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. _,a=open(0);a,*b=list(map(int,a.split()))\n\nfor b in b:a^=b\n\nprint(('YNeos'[a>0::2])) \nB. from functools import*;_,a=open(0);print(('YNeos'[reduce(lambda x,y:x^y,list(map(int,a.split())))>0::2]))", "output": "A", "improve_diff": 1.6490470034, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from scipy.sparse.csgraph import floyd_warshall as wf\n\nfrom itertools import permutations\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    N, M, R = list(map(int, input().split()))\n\n    r = list(map(int, input().split()))\n\n\n\n    MAX = int(1e9)\n\n    link = [[MAX if i != j else 0 for j in range(N)] for i in range(N)]\n\n\n\n    for i in range(M):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        link[a][b] = c\n\n        link[b][a] = c\n\n    \n\n    link = wf(link)\n\n\n\n    ans = -1\n\n    for t in permutations(r):\n\n        tmp = 0\n\n        for i in range(1, R):\n\n            tmp += link[t[i-1]-1][t[i]-1]\n\n        if ans == -1:\n\n            ans = tmp\n\n        else:\n\n            ans = min(ans, tmp)\n\n    print((int(ans)))\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. from collections import deque\n\nimport itertools\n\nfrom scipy.sparse.csgraph import floyd_warshall as wf\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nMAX = 1e9\n\n\n\ndef main():\n\n    N, M, R = list(map(int, input().split()))\n\n    r = list(map(int, input().split()))\n\n    link = [[MAX if j != i else 0 for j in range(N+1)] for i in range(N+1)]\n\n\n\n    for i in range(M):\n\n        a, b, c = list(map(int, input().split()))\n\n        link[a][b] = c\n\n        link[b][a] = c\n\n\n\n    link = wf(link)\n\n\n\n    ans = MAX\n\n    for per in list(itertools.permutations(r)):\n\n        tmp = 0\n\n        for i in range(R-1):\n\n            tmp += link[per[i]][per[i+1]]\n\n        ans = min(ans, tmp)\n\n    print((int(ans)))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "B", "improve_diff": 1.017501176, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\n#sys.setrecursionlimit(10**9)\n\n#from functools import lru_cache\n\n\n\ndef RD(): return input().rstrip().decode()\n\ndef II(): return int(eval(input()))\n\ndef FI(): return float(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef MF(): return list(map(float,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef LF(): return list(map(float,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n# rstrip().decode()\n\n\n\n\n\n\n\ndef main():\n\n\tnn=II()\n\n\tA=LI()\n\n\tans=\"pairwise coprime\"\n\n\n\n\tn = 333335\n\n\tprimes = set(range(2, n+1))\n\n\tfor i in range(2, int(n**0.5+1)):\n\n\t\tprimes.difference_update(list(range(i*2, n+1, i)))\n\n\tprimes=set(primes)\n\n\n\n\t#print(primes)\n\n\n\n\n\n\tB=set(range(1,333335))\n\n\tC=set()\n\n\tfor i in A:\n\n\t\ta=set()\n\n\t\twhile i%2==0:\n\n\t\t\ta.add(2)\n\n\t\t\ti//=2\n\n\t\tf=3\n\n\t\twhile f*f<=i:\n\n\t\t\tif i in primes:\n\n\t\t\t\tbreak\n\n\t\t\telif i%f==0:\n\n\t\t\t\ta.add(f)\n\n\t\t\t\ti//=f\n\n\t\t\telse:\n\n\t\t\t\tf+=2\n\n\t\tif i!=1:\n\n\t\t\ta.add(i)\n\n\t\tB&=a\n\n\t\tif C&a:\n\n\t\t\tans=\"setwise coprime\"\n\n\t\tC|=a\n\n\n\n\tif B:\n\n\t\tans=\"not coprime\"\n\n\n\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n \nB. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\n#sys.setrecursionlimit(10**9)\n\n#from functools import lru_cache\n\n\n\ndef RD(): return input().rstrip().decode()\n\ndef II(): return int(eval(input()))\n\ndef FI(): return float(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef MF(): return list(map(float,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef LF(): return list(map(float,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n# rstrip().decode()\n\n\n\n\n\n\n\ndef main():\n\n\tnn=II()\n\n\tA=LI()\n\n\tans=\"pairwise coprime\"\n\n\n\n\tn = 500005\n\n\tprimes = set(range(2, n+1))\n\n\tfor i in range(2, int(n**0.5+1)):\n\n\t\tprimes.difference_update(list(range(i*2, n+1, i)))\n\n\tprimes=set(primes)\n\n\n\n\t#print(primes)\n\n\n\n\n\n\tB=set(range(1,5*10**5+5))\n\n\tC=set()\n\n\tfor i in A:\n\n\t\ta=set()\n\n\t\twhile i%2==0:\n\n\t\t\ta.add(2)\n\n\t\t\ti//=2\n\n\t\tf=3\n\n\t\twhile f*f<=i:\n\n\t\t\tif i in primes:\n\n\t\t\t\tbreak\n\n\t\t\telif i%f==0:\n\n\t\t\t\ta.add(f)\n\n\t\t\t\ti//=f\n\n\t\t\telse:\n\n\t\t\t\tf+=2\n\n\t\tif i!=1:\n\n\t\t\ta.add(i)\n\n\t\tB&=a\n\n\t\tif C&a:\n\n\t\t\tans=\"setwise coprime\"\n\n\t\tC|=a\n\n\n\n\tif B:\n\n\t\tans=\"not coprime\"\n\n\n\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n", "output": "A", "improve_diff": 1.2554257942, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. ri = lambda: int(input())\n\nrl = lambda: list(map(int,input().split()))\n\nrr = lambda N: [ri() for _ in range(N)]\n\nYN = lambda b: print('YES') if b else print('NO')\n\nyn = lambda b: print('Yes') if b else print('No')\n\nOE = lambda x: print('Odd') if x%2 else print('Even')\n\nINF = 10**18\n\n\n\nN=ri()\n\nW=[0]*N\n\nans = 1\n\nfor i in range(N):\n\n    W[i] = input()\n\n    if ans == 1 and i != 0 and W[i-1][-1] != W[i][0]:\n\n        ans = 0\n\n\n\nif ans == 1 and len(set(W)) != N:\n\n    ans = 0\n\n\n\nyn(ans)\n \nB. ri = lambda: int(input())\n\nrl = lambda: list(map(int,input().split()))\n\nrr = lambda N: [ri() for _ in range(N)]\n\nYN = lambda b: print('YES') if b else print('NO')\n\nyn = lambda b: print('Yes') if b else print('No')\n\nOE = lambda x: print('Odd') if x%2 else print('Even')\n\nINF = 10**18\n\n\n\nN=ri()\n\nW=[0]*N\n\nans = 1\n\nfor i in range(N):\n\n    W[i] = input()\n\n    if i != 0 and W[i-1][-1] != W[i][0]:\n\n        ans = 0\n\n\n\nimport collections\n\nWc = collections.Counter(W).most_common()\n\nif Wc[0][1] != 1:\n\n    ans = 0\n\n\n\nyn(ans)\n", "output": "A", "improve_diff": 1.5905530314, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ndef S(): return sys.stdin.readline().rstrip()\n\ndef I(): return int(sys.stdin.readline().rstrip())\n\n\n\nif __name__=='__main__':\n\n    n = I()\n\n    c = list(S())\n\n    i,j = 0,n-1\n\n    ans = 0\n\n    while i<j:\n\n        while c[i]=='R':\n\n            i += 1\n\n            if i==n:\n\n                break\n\n        while c[j]=='W':\n\n            j -= 1\n\n            if j==-1:\n\n                break\n\n        if i<j:\n\n            c[i],c[j] = c[j],c[i]\n\n            i += 1\n\n            j -= 1\n\n            ans += 1\n\n    print(ans)\n\n    exit() \nB. import sys\n\nfrom collections import deque\n\nimport numpy as np\n\nimport math\n\nsys.setrecursionlimit(10**6)\n\ndef S(): return sys.stdin.readline().rstrip()\n\ndef SL(): return list(map(str,sys.stdin.readline().rstrip().split()))\n\ndef I(): return int(sys.stdin.readline().rstrip())\n\ndef IL(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\n\nif __name__=='__main__':\n\n    n = I()\n\n    c = list(S())\n\n    i,j = 0,n-1\n\n    ans = 0\n\n    while i<j:\n\n        while c[i]=='R':\n\n            i += 1\n\n            if i==n-1:\n\n                break\n\n        while c[j]=='W':\n\n            j -= 1\n\n            if j==0:\n\n                break\n\n        if i<j:\n\n            c[i],c[j] = c[j],c[i]\n\n            i += 1\n\n            j -= 1\n\n            ans += 1\n\n    print(ans)\n\n    exit()", "output": "A", "improve_diff": 11.2042432524, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from heapq import*\n\n(n,m,s),*t=[list(map(int,t.split()))for t in open(0)]\n\n*e,=eval('[],'*8**6)\n\nfor u,v,a,b in t[:m]:\n\n    for i in range(2501-a):\n\n        e[(i+a)*51+u]+=(b,i*51+v),\n\n        e[(i+a)*51+v]+=(b,i*51+u),\n\nfor i,(c,d)in enumerate(t[m:],1):\n\n    for j in range(2501-c):\n\n        e[j*51+i]+=(d,(j+c)*51+i),\n\nd=[10**18]*8**6\n\nf=[1]*8**6\n\nq=[(0,min(2500,s)*51+1)]\n\nwhile q:\n\n    c,v=heappop(q)\n\n    if f[v]<1:continue\n\n    d[v],f[v]=c,0\n\n    for p,w in e[v]:\n\n        if f[w]:heappush(q,(c+p,w))\n\nfor i in range(2,n+1):print((min(d[i::51]))) \nB. def main():\n\n    from heapq import heappush,heappop\n\n    (n,m,s),*t=[list(map(int,r.split()))for r in open(0)]\n\n    e=[[]for _ in range(8**6)]\n\n    for u,v,a,b in t[:m]:\n\n        for i in range(2501-a):\n\n            e[(i+a)*51+u]+=(b,i*51+v),\n\n            e[(i+a)*51+v]+=(b,i*51+u),\n\n    for i,(c,d)in enumerate(t[m:],1):\n\n        for j in range(2501-c):\n\n            e[j*51+i]+=(d,(j+c)*51+i),\n\n    x=[10**18]*8**6\n\n    f=[1]*8**6\n\n    q=[(0,min(2500,s)*51+1)]\n\n    while q:\n\n        c,v=heappop(q)\n\n        if f[v]<1:continue\n\n        x[v],f[v]=c,0\n\n        for p,w in e[v]:\n\n            if f[w]:heappush(q,(c+p,w))\n\n    for i in range(2,n+1):print((min(x[i::51])))\n\nmain()", "output": "B", "improve_diff": 7.4701252054, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\n\n\ndef main():\n\n    eval(input())\n\n    A = list(enumerate(input().split()))\n\n    b = deque()\n\n    (append1, append2) = (b.append, b.appendleft) if len(A) % 2 == 0 else (b.appendleft, b.append)\n\n    for i, a in A:\n\n        if i % 2 == 0:\n\n            append1(a) \n\n        else:\n\n            append2(a)\n\n\n\n    print((\" \".join(list(b))))\n\n\n\nmain()\n \nB. from collections import deque\n\n\n\ndef main():\n\n    eval(input())\n\n    A = list(enumerate(input().split()))\n\n    size = len(A)\n\n    b = deque()\n\n    for i, a in A:\n\n        if i % 2 == 0:\n\n            if size % 2 == 0:\n\n                b.append(a)\n\n            else:\n\n                b.appendleft(a)    \n\n        else:\n\n            if size % 2 == 0:\n\n                b.appendleft(a)\n\n            else:\n\n                b.append(a)\n\n\n\n    print((\" \".join(list(b))))\n\n\n\nmain()", "output": "A", "improve_diff": 1.0250088499, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nM = []\n\n\n\nfor i in range(n):\n\n    M.append(A[i] - (i + 1))\n\n    \n\nM.sort()\n\nb = M[len(M) // 2]\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans += abs(A[i] - (b + i + 1))\n\n    \n\nprint(ans) \nB. n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = []\n\n\n\nfor i in range(n):\n\n    b = A[i] - ( i + 1)\n\n    B.append(b)\n\n    \n\nB.sort()\n\nans = 0\n\nfor i in range(n):\n\n    ans += abs(A[i] - (B[len(B) // 2] + i + 1))\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0070476957, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\n\n\nn = int(eval(input()))\n\nd = [int(eval(input())) for i in range(n)]\n\n\n\ndict = defaultdict(int)\n\nfor i in d:\n\n    dict[i] += 1\n\nprint((len(dict)))\n \nB. n = int(eval(input()))\n\nd = {int(eval(input())) for i in range(n)}\n\nprint((len(d)))\n", "output": "B", "improve_diff": 1.6005310729, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import bisect\n\n\n\nN, K = list(map(int, input().split()))\n\nh = list(map(int, input().split()))\n\nh = sorted(h)\n\nprint((N - bisect.bisect_left(h,K)))\n \nB. N, K = list(map(int, input().split()))\n\nh = list(map(int, input().split()))\n\nh = sorted(h, reverse=True)\n\nfor i, h_i in enumerate(h):\n\n  if h_i >= K:\n\n    continue\n\n  else:\n\n    print(i)\n\n    exit()\n\n\n\nprint(N)", "output": "B", "improve_diff": 1.3787177788, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\n\nab = [tuple(map(int, input().split())) for _ in range(n)]\n\nab.sort()\n\nans = 0\n\nfor a, b in ab:\n\n    buy = [m, b][0 <= m-b]\n\n    m -= buy\n\n    ans += a*buy\n\nprint(ans)\n \nB. import sys\n\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\n\nab = [tuple(map(int, input().split())) for _ in range(n)]\n\nab.sort()\n\nans = 0\n\nfor a, b in ab:\n\n    buy = min(m, b)\n\n    m -= buy\n\n    ans += a*buy\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0300956521, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def bubbleSort( cards ):\n\n    n = len( cards )\n\n    for i in range( 0, n ):\n\n        for j in range( n-1 , i, -1 ):\n\n            if int( cards[j][1] ) < int( cards[ j-1 ][1] ):\n\n                cards[j], cards[ j-1 ] = cards[ j-1 ], cards[j]\n\n \n\n    print(( \" \".join( map( str, cards ) ) ))\n\n \n\ndef selectionSort( cards ):\n\n\tn = len( cards )\n\n\tfor i in range( 0, n ):\n\n\t\tmini = i\n\n\t\tfor j in range( i , n ):\n\n\t\t\tif int( cards[j][1] ) < int( cards[ mini ][1] ):\n\n\t\t\t\tmini = j\n\n\t\tif mini != i:\n\n\t\t\tcards[i], cards[ mini ] = cards[ mini ], cards[i]\n\n\n\n\tprint(( \" \".join( map( str, cards ) ) ))\n\n\n\n\n\nn = int( input( ) )\n\ncards = input( ).split( \" \" )\n\ncards2 = list( cards )\n\nbubbleSort( cards )\n\nprint( \"Stable\" )\n\nselectionSort( cards2 )\n\nif cards2 == cards:\n\n\tprint( \"Stable\" )\n\nelse:\n\n\tprint( \"Not stable\" ) \nB. def bubbleSort( cards ):\n\n    n = len( cards )\n\n    for i in range( 0, n ):\n\n        for j in range( n-1 , i, -1 ):\n\n            if int( cards[j][1] ) < int( cards[ j-1 ][1] ):\n\n                cards[j], cards[ j-1 ] = cards[ j-1 ], cards[j]\n\n \n\n    print(( \" \".join( map( str, cards ) ) ))\n\n \n\ndef selectionSort( cards ):\n\n\tn = len( cards )\n\n\tfor i in range( 0, n ):\n\n\t\tmini = i\n\n\t\tfor j in range( i , n ):\n\n\t\t\tif int( cards[j][1] ) < int( cards[ mini ][1] ):\n\n\t\t\t\tmini = j\n\n\t\tif mini != i:\n\n\t\t\tcards[i], cards[ mini ] = cards[ mini ], cards[i]\n\n\n\n\tprint(( \" \".join( map( str, cards ) ) ))\n\n\n\n\n\nn = int( eval(input( )) )\n\ncards = input( ).split( \" \" )\n\ncards2 = list( cards )\n\nbubbleSort( cards )\n\nprint( \"Stable\" )\n\nselectionSort( cards2 )\n\nif \" \".join( map( str, cards2 ) ) == \" \".join( map( str, cards ) ):\n\n\tprint( \"Stable\" )\n\nelse:\n\n\tprint( \"Not stable\" )", "output": "A", "improve_diff": 1.0363204818, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\n\n\ndef main():\n\n    N, *LR = list(map(int, stdin.buffer.read().split()))\n\n    L, R = LR[::2], LR[1::2]\n\n\n\n    Lp = max(L)\n\n    Rq = min(R)\n\n\n\n    AB = sorted((max(0, r - Lp + 1), -max(0, Rq - l + 1)) for l, r in zip(L, R))\n\n\n\n    mi = float(\"inf\")\n\n    ma = max(r - l + 1 for l, r in zip(L, R)) + max(0, Rq - Lp + 1)\n\n\n\n    for i, (a, b) in enumerate(AB):\n\n        if i:\n\n            ma = max(ma, mi + a)\n\n        mi = min(mi, -b)\n\n\n\n    print(ma)\n\n\n\n\n\nmain()\n \nB. from sys import stdin\n\n\n\ndef main():\n\n    N, *LR = list(map(int, stdin.buffer.read().split()))\n\n    L, R = LR[::2], LR[1::2]\n\n\n\n    Lp = max(L)\n\n    Rq = min(R)\n\n\n\n    A, B = list(zip(*sorted((max(0, r - Lp + 1), -max(0, Rq - l + 1)) for l, r in zip(L, R))))\n\n\n\n    mi = float(\"inf\")\n\n    ma = max(r - l + 1 for l, r in zip(L, R)) + max(0, Rq - Lp + 1)\n\n\n\n    for a, b in zip(A[1:], B):\n\n        mi = min(mi, -b)\n\n        ma = max(ma, mi + a)\n\n\n\n    print(ma)\n\n\n\n\n\nmain()\n", "output": "A", "improve_diff": 1.0504108242, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k,q=list(map(int,input().split()))\n\na=[]\n\nwhile True:\n\n  try:\n\n    a.append(int(eval(input())))\n\n  except:\n\n    break;\n\nt=[0]*n\n\nfor i in a:\n\n  t[i-1]+=1\n\nfor i in t:\n\n  if i >= q - k + 1:\n\n    print(\"Yes\")\n\n  else:\n\n    print(\"No\") \nB. #C\n\nn, k, q = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(q)]\n\npeople = [0] * n\n\nfor i in a:\n\n    people[i-1] += 1\n\n# print(people)\n\nfor i in people:\n\n    if k <= q - i:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")", "output": "A", "improve_diff": 1.0285905506, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nsys.setrecursionlimit(10 ** 5)\n\n\n\n\n\ndef dfs(v):\n\n    if v > 3234566667:\n\n        return\n\n    ans.append(v)\n\n    d = v % 10\n\n    if d - 1 >= 0:\n\n        dfs(v * 10 + d - 1)\n\n    dfs(v * 10 + d)\n\n    if d + 1 < 10:\n\n        dfs(v * 10 + d + 1)\n\n\n\n\n\nK = int(eval(input()))\n\nans = []\n\n[dfs(i) for i in range(1, 10)]\n\nprint((sorted(ans)[K - 1]))\n \nB. def is_good(mid, key):\n\n    S = list(map(int, str(mid)))\n\n    N = len(S)\n\n    dp = [[[0] * 11 for _ in range(2)] for _ in range(N + 1)]\n\n    dp[1][1][10] = 1\n\n    for k in range(1, S[0]):\n\n        dp[1][1][k] = 1\n\n    dp[1][0][S[0]] = 1\n\n    for i in range(1, N):\n\n        for k in range(1, 11):\n\n            dp[i + 1][1][k] += dp[i][0][10] + dp[i][1][10]\n\n        for is_less in range(2):\n\n            for k in range(10):\n\n                for l in range(k - 1, k + 2):\n\n                    if not 0 <= l <= 9 or (not is_less and l > S[i]):\n\n                        continue\n\n                    dp[i + 1][is_less or l < S[i]][l] += dp[i][is_less][k]\n\n    return sum(dp[N][0][k] + dp[N][1][k] for k in range(10)) >= key\n\n\n\n\n\ndef binary_search(bad, good, key):\n\n    while good - bad > 1:\n\n        mid = (bad + good) // 2\n\n        if is_good(mid, key):\n\n            good = mid\n\n        else:\n\n            bad = mid\n\n    return good\n\n\n\n\n\nK = int(eval(input()))\n\nprint((binary_search(0, 3234566667, K)))\n", "output": "B", "improve_diff": 4.6370821479, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!python3\n\n\n\nimport sys\n\niim = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\n\n\n\ndef get_factor(N):\n\n    N1 = N + 2\n\n    A = [2, 0] * (N1//2)\n\n\n\n    for i in range(3, N1, 2):\n\n        if A[i]:\n\n            continue\n\n        for j in range(i, N1, 2*i):\n\n            A[j] = i\n\n\n\n    def factor(n):\n\n        i = 0\n\n        ans = []\n\n\n\n        while n & 1 == 0:\n\n            i += 1\n\n            n >>= 1\n\n        if i:\n\n            ans.append((2, i))\n\n\n\n        while n > 1:\n\n            a = A[n]\n\n            i = 1\n\n            while True:\n\n                n //= a\n\n                b = A[n]\n\n                if a != b:\n\n                    ans.append((a, i))\n\n                    b = a\n\n                    break\n\n                i += 1\n\n\n\n        return ans\n\n\n\n\n\n    return factor\n\n\n\ndef resolve():\n\n    N = int(sys.stdin.readline())\n\n\n\n    f = get_factor(N)\n\n\n\n    ans = 0\n\n    for i in range(1, N):\n\n        num = 1\n\n        #print(i, f(i))\n\n        for a, b in f(i):\n\n            num *= b + 1\n\n        ans += num\n\n    print(ans)\n\nif __name__ == \"__main__\":\n\n    resolve()\n \nB. #!python3\n\n\n\nimport sys\n\niim = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\n\n\n\ndef resolve():\n\n    N = int(sys.stdin.readline())\n\n    N1 = N - 1\n\n\n\n    ans = 0\n\n    for i in range(1, N):\n\n        ans += N1//i\n\n    print(ans)\n\nif __name__ == \"__main__\":\n\n    resolve()\n", "output": "B", "improve_diff": 8.9429840874, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\n# Your code here!\n\nSIZE=300000; MOD=10**9+7 #\n\n\n\ninv = [0]*(SIZE+1)# inv[j] = j^{-1} mod MOD\n\nfac = [0]*(SIZE+1)# fac[j] = j! mod MOD\n\nfinv = [0]*(SIZE+1)# finv[j] = (j!)^{-1} mod MOD\n\ninv[1] = 1\n\nfac[0] = fac[1] = 1\n\nfinv[0] = finv[1] = 1\n\nfor i in range(2,SIZE+1):\n\n    inv[i] = MOD -(MOD//i)*inv[MOD%i]%MOD\n\n    fac[i] = fac[i-1]*i%MOD\n\n    finv[i]= finv[i-1]*inv[i]%MOD\n\n\n\ndef choose(n,r): # nCk mod MOD \n\n    if 0 <= r <= n:\n\n        return (fac[n]*finv[r]%MOD)*finv[n-r]%MOD\n\n    else:\n\n        return 0\n\n\n\n\n\nh,w,n = [int(i) for i in input().split()]\n\nxy = [[1,1]]+[[int(i) for i in input().split()] for _ in range(n)]\n\n\n\ndp = [0]*(n+1)\n\ndp[0] = 1\n\n\n\nxy.sort(key=lambda x: x[1])\n\nxy.sort(key=lambda x: x[0])\n\n\n\n#print(xy)\n\n\n\nfor i in range(1,n+1):\n\n    x,y = xy[i]\n\n    for j in range(i):\n\n        xj,yj = xy[j]\n\n        dp[i] -= choose(x - xj + y-yj, y-yj)*dp[j]\n\n        dp[i] %= MOD\n\n\n\nans = 0\n\n#print(dp)\n\nfor i,dpi in enumerate(dp):\n\n    x,y=xy[i]\n\n    ans += choose(h-x + w-y, w-y) * dpi\n\n    ans %= MOD\n\nprint(ans)\n\n\n\n\n \nB. # coding: utf-8\n\n# Your code here!\n\nSIZE=300000; MOD=10**9+7 #\n\n\n\ninv = [0]*(SIZE+1)# inv[j] = j^{-1} mod MOD\n\nfac = [0]*(SIZE+1)# fac[j] = j! mod MOD\n\nfinv = [0]*(SIZE+1)# finv[j] = (j!)^{-1} mod MOD\n\ninv[1] = 1\n\nfac[0] = fac[1] = 1\n\nfinv[0] = finv[1] = 1\n\nfor i in range(2,SIZE+1):\n\n    inv[i] = MOD -(MOD//i)*inv[MOD%i]%MOD\n\n    fac[i] = fac[i-1]*i%MOD\n\n    finv[i]= finv[i-1]*inv[i]%MOD\n\n\n\ndef choose(n,r): # nCk mod MOD \n\n    if 0 <= r <= n:\n\n        return (fac[n]*finv[r]%MOD)*finv[n-r]%MOD\n\n    else:\n\n        return 0\n\n\n\n\n\nh,w,n = [int(i) for i in input().split()]\n\nxy = [[1,1]]+[[int(i) for i in input().split()] for _ in range(n)]\n\n\n\ndp = [0]*(n+1)\n\ndp[0] = 1\n\n\n\nxy.sort()\n\n\n\n#print(xy)\n\n\n\nfor i in range(1,n+1):\n\n    x,y = xy[i]\n\n    for j in range(i):\n\n        xj,yj = xy[j]\n\n        dp[i] -= choose(x - xj + y-yj, y-yj)*dp[j]\n\n        dp[i] %= MOD\n\n\n\nans = 0\n\n#print(dp)\n\nfor i,dpi in enumerate(dp):\n\n    x,y=xy[i]\n\n    ans += choose(h-x + w-y, w-y) * dpi\n\n    ans %= MOD\n\nprint(ans)\n\n\n\n\n", "output": "B", "improve_diff": 1.0189402693, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nn, m, x = list(map(int, input().split()))\n\nca = [list(map(int, input().split())) for _ in range(n)]\n\ncnt = [i for i in range(n)]\n\nans = 10**12\n\nok = False\n\nfor i in range(1,n+1):\n\n    for conb in itertools.combinations(cnt, i):\n\n        z = [0]*(m+1)\n\n        for j in conb:\n\n            for k in range(m+1):\n\n                z[k] = z[k] + ca[j][k]\n\n            if sum(l >= x for l in z[1:]) == m:\n\n                ans = min(ans, z[0])\n\n                ok = True\n\nif ok:\n\n    print(ans)\n\nelse:\n\n    print((-1))\n \nB. n, m, x = list(map(int, input().split()))\n\nca = [list(map(int, input().split())) for _ in range(n)]\n\nans = 10**111\n\nok = False\n\nfor i in range(2**n):\n\n    y = [0]*(m+1)\n\n    for j in range(n):\n\n        if i & (1 << j):\n\n            for k in range(m+1):\n\n                y[k] = y[k] + ca[j][k]\n\n    if sum(z >= x for z in y[1:]) == m:\n\n        ans = min(ans, y[0])\n\n        ok = True\n\nif ok:\n\n    print(ans)\n\nelse:\n\n    print((-1))\n", "output": "B", "improve_diff": 1.0431827472, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nN, K = list(map(int, input().split()))\n\n\n\n\n\nd = list(map(int, input().split()))\n\nd_set = set(d)\n\n\n\nnum_set = set([1,2,3,4,5,6,7,8,9,0])\n\nenable = num_set - d_set\n\n#print(type(enable))\n\n#print(enable)\n\n\n\n\n\ndef dfs(s):\n\n  #print(s)\n\n  global ans\n\n  # N\n\n  if s != \"\":\n\n    if int(s) >= N:\n\n      #print(s)\n\n      ans.append(int(s))\n\n      return\n\n\n\n  for num in enable:\n\n    if len(s) == 0 and num == 0:\n\n      continue\n\n    else:\n\n      (dfs(s+str(num)))\n\n    \n\n  return\n\n\n\nans = []\n\ndfs(\"\")\n\n#print(ans)\n\nprint((min(ans))) \nB. n, k = list(map(int, input().split()))\n\n\n\nd = list(map(int, input().split()))\n\n\n\nn_list = list(str(n))\n\nn_list = [int(num) for num in n_list]\n\n\n\nnum = {1,2,3,4,5,6,7,8,9,0}\n\n\n\nd_set = set(d)\n\nempty = set()\n\n#print(set(n_list))\n\n#print(d_set)\n\n#print(set(n_list) & d_set)\n\nwhile(1):\n\n  n_list = list(str(n))\n\n  n_list = [int(num) for num in n_list]\n\n  if(set(n_list) & d_set == empty):\n\n    print(n)\n\n    break\n\n  n += 1\n\n  \n", "output": "A", "improve_diff": 1.1065734661, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import bisect\n\nimport sys\n\n\n\nA, B, Q = list(map(int,input().split()))\n\ns = tuple([-(10**18)] + list(map(int, (sys.stdin.readline() for _ in [0]*A))) + [10**18])\n\nt = tuple([-(10**18)] + list(map(int, (sys.stdin.readline() for _ in [0]*B))) + [10**18])\n\n\n\n\n\ndef solve(s,t,x):\n\n    ans = 10**18\n\n    for i in range(2):\n\n        a, b = (s, t) if i==0 else (t, s)\n\n        posX1 = bisect.bisect_left(a,x)\n\n        for j in range(2):\n\n            ax = a[posX1 -j]\n\n            posX2 = bisect.bisect_left(b,ax)\n\n            for k in range(2):\n\n                bx = b[posX2-k]\n\n                ans = min(ans, abs(x-ax)+abs(bx-ax))\n\n    return ans\n\n\n\nfor _ in range(Q):\n\n    x = int(eval(input()))\n\n    print((solve(s,t,x))) \nB. import bisect\n\nimport sys\n\n\n\nA, B, Q = map(int,input().split())\n\ns = tuple([-(10**18)] + list(map(int, (sys.stdin.readline() for _ in [0]*A))) + [10**18])\n\nt = tuple([-(10**18)] + list(map(int, (sys.stdin.readline() for _ in [0]*B))) + [10**18])\n\n\n\n\n\ndef solve(s,t,x):\n\n    ans = 10**18\n\n    for i in range(2):\n\n        a, b = (s, t) if i==0 else (t, s)\n\n        posX1 = bisect.bisect_left(a,x)\n\n        for j in range(2):\n\n            ax = a[posX1 -j]\n\n            posX2 = bisect.bisect_left(b,ax)\n\n            for k in range(2):\n\n                bx = b[posX2-k]\n\n                ans = min(ans, abs(x-ax)+abs(bx-ax))\n\n    return ans\n\n\n\nans = [solve(s,t,x) for x in map(int,sys.stdin)]\n\nprint(*ans, sep=\"\\n\")\n", "output": "B", "improve_diff": 1.0178159343, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import collections\n\nn,k,q = list(map(int, input().split()))\n\ntemp = [k-q for _ in range(n)]\n\nfor _ in range(q):\n\n  a = int(eval(input()))\n\n  temp[a-1] += 1\n\nfor i in temp:\n\n  print(('Yes' if i > 0 else 'No')) \nB. import collections\n\nn,k,q = list(map(int, input().split()))\n\ntemp = [k-q for _ in range(n)]\n\na = [int(eval(input())) for _ in range(q)]\n\nfor A in a:\n\n  temp[A-1] += 1\n\nfor i in temp:\n\n  print(('Yes' if i > 0 else 'No'))", "output": "B", "improve_diff": 1.0097640071, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\np = [int(x) for x in input().split()]\n\n\n\nans = 0\n\nfor i in range(N):\n\n  if i < N - 1 and p[i] == i + 1:\n\n    p[i] = p[i+1]\n\n    p[i+1] = i+1\n\n    ans += 1\n\n  elif i == N -1 and p[i] == i+1:\n\n    p[i] = p[i-1]\n\n    p[i-1] = i + 1\n\n    ans += 1\n\nprint(ans) \nB. N = int(eval(input()))\n\np = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(N):\n\n    if p[i]-1 == i:\n\n        if i + 1 <= N-1:\n\n            p[i] = p[i+1]\n\n            p[i+1] = i + 1\n\n            ans += 1\n\n        elif i - 1 >= 0:\n\n            p[i] = p[i-1]\n\n            p[i-1] = i + 1\n\n            ans += 1\n\nprint(ans)", "output": "A", "improve_diff": 1.0398420914, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\ndef S(a,b,c):\n\n\ts = (a+b+c)/2\n\n\treturn math.sqrt(s*(s-a)*(s-b)*(s-c))\n\n\t\n\nwhile True:\n\n\ttry:\n\n\t\tx1,y1,x2,y2,x3,y3,xp,yp = list(map(float, input().split()))\n\n\t\ta = math.sqrt((x1-x2)**2+(y1-y2)**2)\n\n\t\tb = math.sqrt((x1-x3)**2+(y1-y3)**2)\n\n\t\tc = math.sqrt((x2-x3)**2+(y2-y3)**2)\n\n\t\txa = math.sqrt((x3-xp)**2+(y3-yp)**2)\n\n\t\txb = math.sqrt((x2-xp)**2+(y2-yp)**2)\n\n\t\txc = math.sqrt((x1-xp)**2+(y1-yp)**2)\n\n\t\tif S(a,xb,xc)+S(b,xc,xa)+S(c,xa,xb)-S(a,b,c) > 0.0000001:\n\n\t\t\tprint(\"NO\")\n\n\t\telse:\n\n\t\t\tprint(\"YES\")\n\n\texcept:\n\n\t\tbreak \nB. import math\n\n\n\ndef L(x1,y1,x2,y2):\n\n\treturn math.sqrt((x1-x2)**2+(y1-y2)**2)\n\n\t\n\ndef S(a,b,c):\n\n\ts=(a+b+c)/2\n\n\treturn math.sqrt(s*(s-a)*(s-b)*(s-c))\n\n\t\n\nwhile True:\n\n    try:\n\n        x1,y1,x2,y2,x3,y3,xp,yp = list(map(float, input().split()))\n\n        a  = L(x1,y1,x2,y2)\n\n        b  = L(x1,y1,x3,y3)\n\n        c  = L(x2,y2,x3,y3)\n\n        pa = L(x3,y3,xp,yp)\n\n        pb = L(x2,y2,xp,yp)\n\n        pc = L(x1,y1,xp,yp)\n\n        if S(a,pb,pc)+S(b,pc,pa)+S(c,pa,pb)-S(a,b,c) > 0.0000001:\n\n            print(\"NO\")\n\n        else:\n\n            print(\"YES\")\n\n    except:\n\n        break", "output": "B", "improve_diff": 1.0240002985, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. num = int(eval(input()))\n\nnums = list(map(int,input().split()))\n\nnums.sort()\n\nans = 1\n\nfor i in nums:\n\n    if i == 0:\n\n        ans = 0\n\n        break\n\n    ans *= i\n\n    if ans > 10 **18:\n\n        ans = -1\n\n        break\n\nprint(ans)\n \nB. n = int(eval(input()))\n\na = [int(_) for _ in input().split()]\n\na.sort()\n\nans = 1\n\nfor i in a:\n\n    if i == 0:\n\n        ans = 0\n\n        break\n\n    ans *= i\n\n    if ans > 10**18:\n\n        ans = -1\n\n        break\n\n \n\nprint(ans)", "output": "A", "improve_diff": 1.0189431551, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nsys.setrecursionlimit(10**7)\n\ndef I(): return int(sys.stdin.readline().rstrip())\n\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\n\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #\n\ndef S(): return sys.stdin.readline().rstrip()\n\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #\n\ndef LS2(): return list(sys.stdin.readline().rstrip())  #\n\n\n\n\n\nN = I()\n\nmod = 10**9+7\n\nprint(((pow(10,N,mod)-2*pow(9,N,mod)+pow(8,N,mod)) % mod))\n \nB. import sys\n\ndef I(): return int(sys.stdin.readline().rstrip())\n\n\n\n\n\nN = I()\n\nmod = 10**9+7\n\nprint(((pow(10,N,mod)-2*pow(9,N,mod)+pow(8,N,mod)) % mod))\n", "output": "B", "improve_diff": 1.0137175516, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nn, p, score = N, 2, 0\n\nwhile p ** 2 <= N:\n\n  e = 1\n\n  while n >= (p ** e) and n % (p ** e) == 0:\n\n    n //= (p ** e)\n\n    score += 1\n\n    e += 1\n\n  else:\n\n    while n >= p and n % p == 0:\n\n      n //= p\n\n    p += 1\n\nelse:\n\n  if n != 1:\n\n    score += 1\n\nprint(score) \nB. N = int(eval(input()))\n\nn, p, score = N, 2, 0\n\nwhile p ** 2 <= N:\n\n  e = 1\n\n  while n % (p ** e) == 0:\n\n    n //= (p ** e)\n\n    score += 1\n\n    e += 1\n\n  else:\n\n    while n % p == 0:\n\n      n //= p\n\n    p += 1\n\nelse:\n\n  if n != 1:\n\n    score += 1\n\nprint(score)", "output": "A", "improve_diff": 1.2107491528, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from heapq import heapify, heappush, heappop\n\nfrom heapq import _heapify_max, _heappop_max\n\nimport heapq\n\n\n\ndef _heappush_max(heap, item):\n\n    heap.append(item)\n\n    heapq._siftdown_max(heap, 0, len(heap)-1)\n\n\n\n\"\"\"\n\nmethod:\n\n    heapify(x): \n\n    heappush(heap, item): itemheappush\n\n    heappop(heap): heap IndexError\n\nnote:\n\n    max heapprefix: _ suffix: _max\n\n\"\"\"\n\ndef main():\n\n    n, m = list(map(int, input().split()))\n\n    h = [0] + list(map(int, input().split()))\n\n    ans = [[] for _ in range(n+1)]\n\n    for _ in range(m):\n\n        a, b = list(map(int, input().split()))\n\n        _heappush_max(ans[a], h[b])\n\n        _heappush_max(ans[b], h[a])\n\n    out = 0\n\n    for ai, hi in zip(ans[1:], h[1:]):\n\n        if (not ai) or hi > _heappop_max(ai):\n\n            out += 1\n\n    print(out)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. def main():\n\n    n, m = list(map(int, input().split()))\n\n    h = list(map(int, input().split()))\n\n    to = [0]*(n+1)\n\n    ans = 0\n\n    for _ in range(m):\n\n        a, b = list(map(int, input().split()))\n\n        to[a] = max(to[a], h[b-1])\n\n        to[b] = max(to[b], h[a-1])\n\n    for i, hi in enumerate(h, 1):\n\n        t = to[i]\n\n        if t == 0 or hi > t:\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.3990789546, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nMOD = 10**9+7\n\nN, M = list(map(int, input().split()))\n\ns = np.array(input().split(), dtype=np.int32)\n\nt = np.array(input().split(), dtype=np.int32)\n\n\n\ndp = np.zeros((N+1,M+1), dtype=np.int64)\n\ndp[0] = 1\n\n\n\nfor i in range(N):\n\n  same = (s[i]==t)\n\n  dp[i+1,1:][same] = dp[i,:-1][same]\n\n  dp[i+1] = (dp[i+1].cumsum()+dp[i])%MOD\n\n\n\nprint((dp[-1,-1]))\n \nB. N, M = list(map(int, input().split()))\n\ns = [int(c) for c in input().split()]\n\nt = [int(c) for c in input().split()]\n\nMOD = 10**9+7\n\n\n\ndp = [[0]*(M+1) for i in range(N+1)]\n\ndp_cum = [[0]*(M+1) for i in range(N+1)]\n\n\n\ndp[0][0] = 1\n\nfor i in range(N+1):\n\n  dp_cum[i][0] = 1\n\nfor j in range(M+1):\n\n  dp_cum[0][j] = 1\n\n  \n\nfor i in range(N):\n\n  for j in range(M):\n\n    if s[i]!=t[j]:\n\n      dp[i+1][j+1] = 0\n\n    else:\n\n      dp[i+1][j+1] = dp_cum[i][j]\n\n    dp_cum[i+1][j+1] = dp_cum[i][j+1] + dp_cum[i+1][j] - dp_cum[i][j] + dp[i+1][j+1]\n\n    dp_cum[i+1][j+1] %= MOD\n\n\n\nprint((dp_cum[-1][-1]))", "output": "B", "improve_diff": 10.7849679542, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import reduce\ndef main():\n\n    from math import gcd\n\n    from functools import reduce\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    m = max(a)\n\n\n\n    d = [0] * (m + 1)\n\n    d[1] = 1\n\n    for i in range(2, m + 1):\n\n        for j in range(i, m + 1, i):\n\n            if d[j] == 0:\n\n                d[j] = i\n\n\n\n    def primes(x):\n\n        ps = set()\n\n        while x != 1:\n\n            p = d[x]\n\n            ps.add(p)\n\n            x = x // d[x]\n\n        return ps\n\n\n\n    b = set()\n\n    f = 0\n\n    for i in a:\n\n        ps = primes(i)\n\n        if b & ps:\n\n            f = 1\n\n            break\n\n        b |= ps\n\n    if f > 0 and reduce(gcd, a) != 1:\n\n        f = 2\n\n\n\n    ans = [\"pairwise coprime\", \"setwise coprime\", \"not coprime\"][f]\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    m = max(a)\n\n\n\n    d = [0] * (m + 1)\n\n    d[1] = 1\n\n    for i in range(2, m + 1):\n\n        for j in range(i, m + 1, i):\n\n            if d[j] == 0:\n\n                d[j] = i\n\n\n\n    def primes(x):\n\n        ps = set()\n\n        while x != 1:\n\n            p = d[x]\n\n            ps.add(p)\n\n            x = x // d[x]\n\n        return ps\n\n\n\n    b = set()\n\n    c = primes(a[0])\n\n    f = 0\n\n    for i in a:\n\n        ps = primes(i)\n\n        if f == 0:\n\n            if b & ps:\n\n                f = 1\n\n            b |= ps\n\n        c &= ps\n\n    else:\n\n        if f == 1 and len(c) > 0:\n\n            f = 2\n\n    \n\n    ans = [\"pairwise coprime\", \"setwise coprime\", \"not coprime\"][f]\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.715342498, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. Tmp = []\n\nTmp  = input().rstrip().split(' ')\n\n\n\nA = int(Tmp[0])\n\nB = int(Tmp[1])\n\n\n\nAns = 0\n\nData = A\n\nwhile Data <= B:\n\n    C = Data // 10000\n\n    D = (Data - C * 10000 )// 1000\n\n    E = Data // 100\n\n    F = (Data - E * 100 )// 10\n\n    G = Data % 10\n\n    if (C==G) and (D==F):\n\n        Ans += 1    \n\n    Data += 1 \n\n\n\nprint(Ans)\n \nB. \n\nA, B=list(map(int,input().split()))\n\n\n\nN = B - A + 1\n\nAns = 0\n\n\n\nfor i in range(N):\n\n  TmpN = A + i\n\n  S = str(TmpN)\n\n  if S[0]==S[4] and S[1]==S[3]:\n\n    Ans += 1\n\n\n\nprint(Ans)\n\n  \n\n  \n\n\n", "output": "B", "improve_diff": 1.2364604882, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nABC = []\n\nfor _ in range(N):\n\n        a,b,c = list(map(int,input().split()))\n\n        ABC.append((a,b,c))\n\n\n\ndpA = [ABC[0][0]]*N\n\ndpB = [ABC[0][1]]*N\n\ndpC = [ABC[0][2]]*N\n\n\n\nfor i in range(1, N):\n\n        dpA[i] = max(dpB[i-1] + ABC[i][0], dpC[i-1] + ABC[i][0])\n\n        dpB[i] = max(dpA[i-1] + ABC[i][1], dpC[i-1] + ABC[i][1])\n\n        dpC[i] = max(dpA[i-1] + ABC[i][2], dpB[i-1] + ABC[i][2])\n\nprint((max(dpA[N-1], dpB[N-1], dpC[N-1]))) \nB. N = int(eval(input()))\n\nfor i in range(N):\n\n        a,b,c = list(map(int,input().split()))\n\n        if i == 0:\n\n                preA = a\n\n                preB = b\n\n                preC = c\n\n        else:\n\n                A = max(preB + a, preC + a)\n\n                B = max(preA + b, preC + b)\n\n                C = max(preA + c, preB + c)\n\n                preA = A\n\n                preB = B\n\n                preC = C\n\nprint((max(preA, preB, preC)))", "output": "B", "improve_diff": 1.0185862077, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\ndef resolve():\n\n    INF = 10 ** 18\n\n    N, M = list(map(int, input().split()))\n\n\n\n    Cost = [0] * M\n\n    Box_key = [0] * M\n\n    for i in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        Cost[i] = a\n\n        C = list(map(int, input().split()))\n\n        Box_key[i] = sum(1 << (c - 1) for c in C)\n\n\n\n    # dp[ i ][ S ] :=  i \n\n    #  S \n\n    dp = [[INF] * (1 << N) for _ in range(M + 1)]\n\n    dp[0][0] = 0\n\n\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])\n\n            dp[i + 1][j | Box_key[i]] = min(dp[i + 1][j | Box_key[i]], dp[i][j] + Cost[i])\n\n\n\n    if dp[M][(1 << N) - 1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[M][(1 << N) - 1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    resolve() \nB. \n\ndef resolve():\n\n    INF = 10 ** 18\n\n    N, M = list(map(int, input().split()))\n\n\n\n    Box_key = []\n\n    for i in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        C = list(map(int, input().split()))\n\n        s = sum(1 << (c - 1) for c in C)\n\n        Box_key.append((s, a))\n\n\n\n    # dp[i]: i\n\n    dp = [INF] * (1 << N)\n\n    dp[0] = 0\n\n\n\n    for s in range(1 << N):\n\n        for i in range(M):\n\n            ns = s | Box_key[i][0]\n\n            cost = dp[s] + Box_key[i][1]\n\n            dp[ns] = min(dp[ns], cost)\n\n\n\n    if dp[(1 << N) - 1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[(1 << N) - 1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()", "output": "B", "improve_diff": 1.0339824543, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nn = int(eval(input()))\n\nif n < 357:\n\n  print((0))\n\n  sys.exit()\n\n\n\ndef dfs(s): \n\n  if int(s) > n:\n\n    return 0\n\n  ret = 1 if all(s.count(c) > 0 for c in '753') else 0\n\n  for c in '753':\n\n    ret += dfs(s + c)\n\n  return ret\n\n\n\nprint((dfs('0')))  \nB. #!/usr/bin/env python3\n\nimport sys\n\nimport itertools\n\n\n\ndef solve(N: int):\n\n    LEN = len(str(N))\n\n    if LEN <= 2:\n\n        print((0))\n\n        return\n\n\n\n    answer = 0\n\n    for i in range(3,LEN+1):\n\n        for num in list(itertools.product(['3','5','7'], repeat=i)):\n\n\n\n            if num.count('3') >= 1 and num.count('5')>=1 and num.count('7') >=1 and int(''.join(num))<=N:\n\n                answer +=1\n\n\n\n    print(answer)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    solve(N)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.356980176, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC100 C - *3 or /2\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(N):\n\n    x = 0\n\n    t = 0\n\n    x = A[i]\n\n    while x%2==0:\n\n        x = x//2\n\n        t += 1\n\n    ans += t\n\nprint(ans) \nB. def count(x):\n\n    cnt=0\n\n    while x!=0:\n\n        if x%2==0:\n\n            x//=2\n\n            cnt+=1\n\n        else:\n\n            break\n\n    return cnt\n\nn=int(eval(input()))\n\na=list(map(int,input().split()))\n\nans=0\n\nfor aa in a:\n\n    if aa%2==0:\n\n        ans+=count(aa)\n\nprint(ans)\n\n\n", "output": "A", "improve_diff": 1.015298107, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M = list(map(int,input().split()))\n\nX = sorted(map(int,input().split()))\n\nD = sorted(x2-x1 for x1,x2 in zip(X,X[1:]))[::-1]\n\nprint((sum(D[N-1:]))) \nB. N,M = list(map(int,input().split()))\n\nX = sorted(list(map(int,input().split())))\n\nD = sorted([X[n+1]-X[n] for n in range(M-1)])\n\n\n\nif M<=N:\n\n  print((0))\n\nelse:\n\n  print((sum(D[:M-N])))", "output": "B", "improve_diff": 1.0133603625, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nn, p, score = N, 2, 0\n\nwhile p ** 2 <= N:\n\n  e = 1\n\n  while n % (p ** e) == 0:\n\n    n //= (p ** e)\n\n    score += 1\n\n    e += 1\n\n  else:\n\n    while n % p == 0:\n\n      n //= p\n\n    p = p + 1 if p == 2 else p + 2\n\nelse:\n\n  if n != 1:\n\n    score += 1\n\nprint(score) \nB. N = int(eval(input()))\n\nn, p, score = N, 2, 0\n\nwhile p ** 2 <= N:\n\n  e = 1\n\n  while n % (p ** e) == 0:\n\n    n //= (p ** e)\n\n    score += 1\n\n    e += 1\n\n  else:\n\n    while n % p == 0:\n\n      n //= p\n\n    p += 1\n\nelse:\n\n  if n != 1:\n\n    score += 1\n\nprint(score)", "output": "A", "improve_diff": 1.5652102948, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nimport sys\n\ninput = sys.stdin.buffer.readline\n\nans = {}\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    for i in range(n):\n\n        dic = {}\n\n        for a in input().strip():\n\n            if a in dic:\n\n                dic[a] += 1\n\n            else:\n\n                dic[a] = 1\n\n        dic2 = tuple(sorted(dic.items()))\n\n        #print(dic2)\n\n        tmp = \"\"\n\n        for k, v in dic2:\n\n            tmp += str(k) + str(v)\n\n        if tmp in ans:\n\n            ans[tmp] += 1\n\n        else:\n\n            ans[tmp] = 1\n\n    su = 0\n\n    for vv in list(ans.values()):\n\n        su += vv * (vv -1) // 2\n\n    print(su)\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    dic = {}\n\n    for i in range(n):\n\n        a = ''.join(sorted(input().rstrip()))\n\n        if a in dic:\n\n            dic[a] += 1\n\n        else:\n\n            dic[a] = 1\n\n    su = 0\n\n    for v in list(dic.values()):\n\n        su += v * (v - 1) // 2\n\n    print(su)\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.4460645635, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import gcd\n\n\n\na = int(eval(input()))\n\n\n\ndef main():\n\n    for i in range(1, a+1):\n\n        for j in range(i, a+1):\n\n            ab = gcd(i, j)\n\n            for k in range(j, a+1):\n\n                x = len({i, j, k})\n\n                if x == 1:\n\n                    x = 1\n\n                elif x == 2:\n\n                    x = 3\n\n                else:\n\n                    x = 6\n\n                yield gcd(ab, k) * x\n\n\n\nprint((sum(main())))\n\n\n \nB. from math import gcd\n\nfrom functools import lru_cache\n\nfrom itertools import combinations\n\n\n\na = int(eval(input()))\n\n\n\ndef main():\n\n    for i in range(1, a+1):\n\n        for j in range(i, a+1):\n\n            for k in range(j, a+1):\n\n                x = len({i, j, k})\n\n                if x == 1:\n\n                    x = 1\n\n                elif x == 2:\n\n                    x = 3\n\n                else:\n\n                    x = 6\n\n                yield gcd(gcd(i, j), k) * x\n\n\n\nprint((sum(main())))\n\n\n", "output": "A", "improve_diff": 1.307026203, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n \n\ndef combination(n, k):\n\n    return math.factorial(n) // math.factorial(k) // math.factorial(n - k)\n\n \n\n\n\nn,p = list(map(int,input().split()))\n\n\n\nt = list(map(int,input().split()))\n\n\n\ngu = 0\n\n\n\nki = 0\n\n\n\nfor i in t:\n\n    if i%2==0:\n\n        gu += 1\n\n    else:\n\n        ki += 1\n\n\n\ngukumi = 0\n\n\n\nkikumi = 0\n\n\n\nfor i in range(1,gu+1):\n\n    gukumi += combination(gu,i)\n\n\n\nif p == 0:\n\n    for i in range(2,ki+1,2):\n\n        kikumi += combination(ki,i)\n\n    ans = kikumi+1+gukumi\n\nelse:\n\n    for i in range(1,ki+1,2):\n\n        kikumi += combination(ki,i)\n\n    ans = kikumi\n\n    \n\n\n\nans += gukumi*kikumi\n\n\n\nprint(ans) \nB. import math\n\n \n\ndef combination(n, k):\n\n    return math.factorial(n) // math.factorial(k) // math.factorial(n - k)    \n\n\n\nN,P = list(map(int,input().split()))\n\n\n\nA = list(map(int,input().split()))\n\n\n\nkisu = 0\n\ngusu = 0\n\n\n\nfor a in A:\n\n    if a%2 == 0:\n\n        gusu += 1\n\n    else:\n\n        kisu += 1\n\n\n\nsum_gu = 2**gusu\n\n\n\nif P%2==0:\n\n    sum_ki = 0\n\n    for i in range(2,kisu+1, 2):\n\n        sum_ki += combination(kisu, i)\n\n    sum_ki *= sum_gu\n\n    print((sum_gu+sum_ki))\n\nelse:\n\n    sum_ki = 0\n\n    for i in range(1,kisu+1, 2):\n\n        sum_ki += combination(kisu, i)\n\n    print((sum_gu*sum_ki))", "output": "B", "improve_diff": 1.0191013067, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nn,m = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\nbc =[]\n\nfor i in range(m):\n\n    b,c = list(map(int,input().split()))\n\n    bc.append((b,c))\n\n\n\nbc.sort(key=lambda x:x[1],reverse=True)\n\nnewcard=[]\n\nfor b,c in bc:\n\n    newcard.extend([c]*b)\n\n    if(len(newcard)>=n):\n\n        break\n\na += newcard\n\na.sort(reverse=True)\n\nprint((sum(a[:n]))) \nB. n,m = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\nbc =[]\n\nfor i in range(m):\n\n    b,c = list(map(int,input().split()))\n\n    bc.append((b,c))\n\n\n\nbc.sort(key=lambda x:x[1],reverse=True)\n\nnewcard=[]\n\nfor b,c in bc:\n\n    newcard.extend([c]*b)\n\n    if(len(newcard)>=n):\n\n        break\n\n\n\nsize = min(n,len(newcard))\n\na.sort()\n\nfor i in range(size):\n\n    if(newcard[i]>a[i]):\n\n        a[i]=newcard[i]\n\n    else:\n\n        break\n\nprint((sum(a)))", "output": "A", "improve_diff": 1.0223403502, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M = list(map(int,input().split()))\n\n\n\nA = list(map(int,input().split()))\n\nA.sort(reverse=True)\n\nBC = []\n\nfor _ in range(M):\n\n    B, C = (int(x) for x in input().split())\n\n    BC.append([B, C])\n\nBC = sorted(BC, key=lambda x: -x[1])\n\n\n\nindex = 0\n\n\n\nans = 0\n\n\n\nwhile index < M and len(A) and A[-1] < BC[index][1]:\n\n    b, c = BC[index]\n\n    count = 0\n\n    while len(A) and A[-1] < c and count < b:\n\n        A.pop()\n\n        ans += c\n\n        count += 1\n\n    index += 1\n\nprint((sum(A)+ans)) \nB. import heapq\n\n\n\nn,m = list(map(int,input().split()))\n\n\n\na = list(map(int,input().split()))\n\nbc = []\n\nfor _ in range(m):\n\n    b, c = (int(x) for x in input().split())\n\n    bc.append([b, c])\n\nbc = sorted(bc, key=lambda x: -x[1])\n\n\n\nheapq.heapify(a)\n\n\n\nfor i in range(m):\n\n    count = 0\n\n    if bc[i][1] < a[0]:\n\n        break\n\n    while a[0] < bc[i][1] and count < bc[i][0]:\n\n        heapq.heappop(a)\n\n        heapq.heappush(a,bc[i][1])\n\n        count += 1\n\nprint((sum(a)))", "output": "A", "improve_diff": 1.3548472665, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\n\n\nk=int(eval(input()))\n\n\n\nlunlun=deque(i for i in range(1,10))\n\nfor _ in range(k-1):\n\n  p=lunlun.popleft()\n\n  if p%10!=0:\n\n    lunlun.append(10*p+p%10-1)\n\n  lunlun.append(10*p+p%10)\n\n  if p%10!=9:\n\n    lunlun.append(10*p+p%10+1)\n\nprint((lunlun.popleft())) \nB. k=int(eval(input()))\n\nL=[]\n\ndef f(d,now,L):\n\n  L.append(now)\n\n  \n\n  if d==10:\n\n    return\n\n  \n\n  for j in range(-1,2):\n\n    v=now%10+j\n\n    if 0<=v<=9:\n\n      f(d+1,now*10+v,L)\n\n\n\nfor l in range(1,10):\n\n  f(1,l,L)\n\nL.sort()\n\nprint((L[k-1]))\n\n\n\n      ", "output": "A", "improve_diff": 2.3512267893, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**6)\n\n\n\nN, Q = list(map(int, input().split()))\n\n\n\ng = [[] for _ in range(N+1)]\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\ncnt = [0] * (N+1)\n\nfor i in range(Q):\n\n    p, x = list(map(int, input().split()))\n\n    cnt[p] += x\n\n\n\ndef dfs(v, p, add):\n\n    cnt[v] += add\n\n    for nv in g[v]:\n\n        if nv == p:\n\n            continue\n\n        dfs(nv, v, cnt[v])\n\n\n\ndfs(1, 0, 0)\n\n\n\nprint((' '.join(map(str, cnt[1:]))))      \nB. import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**6)\n\n\n\nN, Q = list(map(int, input().split()))\n\nAB = [[int(x) for x in input().split()] for _ in range(N-1)]\n\nPX = [[int(x) for x in input().split()] for _ in range(Q)]\n\n \n\ng = [[] for _ in range(N+1)]\n\nfor a,b in AB:\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n \n\ncnt = [0] * (N+1)\n\nfor p,x in PX:\n\n    cnt[p] += x\n\n\n\ndef dfs(v, p, add):\n\n    cnt[v] += add\n\n    for nv in g[v]:\n\n        if nv == p:\n\n            continue\n\n        dfs(nv, v, cnt[v])\n\n\n\ndfs(1, 0, 0)\n\n\n\nprint((' '.join(map(str, cnt[1:]))))    ", "output": "A", "improve_diff": 1.0198965347, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import combinations, chain\nfrom functools import reduce\n\n\n\ndef eval_str(string):\n\n    s = string.split(\"+\")\n\n    return int(reduce(lambda x,y: int(x)+int(y), s))\n\n\n\nmystr = input()\n\nallsubsets = lambda n: list(chain(*[combinations(list(range(1,n)), ni) for ni in range(n+1)]))\n\nl = allsubsets(len(mystr))\n\n#for i in xrange(len(l)):\n\n#    l[i] = list(l[i])\n\nmylist = []\n\n#print l\n\nfor x in l:\n\n    s = \"\"\n\n    prev = 0\n\n    for y in x:\n\n        s += mystr[prev:int(y)]\n\n        s += \"+\"\n\n        prev = int(y)\n\n    s += mystr[prev:]\n\n    mylist.append(s)\n\n#print mylist\n\ntot = 0\n\nfor x in mylist:\n\n    tot += eval_str(x)\n\nprint(tot) \nB. def eval(d,mask):\n\n    s = ''\n\n    for i in range(len(mask)):\n\n        s += d[i]\n\n        if mask[i] == '1':\n\n            s += '+'\n\n    s += d[-1]\n\n    l = s.split('+')\n\n    res = sum(map(int,l))\n\n    return res\n\n\n\nd = list(input())\n\ntot = 0\n\nfor i in range(2**(len(d)-1)):\n\n    mask = bin(2**(len(d)-1)+i)[3:]\n\n    tot += eval(d,mask)\n\nprint(tot)", "output": "B", "improve_diff": 1.5736206193, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(1 << 25)\n\nread = sys.stdin.readline\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H):\n\n    '''\n\n    H is number of rows\n\n    AB\n\n    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, read().split())))\n\n    return tuple(map(list, list(zip(*ret))))\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, read().split())))\n\n    return ret\n\n    # return [list(map(int, read().split())) for _ in range(H)] # pypy\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom operator import itemgetter\n\nfrom itertools import product, permutations, combinations\n\nfrom bisect import bisect_left, bisect_right  # , insort_left, insort_right\n\n\n\n# \n\nK, S = read_ints()\n\nX = list(range(K + 1))  # K2500K^2\n\n# X,YZ #\uff08\uff01\uff09\n\nans = 0\n\nfor x in X:\n\n    for y in X:\n\n        z = S - x - y\n\n        if 0 <= z <= K:\n\n            ans += 1\n\nprint(ans)\n \nB. import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # \n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# sub.*\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\ndef read_col(H):\n\n    '''H is number of rows\n\n    AB\n\n    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #'''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, readline().split())))\n\n    return tuple(map(list, zip(*ret)))\n\n\n\n\n\ndef read_tuple(H):\n\n    '''H is number of rows'''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, readline().split())))\n\n    return ret\n\n\n\n\n\ndef read_matrix(H):\n\n    '''H is number of rows'''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(list(map(int, readline().split())))\n\n    return ret\n\n    # return [list(map(int, read().split())) for _ in range(H)] # pypy\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom operator import itemgetter, xor, add\n\nfrom itertools import product, permutations, combinations\n\nfrom bisect import bisect_left, bisect_right  # , insort_left, insort_right\n\nfrom functools import reduce\n\nfrom math import gcd\n\n\n\n\n\ndef lcm(a, b):\n\n    # \n\n    g = gcd(a, b)\n\n    return a // g * b\n\n\n\n\n\nK, S = ints()\n\nans = 0\n\nfor x in range(K + 1):\n\n    for y in range(K + 1):\n\n        z = S - x - y\n\n        if 0 <= z <= K:\n\n            # print(x, y, z)\n\n            ans += 1\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.1034350444, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,W=list(map(int,input().split()))\n\nw,v=[],[]\n\nfor i in range(N):\n\n  a,b=list(map(int,input().split()))\n\n  w.append(a)\n\n  v.append(b)\n\ndp=[[0]*(W+1) for i in range(N+1)]\n\nfor i in range(N):\n\n  for j in range(W+1):\n\n      if j-w[i]>=0:\n\n          dp[i+1][j]=dp[i][j-w[i]]+v[i]\n\n      dp[i+1][j]=max(dp[i+1][j],dp[i][j])\n\nprint((dp[N][W])) \nB. N,W=list(map(int,input().split()))\n\nw,v=[],[]\n\nfor i in range(N):\n\n  ww,vv=list(map(int,input().split()))\n\n  w.append(ww)\n\n  v.append(vv)\n\ndp=[[0]*(W+1) for i in range(N+1)]\n\n\n\nfor i in range(N):\n\n  for j in range(W+1):\n\n    if j-w[i]>=0:\n\n      dp[i+1][j]=max(dp[i][j-w[i]]+v[i],dp[i+1][j])\n\n    dp[i+1][j]=max(dp[i+1][j],dp[i][j])\n\n\n\nprint((dp[-1][-1]))\n", "output": "A", "improve_diff": 1.0209862856, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k=list(map(int,input().split()))\n\nD=set(list(map(str,input().split())))\n\n\n\nfor i in range(n,10*n):\n\n    num=set(list(str(i)))\n\n    if i>=n and len(D&num)==0:\n\n        print(i)\n\n        exit() \nB. n,k=list(map(int,input().split()))\n\nD=set(list(map(int,input().split())))\n\n\n\nfor i in range(n,10*n):\n\n    num=set(list(map(int,str(i))))\n\n    if i>=n and len(D&num)==0:\n\n        print(i)\n\n        exit()", "output": "A", "improve_diff": 1.0586873961, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. class SegmentTree():\n\n  def __init__(self, n, oper, e):\n\n    self.n = n\n\n    self.oper = oper\n\n    self.e = e\n\n    self.log = (n - 1).bit_length()\n\n    self.size = 1 << self.log\n\n    self.data = [e] * (2 * self.size)\n\n\n\n  def update(self, k):\n\n    self.data[k] = self.oper(self.data[2 * k], self.data[2 * k + 1])\n\n\n\n  def build(self, arr):\n\n    #assert len(arr) <= self.n\n\n    for i in range(self.n):\n\n      self.data[self.size + i] = arr[i]\n\n    for i in range(self.size-1,0,-1):\n\n      self.update(i)\n\n\n\n  def set(self, p, x):\n\n    #assert 0 <= p < self.n\n\n    p += self.size\n\n    self.data[p] = x\n\n    for i in range(self.log):\n\n      p >>= 1\n\n      self.update(p)\n\n\n\n  def get(self, p):\n\n    #assert 0 <= p < self.n\n\n    return self.data[p + self.size]\n\n\n\n  def prod(self, l, r):\n\n    #assert 0 <= l <= r <= self.n\n\n    sml = smr = self.e\n\n    l += self.size\n\n    r += self.size\n\n    while l < r:\n\n      if l & 1:\n\n        sml = self.oper(sml, self.data[l])\n\n        l += 1\n\n      if r & 1:\n\n        r -= 1\n\n        smr = self.oper(self.data[r], smr)\n\n      l >>= 1\n\n      r >>= 1\n\n    return self.oper(sml, smr)\n\n\n\n  def all_prod(self):\n\n    return self.data[1]\n\n\n\n  def max_right(self, l, f):\n\n    #assert 0 <= l <= self.n\n\n    #assert f(self.)\n\n    if l == self.n: return self.n\n\n    l += self.size\n\n    sm = self.e\n\n    while True:\n\n      while l % 2 == 0: l >>= 1\n\n      if not f(self.oper(sm, self.data[l])):\n\n        while l < self.size:\n\n          l = 2 * l\n\n          if f(self.oper(sm, self.data[l])):\n\n            sm = self.oper(sm, self.data[l])\n\n            l += 1\n\n        return l - self.size\n\n      sm = self.oper(sm, self.data[l])\n\n      l += 1\n\n      if (l & -l) == l: break\n\n    return self.n\n\n\n\n  def min_left(self, r, f):\n\n    #assert 0 <= r <= self.n\n\n    #assert f(self.)\n\n    if r == 0: return 0\n\n    r += self.size\n\n    sm = self.e\n\n    while True:\n\n      r -= 1\n\n      while r > 1 and (r % 2): r >>= 1\n\n      if not f(self.oper(self.data[r], sm)):\n\n        while r < self.size:\n\n          r = 2 * r + 1\n\n          if f(self.oper(self.data[r], sm)):\n\n            sm = self.oper(self.data[r], sm)\n\n            r -= 1\n\n        return r + 1 - self.size\n\n      sm = self.oper(self.data[r], sm)\n\n      if (r & -r) == r: break\n\n    return 0\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nfrom math import gcd\n\n\n\ne = 0\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nst = SegmentTree(N,gcd,e)\n\nst.build(A)\n\n\n\nans = max(st.prod(1,N),st.prod(0,N-1))\n\nfor i in range(1,N-1):\n\n  ans = max(ans, gcd(st.prod(0,i),st.prod(i+1,N)))\n\nprint(ans) \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef common_divisor(n):\n\n    cd = []\n\n    for i in range(1,int(n**0.5)+2):\n\n        if n%i==0:\n\n            cd.append(i)\n\n            if i != n//i:\n\n                cd.append(n//i)\n\n    return set(cd)\n\n\n\n#print(cd_dic)\n\ncds = common_divisor(A[0]).union(common_divisor(A[1]))\n\nans = 1\n\nfor k in cds:\n\n    #print(cd_dic)\n\n    cnt = 0\n\n    for a in A:\n\n        if a%k!=0:\n\n            cnt += 1\n\n            if cnt == 2:\n\n                break\n\n    else:\n\n        ans = max(ans,k)\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.3154903328, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC084C - Snuke Festival\n\n# Binary search\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nn = int(eval(input()))\n\nA, B, C = [sorted(list(map(int, input().rstrip().split()))) for _ in range(3)]\n\nlgth = len(C)\n\nans = 0\n\nfor i in B:\n\n    ans += bisect_left(A, i) * (lgth - bisect_right(C, i))\n\nprint(ans) \nB. # ARC084C - Snuke Festival\n\nfrom bisect import bisect_left, bisect_right\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A, B, C = [sorted(tuple(map(int, input().rstrip().split()))) for _ in range(3)]\n\n    l, ans = len(C), 0\n\n    for i in B:\n\n        ans += bisect_left(A, i) * (l - bisect_right(C, i))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.029153918, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import defaultdict\n\nfrom heapq import *\n\nsys.setrecursionlimit(10**8)\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    \"\"\" main \"\"\"\n\n    N = int(eval(input()))\n\n    AS = [int(eval(input())) for _ in range(N)]\n\n    AS_dup = AS[:]\n\n    AS.sort()\n\n    for i in range(N):\n\n        if AS_dup[i] == AS[-1]:\n\n            print((AS[-2]))\n\n        else:\n\n            print((AS[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. n = int(eval(input()))\n\na_list = [int(eval(input())) for _ in range(n)]\n\nsorted_a_list = sorted(a_list)\n\nmax_num = sorted_a_list[-1]\n\nsecond_max_num = sorted_a_list[-2]\n\n\n\nresult = [0]*n\n\nfor i in range(n):\n\n    if a_list[i] == max_num:\n\n        result[i] = second_max_num\n\n    else:\n\n        result[i] = max_num\n\n\n\nfor i in range(n):\n\n    print((result[i]))", "output": "B", "improve_diff": 1.5513288818, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def gcd(n,m):\n\n  a=min(n,m)\n\n  b=max(n,m)\n\n  while a!=0:\n\n    b,a=a,b%a\n\n  return b\n\nn=int(eval(input()))\n\nl=list(map(int,input().split()))\n\nans=l[0]\n\nfor i in range(1,n):\n\n  ans=gcd(ans,l[i])\n\nprint(ans) \nB. n=int(eval(input()))\n\nl=sorted(list(map(int,input().split())))\n\nm=min(l)\n\nl2=[]\n\nl3=[]\n\nfor i in range(1,int(m**(1/2)+1)):\n\n  if m%i==0:                   \n\n    l2.append(i)\n\n    if i!=m//i:\n\n      l2.append(m//i)\n\nfor i in l2:\n\n  b=True\n\n  for j in l:\n\n    if j%i==0:\n\n      pass\n\n    else:\n\n      b=False\n\n  if b:\n\n    l3.append(i)\n\nprint((max(l3)))", "output": "A", "improve_diff": 1.0426533074, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nCSFn = [[int(j) for j in input().split()] for i in range(N - 1)]\n\n\n\n\n\ndef next(s):\n\n    t = 0\n\n\n\n    for Ci, Si, Fi in CSFn[s:]:\n\n        # \n\n        if t < Si:\n\n            t = Si\n\n\n\n        # \n\n        elif t % Fi:\n\n            t += Fi - t % Fi\n\n\n\n        # \n\n        t += Ci\n\n\n\n    return t\n\n\n\n\n\ndef main():\n\n    # \n\n    for i in range(N - 1):\n\n        t = next(i)\n\n        print(t)\n\n\n\n    print((0))\n\n\n\n    return\n\n\n\n\n\nmain()\n \nB. N = int(eval(input()))\n\n\n\nC = []\n\nS = []\n\nF = []\n\n\n\nfor i in range(N - 1):\n\n    c, s, f = list(map(int, input().split()))\n\n    C.append(c)\n\n    S.append(s)\n\n    F.append(f)\n\n\n\n\n\ndef next(s, t):\n\n    # \n\n    if t < S[s]:\n\n        t = S[s]\n\n\n\n    # \n\n    elif t % F[s]:\n\n        t += F[s] - t % F[s]\n\n\n\n    # \n\n    t += C[s]\n\n\n\n    return t\n\n\n\n\n\ndef main():\n\n    # \n\n    for i in range(N - 1):\n\n        t = next(i, 0)\n\n\n\n        # \n\n        for j in range(i + 1, N - 1):\n\n            t = next(j, t)\n\n\n\n        print(t)\n\n\n\n    print((0))\n\n\n\n    return\n\n\n\n\n\nmain()\n", "output": "B", "improve_diff": 1.0409849618, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\nN, T = list(map(int, input().split()))\n\nAB = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for _ in range(N+1)] for _ in range(T+1)]\n\n# wn\n\n\n\nprev = [[0 for _ in range(N+1)] for _ in range(T+1)]\n\n\n\nfor n in range(N): # n\n\n    a, b = AB[n]\n\n    for w in range(T):\n\n        if a > w: # \n\n            dp[w][n+1] = dp[w][n]\n\n            prev[w][n+1] = w\n\n        else: #\n\n            if b+dp[w-a][n] >= dp[w][n]:\n\n                dp[w][n+1] = dp[w-a][n] + b\n\n                prev[w][n+1] = w - a\n\n            else:\n\n                dp[w][n+1] = dp[w][n]\n\n                prev[w][n+1] = w\n\n\n\nans = dp[T-1][N]\n\nused = [False]*N\n\nc = T-1\n\nfor i in reversed(list(range(N))):\n\n    if prev[c][i+1] == c - AB[i][0]:\n\n        used[i] = True\n\n    c = prev[c][i+1]\n\n\n\np = 0\n\nfor i in range(N):\n\n    if not used[i] and AB[i][1] > p:\n\n        p = AB[i][1]\n\n\n\nprint((ans+p)) \nB. import sys\n\ninput = sys.stdin.readline\n\nfrom operator import itemgetter\n\n\n\nN, T = list(map(int, input().split()))\n\nAB = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nAB.sort(key=itemgetter(0))\n\n\n\ndp = [[0 for _ in range(N+1)] for _ in range(T+1)]\n\n# wn\n\nC = []\n\n\n\nfor n in range(N): # n\n\n    a, b = AB[n]\n\n    for w in range(T):\n\n        if a > w: # \n\n            dp[w][n+1] = dp[w][n]\n\n        else: #\n\n            if b+dp[w-a][n] >= dp[w][n]:\n\n                dp[w][n+1] = dp[w-a][n] + b\n\n            else:\n\n                dp[w][n+1] = dp[w][n]\n\n    C.append(dp[T-1][n]+b)\n\n\n\nans = max(C)\n\nprint(ans)", "output": "A", "improve_diff": 1.3062858767, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k,q,*a=list(map(int,open(0).read().split()))\n\ns=sorted\n\nm=1e9\n\nfor b in a:\n\n    i=[i for i,t in enumerate(a)if t<b]\n\n    l=s(sum([s(a[i+1:j])[::-1][k-1:]for i,j in zip([-1]+i,i+[n])],[]))\n\n    if len(l)>=q:m=min(m,l[q-1]-b)\n\nprint(m) \nB. def main():\n\n    N, K, Q, *A = list(map(int, open(0).read().split()))\n\n\n\n    ans = float(\"inf\")\n\n    for Y in set(A):\n\n        C = []\n\n        tmp = []\n\n        for a in A:\n\n            if a >= Y:\n\n                tmp.append(a)\n\n            else:\n\n                if len(tmp) >= K:\n\n                    C += sorted(tmp)[:len(tmp) - K + 1]\n\n                tmp = []\n\n        if len(tmp) >= K:\n\n            C += sorted(tmp)[:len(tmp) - K + 1]\n\n\n\n        if len(C) >= Q:\n\n            C.sort()\n\n            X = C[Q - 1]\n\n            ans = min(ans, X - Y)\n\n\n\n    print(ans)\n\n\n\nmain()", "output": "B", "improve_diff": 1.0221097049, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A = int(eval(input()))\n\nB = int(eval(input()))\n\nC = int(eval(input()))\n\nX = int(eval(input()))\n\n\n\ncnt = 0\n\nfor a in range(A+1):\n\n    for b in range(B+1):\n\n        for c in range(C+1):\n\n            if (a*500 + b*100 + c*50) == X:\n\n                cnt+=1\n\nprint(cnt) \nB. A = int(eval(input()))\n\nB = int(eval(input()))\n\nC = int(eval(input()))\n\nX = int(eval(input()))\n\n\n\ncnt = 0\n\nfor a in range(min([A,-(-X//500)])+1):\n\n    _a = a*500\n\n    for b in range(min([B,-(-X//100)])+1):\n\n        _b = b*100 + _a\n\n        if _b > X: break\n\n        for c in range(min([C,-(-X//50)])+1):\n\n            _c = c*50 + _b\n\n            if _c > X: break\n\n            if _c == X:\n\n                cnt+=1\n\nprint(cnt)", "output": "B", "improve_diff": 1.1633622944, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. if __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    L = sorted(map(int, input().split()))\n\n    ret = 0\n\n    for adx in range(N):\n\n        cdx = adx\n\n        for bdx in range(adx + 1, N):\n\n            while cdx < N and L[cdx] < L[bdx] + L[adx]: cdx += 1\n\n            ret += cdx - (bdx + 1)\n\n    print(ret) \nB. from bisect import *\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    L = sorted(map(int, input().split()))\n\n    print((sum(jdx - bisect(L, a - L[jdx], 0, jdx) for idx, a in enumerate(L) for jdx in range(idx))))", "output": "A", "improve_diff": 1.3501191475, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\ncount = 0\n\nfor i in range(1,N+1):\n\n    yaku = 0\n\n    if i%2 == 1:\n\n        for j in range(1,i+1):\n\n            if i%j == 0:\n\n                yaku += 1\n\n        if yaku == 8:\n\n            count += 1\n\nprint(count) \nB. N = int(eval(input()))\n\ncount = 0\n\nif N<105:\n\n    print((0))\n\nelse:\n\n    for i in range(105,N+1):\n\n        yaku = 0\n\n        if i%2 == 1:\n\n            for j in range(1,i+1):\n\n                if i%j == 0:\n\n                    yaku += 1\n\n            if yaku == 8:\n\n                count += 1\n\n    print(count)", "output": "A", "improve_diff": 1.0575340599, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\n\n\n#Union-Find\n\npar=[-1 for i in range(n)]\n\n\n\ndef root(a):\n\n    if par[a]<0:\n\n        return a\n\n    else:\n\n        return root(par[a])\n\n\n\ndef size(a):\n\n    return -par[root(a)]\n\n\n\ndef connect(a,b):\n\n    a=root(a)\n\n    b=root(b)\n\n    if a==b:\n\n        return False\n\n    if size(a)<size(b):\n\n        a,b=b,a\n\n    par[a]+=par[b]\n\n    par[b]=a\n\n    return True\n\n\n\nxyz=[]\n\nfor i in range(m):\n\n    a=[int(j) for j in input().split()]\n\n    xyz.append([a[0]-1,a[1]-1,a[2]%2])\n\n    if root(a[0]-1)!=root(a[1]-1):\n\n        connect(a[0]-1,a[1]-1)\n\nans=0\n\nfor i in range(n):\n\n    ans+=1/size(i)\n\nprint((round(ans))) \nB. n,m=list(map(int,input().split()))\n\n\n\n#Union-Find\n\npar=[-1 for i in range(n)]\n\n\n\ndef root(a):\n\n    if par[a]<0:\n\n        return a\n\n    else:\n\n        return root(par[a])\n\n\n\ndef size(a):\n\n    return -par[root(a)]\n\n\n\ndef connect(a,b):\n\n    a=root(a)\n\n    b=root(b)\n\n    if a==b:\n\n        return False\n\n    if size(a)<size(b):\n\n        a,b=b,a\n\n    par[a]+=par[b]\n\n    par[b]=a\n\n    return True\n\n\n\nxyz=[]\n\nfor i in range(m):\n\n    a=[int(j) for j in input().split()]\n\n    xyz.append([a[0]-1,a[1]-1,a[2]%2])\n\n    if root(a[0]-1)!=root(a[1]-1):\n\n        connect(a[0]-1,a[1]-1)\n\nans=0\n\nfor i in range(n):\n\n    if par[i]<0:\n\n        ans+=1\n\nprint(ans)", "output": "B", "improve_diff": 1.1184118596, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. H, W = list(map(int,input().split()))\n\n\n\nif(H == 1 or W == 1):\n\n    ans = 1\n\nelse:\n\n    if(H*W%2 != 0):\n\n        ans = H*W//2 + 1\n\n    else:\n\n        ans = H*W//2\n\nprint(ans) \nB. ## coding: UTF-8\n\nfrom decimal import *\n\ns = input().split()\n\nt = [int(p) for p in s]\n\n\n\n\n\n#print(t)\n\nif(t[0] == 1 or t[1] == 1):\n\n    answer = 1\n\nelif( Decimal(Decimal(t[0]) % 2 )== 1 and Decimal(Decimal(t[1]) % 2) == 1):\n\n    n = Decimal( Decimal(Decimal(t[0]) - 1) // 2  )\n\n    #print(n)\n\n    m = Decimal( Decimal(Decimal(t[1]) - 1) // 2  )\n\n    answer = Decimal(    Decimal(  Decimal(Decimal(m) + 1)     *    Decimal(Decimal(n) + 1)  )   + Decimal( Decimal(m) * Decimal(n) )       )\n\nelse:\n\n    answer = Decimal(   Decimal(Decimal(t[0]) * Decimal(t[1])) // 2  )\n\n\n\nprint((int(answer)))\n\n\n\n'''\n\nH = t[0]\n\nW = t[1]\n\nans = 0\n\nif( W % 2 == 0):\n\n    for i in range(H):\n\n        ans += W / 2\n\nelse:\n\n    for i in range(H):\n\n        if(i % 2 == 0):\n\n            ans += W / 2.0 + 0.5\n\n        else:\n\n            ans += W / 2.0 - 0.5\n\nprint(int(ans))\n\n'''\n", "output": "A", "improve_diff": 1.6655404447, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # D - Lunlun Number\n\n\n\nK = int(eval(input()))\n\n\n\nN = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ni = 0\n\n\n\nwhile len(N) < K:\n\n    n = int(str(N[i]) + str(N[i])[-1:])\n\n    if str(n)[-1:] == '0':\n\n        N += [n, n + 1]\n\n    elif str(n)[-1:] == '9':\n\n        N += [n - 1, n]\n\n    else:\n\n        N += [n - 1, n, n + 1]\n\n    i += 1\n\n\n\nprint((N[K - 1])) \nB. # D - Lunlun Number\n\n\n\nK = int(eval(input()))\n\nstack = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ni = 0\n\nwhile len(stack) < K:\n\n    first = int(str(stack[i])[-1:])\n\n    if first == 0:\n\n        stack.append(int(str(stack[i]) + str(first)))\n\n        stack.append(int(str(stack[i]) + str(first + 1)))\n\n    elif first == 9:\n\n        stack.append(int(str(stack[i]) + str(first - 1)))\n\n        stack.append(int(str(stack[i]) + str(first)))\n\n    else:\n\n        stack.append(int(str(stack[i]) + str(first - 1)))\n\n        stack.append(int(str(stack[i]) + str(first)))\n\n        stack.append(int(str(stack[i]) + str(first + 1)))        \n\n    i += 1\n\n\n\nprint((stack[K - 1]))", "output": "A", "improve_diff": 1.2336158332, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nq = int(eval(input()))\n\ntotal = sum(A)\n\n\n\nl = [0 for i in range(10**5+1)]\n\nfor _ in range(n):\n\n    l[A[_]] += 1\n\n\n\nfor i in range(q):\n\n    b, c = list(map(int,input().split()))\n\n    total += (c * l[b])\n\n    total -= (b * l[b])\n\n    print(total)\n\n    l[c] += l[b]\n\n    l[b] = 0\n \nB. n = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nq = int(eval(input()))\n\ntotal = sum(A)\n\n\n\nl = [[i, 0] for i in range(10**5+1)]\n\nfor _ in range(n):\n\n    l[A[_]][1] += 1\n\n\n\nfor i in range(q):\n\n    b, c = list(map(int,input().split()))\n\n    total -= (l[b][0] * l[b][1])\n\n    total += (l[c][0] * l[b][1])\n\n    print(total)\n\n    l[c][1] += l[b][1]\n\n    l[b][1] = 0", "output": "A", "improve_diff": 2.5045990716, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nn, x, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    cnt = 0\n\n    lim = x\n\n    for c in a:\n\n        if c > lim:\n\n            cnt += c - lim\n\n            lim = x - lim\n\n        else:\n\n            lim = x - c\n\n            \n\n    return cnt\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans) \nB. n, x = [int(i) for i in input().split()]\n\na = [int(i) for i in input().split()]\n\n\n\ncount = 0\n\nprevious = 0\n\n\n\nfor i in a:\n\n    if i + previous > x: \n\n        excess = i + previous - x\n\n        count += excess\n\n        previous = x - previous\n\n    else: # if not exceeding x.\n\n        previous = i\n\n\n\nprint(count)\n\n\n", "output": "A", "improve_diff": 1.0451853095, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def dfs(i, a, b, c, plus):\n\n    global ans\n\n\n\n    if i == n:\n\n        if a and b and c:\n\n            mp = abs(a - A) + abs(b - B) + abs(c - C) + (plus - 3) * 10\n\n            ans = min(ans, mp)\n\n\n\n    else:\n\n        dfs(i + 1, a, b, c, plus)\n\n        dfs(i + 1, a + l[i], b, c, plus + 1)\n\n        dfs(i + 1, a, b + l[i], c, plus + 1)\n\n        dfs(i + 1, a, b, c + l[i], plus + 1)\n\n\n\n\n\nn, A, B, C = list(map(int, input().split()))\n\nl = [int(eval(input())) for i in range(n)]\n\n\n\nans = float(\"inf\")\n\n\n\ndfs(0, 0, 0, 0, 0)\n\n\n\nprint(ans) \nB. def dfs(i, A, B, C):\n\n    global ans\n\n    if i == n:\n\n        if A and B and C:\n\n            ans = min(ans, abs(a - sum(A)) + abs(b - sum(B)) + abs(c - sum(C)) + (len(A) + len(B) + len(C) - 3) * 10)\n\n    else:\n\n        dfs(i + 1, A, B, C)\n\n        dfs(i + 1, A + [L[i]], B, C)\n\n        dfs(i + 1, A, B + [L[i]], C)\n\n        dfs(i + 1, A, B, C + [L[i]])\n\n\n\nn, a, b, c = list(map(int, input().split()))\n\nL = [int(eval(input())) for i in range(n)]\n\nans = float(\"inf\")\n\ndfs(0, [], [], [])\n\nprint(ans)", "output": "A", "improve_diff": 1.4391194842, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\n\n\ndef read_int():\n\n    return int(input().strip())\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, input().strip().split(' ')))\n\n\n\n\n\ndef solve():\n\n    # dp[i] = min(abs(h[i]-h[i-1])+dp[i-1], abs(h[i]-h[i-2])+dp[i-2])\n\n    N = read_int()\n\n    h = read_ints()\n\n    dp = [0, abs(h[1]-h[0])]\n\n    for i in range(2, N):\n\n        dp.append(min(abs(h[i]-h[i-1])+dp[i-1], abs(h[i]-h[i-2])+dp[i-2]))\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve()))\n \nB. \n\n\n\ndef read_int():\n\n    return int(input().strip())\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, input().strip().split(' ')))\n\n\n\n\n\ndef solve():\n\n    # dp[i] = min(abs(h[i]-h[i-1])+dp[i-1], abs(h[i]-h[i-2])+dp[i-2])\n\n    N = read_int()\n\n    h = read_ints()\n\n    a, b = 0, abs(h[1]-h[0])\n\n    for i in range(2, N):\n\n        b, a = min(abs(h[i]-h[i-1])+b, abs(h[i]-h[i-2])+a), b\n\n    return b\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((solve()))\n", "output": "B", "improve_diff": 1.0153371003, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b, x = list(map(int, input().split()))\n\nprint((b // x - (a - 1) // x)) \nB. import math\n\na, b, x = list(map(int, input().split()))\n\nprint((b // x - (a - 1) // x))\n", "output": "A", "improve_diff": 1.3151686488, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def is_perfect_power(n):\n\n    if n == 1:\n\n        return True\n\n    div = 2\n\n    divs = []\n\n    while n != 1:\n\n        if n % div == 0:\n\n            n //= div\n\n            divs.append(div)\n\n        else:\n\n            div += 1\n\n    divs_d = {d: 0 for d in set(divs)}\n\n    for d in divs:\n\n        divs_d[d] += 1\n\n    divs_s = {n for n in list(divs_d.values())}\n\n    if min(divs_s) > 1:\n\n        for d in divs_s:\n\n            if d % min(divs_s) != 0:\n\n                return False\n\n    else:\n\n        return False\n\n    return True\n\n\n\n\n\nX = int(eval(input()))\n\nfor x in range(X, 0, -1):\n\n    if is_perfect_power(x):\n\n        print(x)\n\n        break\n \nB. def is_perfect_power(n):\n\n    return n in {\n\n        1, 4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81, 100, 121, 125, 128, 144,\n\n        169, 196, 216, 225, 243, 256, 289, 324, 343, 361, 400, 441, 484, 512,\n\n        529, 576, 625, 676, 729, 784, 841, 900, 961, 1000\n\n    }\n\n\n\n\n\nX = int(eval(input()))\n\nfor x in range(X, 0, -1):\n\n    if is_perfect_power(x):\n\n        print(x)\n\n        break\n", "output": "B", "improve_diff": 1.0298619323, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n# import re\n\nimport math\n\nimport collections\n\n# import decimal\n\nimport bisect\n\nimport itertools\n\nimport fractions\n\n# import functools\n\nimport copy\n\nimport heapq\n\nimport decimal\n\n# import statistics\n\nimport queue\n\n# import numpy as np\n\n\n\n# sys.setrecursionlimit(10000001)\n\nINF = 10 ** 16\n\n# MOD = 10 ** 9 + 7\n\nMOD = 998244353\n\n\n\n\n\ndef ni(): return int(sys.stdin.readline())\n\ndef ns(): return list(map(int, sys.stdin.readline().split()))\n\ndef na(): return list(map(int, sys.stdin.readline().split()))\n\n\n\n\n\n# ===CODE===\n\n\n\nclass ModCombination:\n\n    # https://atcoder.jp/contests/abc167/submissions/13058694\n\n    # https://ikatakos.com/pot/programming_algorithm/number_theory/mod_combination\n\n\n\n    def __init__(self, maxN, MOD):\n\n        self._maxN = maxN\n\n        self._MOD = MOD\n\n        self.facts = [1]\n\n        self.invs = [1]*(self._maxN+1)\n\n\n\n        fact = 1\n\n        for i in range(1, self._maxN+1):\n\n            fact *= i\n\n            fact %= self._MOD\n\n            self.facts.append(fact)\n\n\n\n        inv = pow(fact, self._MOD-2, self._MOD)\n\n        self.invs[self._maxN] = inv\n\n        for i in range(self._maxN, 1, -1):\n\n            inv *= i\n\n            inv %= self._MOD\n\n            self.invs[i-1] = inv\n\n\n\n    def nCr(self, n, r):\n\n        return self.facts[n]*self.invs[r]*self.invs[n-r] % self._MOD\n\n\n\n\n\ndef main():\n\n\n\n    n, m, k = ns()\n\n\n\n    mc = ModCombination(n, MOD)\n\n\n\n    result = 0\n\n\n\n    for ki in range(k + 1):\n\n        ans = 1\n\n        ans *= m % MOD\n\n        ans *= pow(m - 1, n - 1 - ki, MOD)\n\n        ans %= MOD\n\n        ans *= mc.nCr(n-1, ki)\n\n        ans %= MOD\n\n        result += ans\n\n        result %= MOD\n\n\n\n    print(result)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\n\n\n# import re\n\nimport math\n\nimport collections\n\n# import decimal\n\nimport bisect\n\nimport itertools\n\nimport fractions\n\n# import functools\n\nimport copy\n\nimport heapq\n\nimport decimal\n\n# import statistics\n\nimport queue\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10000001)\n\nINF = 10 ** 16\n\n# MOD = 10 ** 9 + 7\n\nMOD = 998244353\n\n\n\nni = lambda: int(sys.stdin.readline())\n\nns = lambda: list(map(int, sys.stdin.readline().split()))\n\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n\n\n\n# ===CODE===\n\n\n\n\n\ndef main():\n\n    def fast_pow(num, kata, mod):\n\n        if kata == 0:\n\n            return 1\n\n\n\n        res = 1\n\n        while kata > 0:\n\n            if kata & 1 == 1:\n\n                res = res * num % mod\n\n            num = num * num % mod\n\n\n\n            kata >>= 1\n\n        return res\n\n\n\n    def prepare(n, MOD):\n\n        f = 1\n\n        factorials = [1]\n\n        for m in range(1, n + 1):\n\n            f *= m\n\n            f %= MOD\n\n            factorials.append(f)\n\n        inv = pow(f, MOD - 2, MOD)\n\n        invs = [1] * (n + 1)\n\n        invs[n] = inv\n\n        for m in range(n, 1, -1):\n\n            inv *= m\n\n            inv %= MOD\n\n            invs[m - 1] = inv\n\n        return factorials, invs\n\n\n\n    n, m, k = ns()\n\n\n\n    p, i = prepare(n, MOD)\n\n\n\n    result = 0\n\n\n\n    for ki in range(k + 1):\n\n        ans = 1\n\n        ans *= m % MOD\n\n        ans *= fast_pow(m - 1, n - 1 - ki, MOD)\n\n        ans %= MOD\n\n        ans *= p[n - 1] * i[ki] * i[n - 1 - ki]\n\n        ans %= MOD\n\n\n\n        result += ans\n\n        result %= MOD\n\n\n\n    print(result)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 3.5014559509, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\ndef check(vec, init_pos, target_pos):\n\n    base = 8000\n\n    dp = [False] * 16001\n\n    dp[init_pos + base] = True\n\n\n\n    for i in range(len(vec)):\n\n        dp, dp_prev = [False] * 16001, dp\n\n        for j in range(16001):\n\n            if (\n\n                j - vec[i] >= 0\n\n                and dp_prev[j - vec[i]]\n\n                or j + vec[i] <= 16000\n\n                and dp_prev[j + vec[i]]\n\n            ):\n\n                dp[j] = True\n\n\n\n    return dp[target_pos + base]\n\n\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    x, y = list(map(int, readline().split()))\n\n\n\n    idx = len(S)\n\n    for i, c in enumerate(S):\n\n        if c == 'T':\n\n            idx = i\n\n            break\n\n\n\n    init_x = idx\n\n    step = [[0] for _ in range(2)]\n\n    i = 0\n\n    for c in S[idx:]:\n\n        if c == 'T':\n\n            i = 1 - i\n\n            step[i].append(0)\n\n        else:\n\n            step[i][-1] += 1\n\n\n\n    ok = check(step[0], init_x, x) and check(step[1], 0, y)\n\n\n\n    if ok:\n\n        print('Yes')\n\n    else:\n\n        print('No')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\ndef check(vec, init_pos, target_pos):\n\n    base = 8000\n\n    dp = [False] * 16001\n\n    dp[init_pos + base] = True\n\n\n\n    for i in range(len(vec)):\n\n        dp, dp_prev = [False] * 16001, dp\n\n        for j in range(16001):\n\n            if (\n\n                j - vec[i] >= 0\n\n                and dp_prev[j - vec[i]]\n\n                or j + vec[i] <= 16000\n\n                and dp_prev[j + vec[i]]\n\n            ):\n\n                dp[j] = True\n\n\n\n    return dp[target_pos + base]\n\n\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    x, y = list(map(int, readline().split()))\n\n\n\n    idx = len(S)\n\n    for i, c in enumerate(S):\n\n        if c == 'T':\n\n            idx = i\n\n            break\n\n\n\n    init_x = idx\n\n    step = [[] for _ in range(2)]\n\n    i = 0\n\n    for c in S[idx:]:\n\n        if c == 'T':\n\n            i = 1 - i\n\n            step[i].append(0)\n\n        else:\n\n            step[i][-1] += 1\n\n            \n\n    for row in step:\n\n        row = [v for v in row if v != 0]\n\n        if not row:\n\n            row = [0]\n\n\n\n    ok = check(step[0], init_x, x) and check(step[1], 0, y)\n\n\n\n    if ok:\n\n        print('Yes')\n\n    else:\n\n        print('No')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.2657513589, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))  #,\uff11\n\nA = []\n\n\n\nfor i in range(1, n + 1):\n\n    if i % 15 == 0:\n\n        A.append(0)\n\n    elif i % 3 == 0:\n\n        A.append(0)\n\n    elif i % 5 == 0:\n\n        A.append(0)\n\n    else:\n\n        A.append(i)\n\n\n\nprint((sum(A))) \nB. N = int(eval(input()))  #,\uff11\n\n \n\nA = []\n\nfor i in range(1,N+1):\n\n  if i % 3 == 0:\n\n    A.append(0)\n\n  elif i % 5 == 0:\n\n    A.append(0)\n\n  else:\n\n    A.append(i)\n\n\n\nprint((sum(A)))", "output": "B", "improve_diff": 1.189597966, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k,*v=list(map(int,open(0).read().split()))\n\nmotimono=[]\n\nans=[]\n\nv*=2\n\nfor j in range(1,min(n,k)+1):\n\n    for i in range(n-j,n+1):\n\n        motimono=v[i:i+j]\n\n        ans.append(sum(motimono))\n\n        motimono.sort()\n\n        for i in range(k-j):\n\n            if len(motimono)>0:\n\n                del motimono[0]\n\n            ans.append(sum(motimono))\n\nprint((max(ans))) \nB. n,k,*v=list(map(int,open(0).read().split()))\n\nmotimono=[]\n\nans=[]\n\nv*=2\n\nfor j in range(1,min(n,k)+1):\n\n    for i in range(n-j,n+1):\n\n        motimono=v[i:i+j]\n\n        ans.append(sum(motimono))\n\n        motimono.sort()\n\n        for i in range(min(k-j,j)):\n\n            del motimono[0]\n\n            ans.append(sum(motimono))\n\nprint((max(ans)))\n", "output": "B", "improve_diff": 1.020929612, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b = list(map(int, input().split()))\n\n\n\nd = 0\n\nfor i in range(a, b+1):\n\n    c = str(i)\n\n    e = True\n\n    for j in range(len(c)//2):\n\n        if c[j] != c[-j-1] and e:\n\n            e = not e\n\n    if e:\n\n        d += 1\n\nprint(d)\n \nB. a, b = list(map(int, input().split()))\n\nd = 0\n\nfor i in range(a, b+1):\n\n    c = str(i)\n\n    if c[0] == c[-1] and c[1] == c[-2]:\n\n        d += 1\n\nprint(d)\n", "output": "B", "improve_diff": 1.5725158848, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nfrom scipy.sparse import csr_matrix\n\nfrom scipy.sparse.csgraph import connected_components\n\n\n\n\n\ndef create_graph(V: int, edges: np.array, dtype=None):\n\n    \"\"\"csr_matrix \n\n\n\n     dtype=object \n\n    \"\"\"\n\n    return csr_matrix((edges[:, 2], (edges[:, 0], edges[:, 1])),\n\n                      shape=(V, V), dtype=dtype)\n\n\n\n\n\ndef main() -> None:\n\n    N, M = list(map(int, input().split()))\n\n    edges = []\n\n    adj_list = [[] for _ in range(N)]\n\n    for _ in range(M):\n\n        x, y = list(map(int, input().split()))\n\n        edges.append([x-1, y-1, 1])\n\n        adj_list[x-1].append(y-1)\n\n    graph = create_graph(N, np.asarray(edges))\n\n    _, labels = connected_components(\n\n        csgraph=graph, directed=True,\n\n        connection=\"strong\", return_labels=True)\n\n    order = [(x, i) for i, x in enumerate(labels)]\n\n    order.sort(reverse=True)\n\n    dp = [0] * N\n\n    for _, i in order:\n\n        for v in adj_list[i]:\n\n            dp[v] = max(dp[v], dp[i] + 1)\n\n    print((max(dp)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nsys.setrecursionlimit(2*10**5)\n\n\n\n\n\ndef dfs(v, graph, memo):\n\n    if memo[v] != -1:\n\n        return memo[v]\n\n    ret = 0\n\n    for c in graph[v]:\n\n        ret = max(ret, dfs(c, graph, memo) + 1)\n\n    memo[v] = ret\n\n    return ret\n\n\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    graph = [[] for _ in range(N)]\n\n    for _ in range(M):\n\n        x, y = list(map(int, input().split()))\n\n        x, y = x - 1, y - 1\n\n        graph[x].append(y)\n\n    memo = [-1] * N\n\n    ans = 0\n\n    for i in range(N):\n\n        ans = max(ans, dfs(i, graph, memo))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 16.0531792607, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K = list(map(int, open(0).read().split()))\n\n\n\nMAX = 5 * 10 ** 5\n\nMOD = 10 ** 9 + 7\n\n\n\n# Factorial\n\nfac = [0] * (MAX + 1)\n\nfac[0] = 1\n\nfac[1] = 1\n\nfor i in range(2, MAX + 1):\n\n    fac[i] = fac[i - 1] * i % MOD\n\n    \n\n# Inverse factorial\n\nfinv = [0] * (MAX + 1)\n\nfinv[MAX] = pow(fac[MAX], MOD - 2, MOD)\n\nfor i in reversed(list(range(1, MAX + 1))):\n\n    finv[i - 1] = finv[i] * i % MOD\n\n\n\ndef comb(n, k):\n\n    return fac[n] * finv[n - k] * finv[k]\n\n\n\ndef rep_perm(n, k):\n\n    return comb(n + k - 1, k)\n\n\n\nans = 0\n\nfor k in range(0, min(N, K + 1)):\n\n    ans += comb(N, k) * rep_perm(N - k, k)\n\n    ans %= MOD\n\nprint(ans)\n \nB. \n\nN, K = list(map(int, input().split()))\n\n\n\nMAX = 6 * 10 ** 5 + 1\n\nMOD = 10 ** 9 + 7\n\n\n\n# Factorial\n\nfac = [0] * (MAX + 1)\n\nfac[0] = 1\n\nfac[1] = 1\n\n\n\n# Inverse\n\ninv = [0] * (MAX + 1)\n\ninv[1] = 1\n\n\n\n# Inverse factorial\n\nfinv = [0] * (MAX + 1)\n\nfinv[0] = 1\n\nfinv[1] = 1\n\n\n\nfor i in range(2, MAX + 1):\n\n    fac[i] = fac[i - 1] * i % MOD\n\n    inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\n    finv[i] = finv[i - 1] * inv[i] % MOD\n\n\n\n\n\ndef comb(n, k):\n\n    if n < k or k < 0:\n\n        return 0\n\n    return (fac[n] * finv[k] * finv[n - k]) % MOD\n\n\n\n\n\ndef comb_rep(n, k):\n\n    return comb(n + k - 1, n - 1)\n\n\n\n\n\nif K >= N - 1:\n\n    print((comb_rep(N + 1, N - 1)))\n\nelse:\n\n    ans = 0\n\n    for i in range(K + 1):\n\n        ans += comb(N, i) * comb_rep(N - i, i) % MOD\n\n        ans %= MOD\n\n    print(ans)\n", "output": "A", "improve_diff": 2.1839332605, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def judge(n):\n\n    for i in range(1,10):\n\n        for j in range(1,10):\n\n            if i*j == n:\n\n                return True\n\n    return False\n\n\n\n\n\nN = int(eval(input()))\n\n\n\nif judge(N):\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\") \nB. N = int(eval(input()))\n\nFLG = False\n\n\n\nfor i in range(1,10):\n\n    if 0 < (N/i) < 10 and (N/i).is_integer():\n\n        FLG = True\n\n        break\n\n\n\nif FLG:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")", "output": "B", "improve_diff": 1.0110832089, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport numpy as np \n\n\n\nI = np.array(sys.stdin.read().split(), dtype=np.int64)\n\nn, m = I[:2]\n\na = I[2:]\n\na.sort()\n\nma = a[-1]\n\ncnt = np.bincount(a, minlength=ma+2)\n\ncnt_not_less_than = np.cumsum(cnt[::-1])[::-1]\n\n\n\nright = a[:, None]\n\ndef possible(border):\n\n    left = border - right\n\n    left = np.maximum(left, 0)\n\n    left = np.minimum(left, ma+1)\n\n    pair_cnt = np.sum(cnt_not_less_than[left])\n\n    return pair_cnt >= m\n\n\n\ndef main():\n\n    lo = 1; hi = ma * 2 + 1\n\n    while lo + 1 < hi:\n\n        border = (lo + hi) // 2\n\n        if possible(border):\n\n            lo = border\n\n        else:\n\n            hi = border\n\n\n\n    res = lo\n\n    left = res - right\n\n    left = np.maximum(left, 0)\n\n    left = np.minimum(left, ma+1)\n\n    c = cnt_not_less_than[left[left != ma+1]]\n\n    pair_cnt = np.sum(c)\n\n    minimum = np.amin(right[left != ma + 1] + a[-c])\n\n\n\n    s = np.cumsum(a[::-1])\n\n    ans = np.sum(s[c-1] + right[left != ma+1] * c) - minimum * (pair_cnt - m)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans) \nB. import sys\n\nfrom itertools import accumulate\n\n\n\nn, m, *a = list(map(int, sys.stdin.read().split()))\n\na.sort()\n\n\n\nma = a[-1]\n\ncnt = [0] * (ma + 1)\n\ncur = ma\n\nfor i in range(n-1, -1, -1):\n\n    if a[i] == cur:\n\n        cnt[cur] += 1\n\n    else:\n\n        while True:\n\n            cur -= 1\n\n            cnt[cur] = cnt[cur+1]\n\n            if cur == a[i]:\n\n                cnt[cur] += 1\n\n                break\n\nfor i in range(cur-1, -1, -1):\n\n    cnt[i] = cnt[i+1]\n\n\n\n\n\ndef possible(border):\n\n    pair_cnt = 0\n\n    for i in range(n):\n\n        aj = border - a[i]\n\n        if aj < 0:\n\n            aj = 0\n\n        elif aj > ma:\n\n            continue\n\n        pair_cnt += cnt[aj]\n\n    return pair_cnt >= m\n\n\n\ndef main():\n\n    s = [0] + list(accumulate(a[::-1]))\n\n    \n\n    lo = 1; hi = a[-1] * 2 + 1\n\n    while lo + 1 < hi:\n\n        border = (lo + hi) // 2\n\n        if possible(border):\n\n            lo = border\n\n        else:\n\n            hi = border\n\n    res = lo\n\n    ans = 0\n\n    minimum = float('inf')\n\n    pair_cnt = 0\n\n    for i in range(n):\n\n        aj = res - a[i]\n\n        if aj < 0:\n\n            aj = 0\n\n        elif aj > ma:\n\n            continue\n\n        c = cnt[aj]\n\n        ans += s[c] + a[i] * c\n\n        pair_cnt += c\n\n        minimum = min(minimum, a[i] + a[-c])\n\n\n\n    ans -= minimum * (pair_cnt - m)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)", "output": "B", "improve_diff": 7.9811895414, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M = list(map(int,input().split()))\n\nA = [list(map(int,input().split())) for _ in range(M)]\n\nif N==1:\n\n    for i in range(10):\n\n        flg = 0\n\n        for j in range(M):\n\n            s,c = A[j]\n\n            if str(i)[s-1]==str(c):\n\n                continue\n\n            else:\n\n                flg = 1\n\n                break\n\n        if flg==0:\n\n            print(i)\n\n            break\n\n    if flg==1:\n\n        print((-1))\n\nelse:\n\n    for i in range(10**(N-1),10**N):\n\n        flg = 0\n\n        for j in range(M):\n\n            s,c = A[j]\n\n            if str(i)[s-1]==str(c):\n\n                continue\n\n            else:\n\n                flg = 1\n\n                break\n\n        if flg==0:\n\n            print(i)\n\n            break\n\n    if flg==1:\n\n        print((-1)) \nB. N,M = list(map(int,input().split()))\n\nA = [list(map(int,input().split())) for _ in range(M)]\n\nn = -1\n\nfor x in range(1000):\n\n    x = str(x)\n\n    if len(x)!=N:continue\n\n    ind = 0\n\n    for i in range(M):\n\n        s,c = A[i]\n\n        if x[int(s)-1]!=str(c):\n\n            ind=1\n\n            break\n\n    if ind==0:\n\n        n = x\n\n        break\n\nprint(n)", "output": "B", "improve_diff": 1.0137657044, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nn_sqrt = int(n ** 0.5) + 1\n\nans = float('inf')\n\nfor i in range(1, n_sqrt + 1):\n\n    if n % i == 0:\n\n        j = int(n // i)\n\n        max_len = max(len(str(i)), len(str(j)))\n\n        ans = min(max_len, ans)\n\nprint(ans) \nB. n = int(eval(input()))\n\nmin_f = 10\n\nfor i in range(1, n + 1):\n\n    if i ** 2 > n:\n\n        break\n\n    if n % i != 0:\n\n        continue\n\n    min_seq = max(len(str(i)), len(str(n // i)))\n\n    if min_seq < min_f:\n\n        min_f = min_seq\n\nprint(min_f)", "output": "A", "improve_diff": 1.1146275263, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nN , K = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(1 , N + 1):\n\n    j = i\n\n    idx = 0\n\n    while j < K:\n\n        j *= 2\n\n        idx += 1\n\n    ans += 1 / N * np.power(1 / 2 , idx)\n\nprint(ans) \nB. N, K = list(map(int, input().split()))\n\nans = 0\n\nfor x in range(1, N + 1):\n\n    cnt = 0\n\n    while x < K:\n\n        cnt += 1\n\n        x *= 2\n\n    ans += (1 / N) * (1 / 2) ** cnt\n\nprint(ans)\n", "output": "B", "improve_diff": 9.7850699028, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nreadline = sys.stdin.readline\n\nfrom math import factorial\n\nMOD = 10 ** 9 + 7\n\n\n\ndef main():\n\n    N, M = list(map(int, readline().rstrip().split()))\n\n    if abs(N-M) > 1:\n\n        ans = 0\n\n    elif N == M:\n\n        ans = (factorial(N) % MOD) * (factorial(M) % MOD) * 2\n\n    else:\n\n        ans = (factorial(N) % MOD) * (factorial(M) % MOD)\n\n\n\n    print((ans % MOD))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. import sys\n\nreadline = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorial(N, mod=MOD):\n\n    res = 1\n\n    for i in range(2, N+1):\n\n        res *= i\n\n        res %= mod\n\n    return res\n\n\n\ndef main():\n\n    N, M = list(map(int, readline().rstrip().split()))\n\n    if abs(N-M) > 1:\n\n        ans = 0\n\n    elif N == M:\n\n        ans = factorial(N) * factorial(M) * 2\n\n    else:\n\n        ans = factorial(N) * factorial(M)\n\n\n\n    print((ans % MOD))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "B", "improve_diff": 1.3429092582, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nif n % 2 <= 0 :\n\n    print((n//2))\n\nelif n % 2 >= 1 :\n\n    print((n//2 +1))\n \nB. import math\n\nN = int(eval(input()))\n\nprint((math.ceil(N/2)))", "output": "A", "improve_diff": 1.2758720606, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nwhile 1:\n\n    n,k,s = list(map(int,input().split()))\n\n    if n == 0: break\n\n    print(sum(sum(ele) == s for ele in itertools.combinations(list(range(1,n+1)),k))) \nB. def dfs(i,k,s):\n\n    if k == s == 0: return 1\n\n    if i > n or s < i*k+k-1: return 0\n\n    return dfs(i+1,k,s)+dfs(i+1,k-1,s-i)\n\n \n\nwhile 1:\n\n    n,k,s = list(map(int,input().split()))\n\n    if n == 0: break\n\n    print(dfs(1,k,s))", "output": "A", "improve_diff": 5.2561053844, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import exit, stdin\n\n\n\ninput = stdin.readline\n\nimport copy\n\n\n\n# from collections import deque,Counter\n\n# import numpy as np\n\n\n\n\n\n(N,) = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\na, b, c = 1, 1, 2\n\nfor i in range(N):\n\n    a = a * 10 % mod\n\n    b = b * 8 % mod\n\n    c = c * 9 % mod\n\n\n\nans = (a + b - c) % mod\n\n\n\nprint(ans)\n \nB. from sys import exit, stdin\n\n\n\ninput = stdin.readline\n\nimport copy\n\n\n\n# from collections import deque,Counter\n\n# import numpy as np\n\n\n\n\n\ndef pow_mod(a, n, d):\n\n    tmp = 1\n\n    for _ in range(n):\n\n        tmp = (tmp * a) % d\n\n    return tmp\n\n\n\n\n\n(N,) = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nans = (pow_mod(10, N, mod) + pow_mod(8, N, mod) - 2 * pow_mod(9, N, mod)) % mod\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 1.4040430563, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nw = list(map(int, input().split()))\n\nres = 10 ** 5\n\nfor i in range(0, n-1):\n\n  a = abs(sum(w[:i+1]) - sum(w[i+1:]))\n\n  if a < res:\n\n    res = a\n\nprint(res) \nB. import numpy\n\nimport math\n\nn = int(eval(input()))\n\nw = list(map(int, input().split()))\n\n\n\nsum_w = sum(w)\n\nsum_w = sum_w / 2\n\n\n\nres = numpy.cumsum(w)\n\n\n\ndiff = [2.0 * math.fabs(res[i] - sum_w) for i in range(n)]\n\nprint((int(min(diff))))", "output": "A", "improve_diff": 9.9082604353, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. c = [1.1,0.6,0.2,0.0]\n\nr = [0 for i in range(8)]\n\nwhile 1:\n\n    try:\n\n        e = list(map(float, input().split()))\n\n        for i in range(2):\n\n            for j in range(4):\n\n                if e[i] >= c[j]:\n\n                \tr[i+2*j] += 1\n\n                \tbreak\n\n    except:\n\n        break\n\nfor i in range(0,8,2):\n\n\tprint(r[i],r[i+1]) \nB. from bisect import bisect\n\nref = [0.2,0.6,1.1]\n\nl,r = [0]*4,[0]*4\n\nwhile 1:\n\n    try:\n\n        le,re = list(map(float, input().split()))\n\n        l[bisect(ref,le)] += 1\n\n        r[bisect(ref,re)] += 1\n\n    except:\n\n        break\n\nfor i in range(1,5):\n\n\tprint(l[-i],r[-i])", "output": "A", "improve_diff": 1.346042559, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\ndict_diffs = dict()\n\nfor i in range(1, n+1):\n\n  dict_diffs[i+a[i-1]] = dict_diffs.get(i+a[i-1], 0) + 1\n\ntotal = 0\n\nfor j in range(1, n+1):\n\n  total += dict_diffs.get(j-a[j-1], 0)\n\nprint(total) \nB. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\ndict_diffs1 = dict()\n\ndict_diffs2 = dict()\n\nfor i in range(1, n+1):\n\n  dict_diffs1[i+a[i-1]] = dict_diffs1.get(i+a[i-1], 0) + 1\n\n  dict_diffs2[i-a[i-1]] = dict_diffs2.get(i-a[i-1], 0) + 1\n\ntotal = 0\n\nfor j in range(1, n+1):\n\n  total += dict_diffs1.get(j-a[j-1], 0)\n\n  total += dict_diffs2.get(j+a[j-1], 0)\n\ntotal = total//2\n\nprint(total)", "output": "B", "improve_diff": 1.0213959563, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. max_num = 10**5+5\n\neratos_thenes_sieve = [0,0] + [1]*max_num\n\nn = 2 #\n\nwhile n*n <= max_num:\n\n  if eratos_thenes_sieve[n]:#\n\n    for i in range(2*n, max_num, n):\n\n      eratos_thenes_sieve[i] = 0\n\n  n += 1\n\n  \n\nisLike2017 = [0] * max_num\n\ncumulativeSums = [0]\n\nfor i in range(max_num):\n\n  if eratos_thenes_sieve[i] and eratos_thenes_sieve[(i+1)//2]:\n\n    isLike2017[i] = 1\n\n  cumulativeSums.append(cumulativeSums[-1] + isLike2017[i])\n\n  \n\n  \n\nq = int(eval(input()))\n\n\n\nfor i in range(q):\n\n  l, r = list(map(int, input().split()))\n\n  print((cumulativeSums[r+1] - cumulativeSums[l])) \nB. Q = int(eval(input()))\n\nlr = [tuple(map(int, input().split())) for _ in range(Q)]\n\n\n\n\n\nN = 10**5\n\nis_prime = [True] * (N+1)\n\nis_prime[0] = False\n\nis_prime[1] = False\n\nfor i in range(2,N+1):\n\n    if is_prime[i]:\n\n        j = 2\n\n        while j * i <= N:\n\n            is_prime[i*j] = False\n\n            j += 1\n\n\n\ncum_like2017 = [0] * (N+1)\n\nfor i in range(1,N+1):\n\n    if is_prime[i] and is_prime[(i+1)//2]:\n\n        cum_like2017[i] = cum_like2017[i-1] + 1\n\n    else:\n\n        cum_like2017[i] = cum_like2017[i-1] \n\n\n\n\n\nfor l, r in lr:\n\n    print((cum_like2017[r] - cum_like2017[l-1]))\n", "output": "A", "improve_diff": 1.7504663354, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\ndef main():\n\n    #\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    F=[]\n\n    for i in range(N):\n\n        f=int(\"\".join(readline().strip().split(\" \")),2)\n\n        F.append(f)\n\n    P=[]\n\n    for i in range(N):\n\n        p=list(map(int,readline().split()))\n\n        P.append(p)\n\n    \n\n    max_res=float(\"-inf\")\n\n    for output in range(1,1<<10):\n\n        res=0\n\n        for j in range(N):\n\n            c=bin(output&F[j]).count(\"1\")\n\n            res+=P[j][c]\n\n        max_res=max(res,max_res)\n\n\n\n    print(max_res)\n\n    \n\nif __name__==\"__main__\":\n\n    main() \nB. from sys import stdin\n\ndef main():\n\n    #\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    F=[]\n\n    for i in range(N):\n\n        f=list(map(int,readline().split()))\n\n        F.append(f)\n\n    P=[]\n\n    for i in range(N):\n\n        p=list(map(int,readline().split()))\n\n        P.append(p)\n\n    \n\n    max_res=-float(\"inf\")\n\n    for i in range(1<<10):\n\n        if i==0:\n\n            continue\n\n        else:\n\n            output=[]\n\n            for j in range(10):\n\n                if(i>>j)&1:\n\n                    output.append(j)\n\n\n\n            oc=[0]*10  #open or close\n\n            for j in output:\n\n                oc[j]=1\n\n            \n\n            res=0\n\n            for j in range(N):\n\n                c=0\n\n                for k in range(10):\n\n                    if oc[k]==1 and F[j][k]==1:\n\n                        c+=1\n\n                res+=P[j][c]\n\n            max_res=max(res,max_res)\n\n\n\n    print(max_res)\n\n    \n\nif __name__==\"__main__\":\n\n    main()", "output": "A", "improve_diff": 1.0683454996, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nList_ans = []\n\n\n\nfor i  in range(1, int(N**(1/2))+1):\n\n    if N % i == 0:\n\n        List_ans.append(i)\n\n        \n\nx = max(List_ans)\n\ny = N//x\n\n\n\nAns = (x-1) + (y-1)\n\nprint(Ans) \nB. import math\n\n\n\nN = int(eval(input()))\n\nroot_N = int(math.sqrt(N)) + 1\n\nA = 100000000000000000000000000000000000\n\n\n\nfor i in range(1, root_N):\n\n    if N % i == 0:\n\n        B = N//i\n\n        A = min(A, B)\n\n\n\nans_1 = A\n\nans_2 = N//A\n\nans = ((ans_1)-1) + ((ans_2)-1)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.2314156509, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\n\n\nN, A, B, C = list(map(int, input().split()))\n\nL = [int(eval(input())) for i in range(N)]\n\n\n\ndef min_cost(target, l_list):\n\n  return 10*(len(l_list) - 1) + abs(target - sum(l_list))\n\n\n\n\n\nans = 1000 * 3\n\ncombs = list(itertools.product([0, 1, 2, 3], repeat=N))\n\nfor comb in combs:\n\n  labcn = [[], [], [], []]\n\n  for i, idx in enumerate(comb):\n\n    labcn[idx].append(L[i])\n\n  \n\n  la, lb, lc, ln = labcn\n\n  if len(la)*len(lb)*len(lc):\n\n    ans = min(ans, min_cost(A, la)+min_cost(B, lb)+min_cost(C, lc))\n\n\n\nprint(ans) \nB. import itertools\n\n\n\nN, A, B, C = list(map(int, input().split()))\n\nL = [int(eval(input())) for i in range(N)]\n\n\n\ndef min_cost(target, l_list):\n\n  if target in l_list:\n\n    return 0\n\n  else:\n\n    res = 1000\n\n    for l in l_list:\n\n      res = min(res, abs(target - l))\n\n    \n\n    for i, l in enumerate(l_list):\n\n      res = min(res, min_cost(target-l, l_list[:i]+l_list[i+1:]) + 10)\n\n  \n\n    return res\n\n\n\nans = 1000 * 3\n\ncombs = list(itertools.product([0, 1, 2], repeat=N))\n\nfor comb in combs:\n\n  labc = [[], [], []]\n\n  for i, idx in enumerate(comb):\n\n    labc[idx].append(L[i])\n\n  \n\n  la, lb, lc = labc\n\n  if len(la)*len(lb)*len(lc):\n\n    ans = min(ans, min_cost(A, la)+min_cost(B, lb)+min_cost(C, lc))\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.924102731, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. q = int(eval(input()))\n\nl, r = [0] * q, [0] * q\n\nfor i in range(q):\n\n    l[i], r[i] = list(map(int, input().split()))\n\n \n\nmini = min(min(l), min(r))\n\nmaxi = max(max(l), max(r))\n\nans = [0] * (maxi + 1)\n\nprime = [0] * (maxi + 1)\n\ndef judge_prime(n):\n\n    for i in range(2, int(n ** 0.5) + 1):\n\n        if n % i == 0:\n\n            return False\n\n    \n\n    return True if n != 1 else False\n\n \n\nfor i in range((mini + 1) // 2, maxi + 1):\n\n    prime[i] = judge_prime(i)\n\n \n\nfor i in range(mini, maxi + 1, 2):\n\n    ans[i] = ans[i - 2] + 1 if prime[i] and prime[(i + 1) // 2] else ans[i - 2]\n\nfor i in range(q):\n\n    print((ans[r[i]] - ans[max(0, l[i] - 2)])) \nB. import math\n\nimport numpy as np\n\ndef get_prime(n):\n\n    if n<= 1:\n\n        return[]\n\n    prime = [2]\n\n    limit = int(math.sqrt(n))\n\n    \n\n    data = [i + 1 for i in range(2,n,2)]\n\n    while limit > data[0]:\n\n        prime.append(data[0])\n\n        data = [j for j in data if j % data[0] != 0]\n\n    return prime + data\n\ndef is_prime(n):\n\n    if n == 1: return False\n\n\n\n    for k in range(2, int(math.sqrt(n)) + 1):\n\n        if n % k == 0:\n\n            return False\n\n\n\n    return True\n\nn = int(eval(input()))\n\nl = []\n\nr = []\n\nfor i in range(n):\n\n    l_, r_ =list(map(int,input().split()))\n\n    l.append(l_)\n\n    r.append(r_)\n\na = get_prime(10**5+1)\n\nb = np.array([0]*(10**5+2))\n\nc =0\n\nd = 0\n\nadd = 0\n\nfor i in range(1,len(a)):\n\n    if is_prime((a[i]+1)/2):\n\n        d = a[i] \n\n        b[c:d] = add \n\n        c = d\n\n        add +=1\n\nb[c:] = add \n\nb[0::2] = 0\n\nfor i in range(n):\n\n    e = b[max(0, l[i] - 2)]\n\n    f = b[r[i]]\n\n    print((f - e))", "output": "A", "improve_diff": 14.9683493365, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    from heapq import heapify, heappop, heappush\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    n,k = list(map(int, input().split()))\n\n    s,p,r = list(map(int, input().split()))\n\n    t = input().rstrip()\n\n    hasi = []\n\n\n\n    res = 0\n\n    for i in range(n):\n\n        if t[i]=='r':\n\n            a = r\n\n            b = 'p'\n\n        if t[i]=='s':\n\n            a = s\n\n            b = 'r'\n\n        if t[i]=='p':\n\n            a = p\n\n            b = 's'\n\n        if i<k:\n\n            res += a\n\n            hasi.append(b)\n\n        else:\n\n            if t[i]==t[i-k] and b in hasi[i-k]:\n\n                hasi.append('x')\n\n                continue\n\n            else:\n\n                res += a\n\n                hasi.append(b)\n\n    print(res)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby, product\n\n    from bisect import bisect_left,bisect_right\n\n    from heapq import heapify, heappop, heappush\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    n,k = list(map(int, input().split()))\n\n    r,s,p = list(map(int, input().split()))\n\n    t = list(input().rstrip())\n\n    score = []\n\n    for i in t:\n\n        if i == 'r':\n\n            score.append(p)\n\n        if i == 's':\n\n            score.append(r)\n\n        if i == 'p':\n\n            score.append(s)\n\n\n\n    res = sum(score)\n\n    for i in range(k, n):\n\n        if t[i] == t[i-k]:\n\n            res -= score[i]\n\n            t[i] = 'u'\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "A", "improve_diff": 1.0149774503, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\n\n\nn = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nT = [[] for _ in range(n)]\n\nfor i, p in enumerate(P, 1):\n\n  T[p-1].append(i)\n\nX = list(map(int, input().split()))\n\nD = [[-1]*n for _ in range(2)]\n\ndef dfs(color, v):\n\n  if D[color][v] != -1:\n\n    return D[color][v]\n\n  l = len(T[v])\n\n  x = X[v]\n\n  dp = [[float(\"inf\")]*(x+1) for _ in range(l+1)]\n\n  dp[0][0] = 0\n\n  for i, nv in enumerate(T[v]):\n\n    for j in range(x+1):\n\n      if j >= X[nv]:\n\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j-X[nv]]+dfs(color, nv))\n\n      if j >= dfs(color^1, nv):\n\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j-dfs(color^1, nv)]+X[nv])\n\n  res = min(dp[l])\n\n  D[color][v] = res\n\n  return res\n\nans = dfs(0, 0)\n\nif ans == float(\"inf\"):\n\n  print(\"IMPOSSIBLE\")\n\nelse:\n\n  print(\"POSSIBLE\") \nB. import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**7)\n\nimport numpy as np\n\n\n\nINF = 2**30\n\nn = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nT = [[] for _ in range(n)]\n\nfor i, p in enumerate(P, 1):\n\n  T[p-1].append(i)\n\nX = list(map(int, input().split()))\n\nD = [[-1]*n for _ in range(2)]\n\ndef dfs(color, v):\n\n  if D[color][v] != -1:\n\n    return D[color][v]\n\n  l = len(T[v])\n\n  x = X[v]\n\n  dp = np.full(x+1, INF, dtype=np.int64)\n\n  dp[0] = 0\n\n  for i, nv in enumerate(T[v]):\n\n    k = np.full(x+1, INF, dtype=np.int64)\n\n    if x+1 >= X[nv]:\n\n      np.minimum(k[X[nv]:], dp[:x+1-X[nv]]+dfs(color, nv), out=k[X[nv]:])\n\n    if x+1 >= dfs(color^1, nv):\n\n      np.minimum(k[dfs(color^1, nv):], dp[:x+1-dfs(color^1, nv)]+X[nv], out=k[dfs(color^1, nv):])\n\n    dp = k.copy()\n\n  res = dp.min()\n\n  D[color][v] = res\n\n  return res\n\nans = dfs(0, 0)\n\nif ans == INF:\n\n  print(\"IMPOSSIBLE\")\n\nelse:\n\n  print(\"POSSIBLE\")", "output": "A", "improve_diff": 9.6122135412, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from copy import deepcopy, copy\n\nclass QueenMAP():\n\n    __slots__ = [\"yoko\", \"tate\", \"naname1\", \"naname2\", \"MAP\"]\n\n    def __init__(self):\n\n        self.yoko = set()\n\n        self.tate = set()\n\n        self.naname1 = set()\n\n        self.naname2 = set()\n\n        self.MAP = [[\".\"] * 8 for _ in range(8)]\n\n    def add(self, y, x):\n\n        self.MAP[y][x] = \"Q\"\n\n        self.yoko.add(y)\n\n        self.tate.add(x)\n\n        self.naname1.add(y - x)\n\n        self.naname2.add(x + y)\n\n    def check(self, y, x):\n\n        if y in self.yoko or x in self.tate or (y - x) in self.naname1 or (x + y) in self.naname2:\n\n            return False\n\n        return True\n\n    def allcheck(self):\n\n        for i in range(8):\n\n            if not \"Q\" in self.MAP[i]:\n\n                return False\n\n        return True\n\ndef MAIN():\n\n    f = lambda M: \"\\n\".join(\"\".join(m) for m in M)\n\n    QM = QueenMAP()\n\n    n = int(eval(input()))\n\n    for _ in range(n):\n\n        a, b = list(map(int, input().split()))\n\n        QM.add(a, b)\n\n    dp = [(deepcopy(QM), n)]\n\n    while dp:\n\n        Q, cnt = dp.pop()\n\n        if cnt == 8:\n\n            if Q.allcheck():\n\n                print((f(Q.MAP)))\n\n                break\n\n            continue\n\n        cnt += 1\n\n        for i in range(8):\n\n            for j in range(8):\n\n                if Q.check(i, j):\n\n                    CQ = deepcopy(Q)\n\n                    CQ.add(i, j)\n\n                    dp.append((CQ, cnt))\n\nMAIN()\n\n\n \nB. from copy import deepcopy, copy\n\nclass QueenMAP():\n\n    __slots__ = [\"yoko\", \"tate\", \"naname1\", \"naname2\", \"MAP\"]\n\n    def __init__(self):\n\n        self.yoko = set()\n\n        self.tate = set()\n\n        self.naname1 = set()\n\n        self.naname2 = set()\n\n        self.MAP = [[\".\"] * 8 for _ in range(8)]\n\n    def add(self, y, x):\n\n        self.MAP[y][x] = \"Q\"\n\n        self.yoko.add(y)\n\n        self.tate.add(x)\n\n        self.naname1.add(y - x)\n\n        self.naname2.add(x + y)\n\n    def check(self, y, x):\n\n        if x in self.tate or (y - x) in self.naname1 or (x + y) in self.naname2:\n\n            return False\n\n        return True\n\n    def allcheck(self):\n\n        for i in range(8):\n\n            if not \"Q\" in self.MAP[i]:\n\n                return False\n\n        return True\n\ndef MAIN():\n\n    f = lambda M: \"\\n\".join(\"\".join(map(str, m)) for m in M)\n\n    QM = QueenMAP()\n\n    n = int(eval(input()))\n\n    for _ in range(n):\n\n        a, b = list(map(int, input().split()))\n\n        QM.add(a, b)\n\n    dp = [(deepcopy(QM), n)]\n\n    while dp:\n\n        Q, cnt = dp.pop()\n\n        if cnt == 8:\n\n            if Q.allcheck():\n\n                print((f(Q.MAP)))\n\n                break\n\n            continue\n\n        cnt += 1\n\n        for i in range(8):\n\n            if i in Q.yoko:\n\n                continue\n\n            for j in range(8):\n\n                if Q.check(i, j):\n\n                    CQ = deepcopy(Q)\n\n                    CQ.add(i, j)\n\n                    dp.append((CQ, cnt))\n\nMAIN()\n\n\n", "output": "B", "improve_diff": 1.030147495, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\nn = int(eval(input()))\n\nh = readints()\n\ncnt = 0\n\nans = 0\n\nfor i in range(n-1):\n\n    if h[i] >= h[i+1]:\n\n        cnt += 1\n\n    else:\n\n        ans = max(cnt, ans)\n\n        cnt = 0\n\nprint((max(ans, cnt)))\n \nB. from copy import deepcopy\n\nimport math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom decimal import Decimal\n\nimport sys\n\nimport fractions\n\nfrom operator import itemgetter\n\nimport itertools\n\nimport copy\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\nh = readints()\n\n# print(h)\n\ncnt = 0\n\nans = -1\n\nfor i in range(n-1):\n\n    if h[i] >= h[i+1]:\n\n        cnt += 1\n\n    else:\n\n        ans = max(cnt, ans)\n\n        cnt = 0\n\nprint((max(ans, cnt)))\n", "output": "A", "improve_diff": 1.1581874541, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. R,G,B,N = list(map(int,input().split()))\n\n\n\nans = 0\n\n\n\nfor r in range(1+N//R):\n\n    for g in range(1+N//G):\n\n        #print(N-(r*R+g*G),r*R, g*G)\n\n        if N-(r*R+g*G) < 0:\n\n            break\n\n        if (N-(r*R+g*G))%B==0:\n\n            ans += 1\n\nprint(ans) \nB. r,g,b,n = list(map(int,input().split()))\n\nr1 = 0\n\ncount = 0\n\n\n\nwhile r*r1 <= n:\n\n    g1 = 0\n\n    while r*r1+g*g1 <= n:\n\n        if (n-(r*r1+g*g1))%b==0:\n\n            count += 1\n\n        g1 += 1\n\n    r1 += 1\n\nprint(count)\n", "output": "A", "improve_diff": 1.1406525947, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nN, M = list(map(int, input().split()))\n\nAB = [list(map(int, sys.stdin.readline().rsplit())) for _ in range(N)]\n\n\n\nAB.sort()\n\n\n\nres = 0\n\nfor a, b in AB:\n\n    if M > b:\n\n        M -= b\n\n        res += a * b\n\n    else:\n\n        res += a * M\n\n        break\n\nprint(res)\n \nB. N, M = list(map(int, input().split()))\n\nAB = [tuple(map(int, input().split())) for _ in range(N)]\n\nAB.sort()\n\n\n\nres = 0\n\ncnt = 0\n\nfor a, b in AB:\n\n    tmp = M - cnt\n\n    if tmp <= b:\n\n        res += a * tmp\n\n        break\n\n    res += a * b\n\n    cnt += b\n\n\n\nprint(res)\n", "output": "B", "improve_diff": 1.0411308039, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b, t = list(map(int, input().split()))\n\nprint((b * (t // a))) \nB. a, b, t = list(map(int, input().split()))\n\nret = 0\n\nfor i in range(a, t + 1, a):\n\n    ret += b\n\nprint(ret)\n", "output": "A", "improve_diff": 1.0580445068, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k = list(map(int,input().split()))\n\nd = input().replace(\" \",\"\")\n\nfor i in range(n,10**9):\n\n  check = True\n\n  for j in str(i):\n\n    if j in d:\n\n      check = False\n\n      break\n\n  if check:\n\n    print(i)\n\n    break \nB. import copy\n\nn,k = list(map(int,input().split()))\n\nd = input().split()\n\nnd = list(map(str,list(range(10))))\n\nfor i in d:\n\n  nd.remove(i)\n\nl = len(str(n))\n\nif \"0\" in nd:\n\n  a1 = 1\n\nelse:\n\n  a1 = 0\n\nalist = nd[a1:]\n\nfor _ in range(l-1):\n\n  tlist = []\n\n  for i in alist:\n\n    for j in nd:\n\n      tlist.append(i+j)\n\n  alist = copy.copy(tlist)\n\nalist.append(nd[a1]+nd[0]*l)\n\nfor i in alist:\n\n  if n <= int(i):\n\n    print(i)\n\n    exit()", "output": "A", "improve_diff": 1.4942564308, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\ntxy = [0]*(N+1)\n\ntxy[0] = [0, 0, 0]\n\nfor i in range(1, N + 1):\n\n    txy[i] = [int(i) for i in input().split()]\n\n\n\nfor i in range(1, N + 1):\n\n    dis = abs(txy[i][1] - txy[i-1][1]) + abs(txy[i][2] - txy[i-1][2])\n\n    time = txy[i][0] - txy[i-1][0]\n\n    if time < dis or (time - dis) % 2 != 0:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes') \nB. N = int(eval(input()))\n\nnow = [0, 0, 0]\n\n\n\nfor i in range(N):\n\n    t, x, y = list(map(int, input().split()))\n\n    dis = abs(x-now[0]) + abs(y - now[1])\n\n    if (t - now[2]) < dis:\n\n        print('No')\n\n        break\n\n    elif ((t - now[2]) - dis) % 2 != 0:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n", "output": "A", "improve_diff": 1.0104418708, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. w, h, n = list(map(int, input().split()))\n\n\n\narea = [[0 for i in range(w)] for j in range(h)]\n\n\n\nfor i in range(n):\n\n    x, y, a = list(map(int, input().split()))\n\n\n\n    if a == 1:\n\n        for j in range(0, h):\n\n            for k in range(0, x):\n\n                area[j][k] = 1\n\n    elif a == 2:\n\n        for j in range(0, h):\n\n            for k in range(x, w):\n\n                area[j][k] = 1\n\n    elif a == 3:\n\n        for j in range(0, y):\n\n            for k in range(0, w):\n\n                area[j][k] = 1\n\n    else:\n\n        for j in range(y, h):\n\n            for k in range(0, w):\n\n                area[j][k] = 1\n\n\n\nans = 0\n\nfor i in range(h):\n\n    for j in range(w):\n\n        if area[i][j] == 0: ans += 1\n\n\n\nprint(ans) \nB. w, h, n = list(map(int, input().split()))\n\n\n\nl = 0\n\nr = w\n\nd = 0\n\nu = h\n\n\n\nfor i in range(n):\n\n    x, y, a = list(map(int, input().split()))\n\n    if a == 1: l = max(l, x)\n\n    if a == 2: r = min(r, x)\n\n    if a == 3: d = max(d, y)\n\n    if a == 4: u = min(u, y)\n\n\n\nans = max(0, r - l) * max(0, u - d)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0233421886, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict, deque, Counter\n\nfrom heapq import heappush, heappop, heapify\n\nimport math\n\nimport bisect\n\nimport random\n\nfrom itertools import permutations, accumulate, combinations, product\n\nimport sys\n\nimport string\n\nfrom bisect import bisect_left, bisect_right\n\nfrom math import factorial, ceil, floor\n\nfrom operator import mul\n\nfrom functools import reduce\n\n\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = 10 ** 20\n\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\n\ndef I(): return int(sys.stdin.buffer.readline())\n\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\n\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\n\ndef IR(n): return [I() for i in range(n)]\n\ndef LIR(n): return [LI() for i in range(n)]\n\ndef SR(n): return [S() for i in range(n)]\n\ndef LSR(n): return [LS() for i in range(n)]\n\ndef SRL(n): return [list(S()) for i in range(n)]\n\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\nmod = 1000000007\n\n\n\n\n\nn, k = LI()\n\nA = [0] + LI()\n\n\n\n\n\n\n\nfor i in range(1, n + 1):\n\n    A[i] = (A[i] + A[i - 1]) % k\n\n\n\n\n\nfor i in range(n + 1):\n\n    A[i] = (A[i] - i) % k\n\n\n\n\n\n\n\nans = 0\n\nD = defaultdict(int)\n\nfor j in range(n, -1, -1):\n\n    ans += D[A[j]]\n\n    D[A[j]] += 1\n\n    if j + k - 1 < n + 1:\n\n        D[A[j + k - 1]] -= 1\n\n\n\n\n\nif k == 1:\n\n    print((0))\n\nelse:\n\n    print(ans) \nB. from collections import defaultdict, deque, Counter\n\nfrom heapq import heappush, heappop, heapify\n\nimport math\n\nimport bisect\n\nimport random\n\nfrom itertools import permutations, accumulate, combinations, product\n\nimport sys\n\nimport string\n\nfrom bisect import bisect_left, bisect_right\n\nfrom math import factorial, ceil, floor\n\nfrom operator import mul\n\nfrom functools import reduce\n\n\n\n\n\nsys.setrecursionlimit(2147483647)\n\nINF = 10 ** 20\n\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\n\ndef I(): return int(sys.stdin.buffer.readline())\n\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\n\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\n\ndef IR(n): return [I() for i in range(n)]\n\ndef LIR(n): return [LI() for i in range(n)]\n\ndef SR(n): return [S() for i in range(n)]\n\ndef LSR(n): return [LS() for i in range(n)]\n\ndef SRL(n): return [list(S()) for i in range(n)]\n\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\nmod = 1000000007\n\n\n\n\n\nn, k = LI()\n\nA = [0] + LI()\n\n\n\nfor i in range(1, n + 1):\n\n    A[i] = (A[i] + A[i - 1] - 1) % k\n\n\n\n\n\nans = 0\n\nD = defaultdict(int)\n\nfor j in range(n, -1, -1):\n\n    ans += D[A[j]]\n\n    D[A[j]] += 1\n\n    if j + k - 1 < n + 1:\n\n        D[A[j + k - 1]] -= 1\n\n\n\n\n\nif k == 1:\n\n    print((0))\n\nelse:\n\n    print(ans)\n", "output": "A", "improve_diff": 1.0722731173, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def floor_sum(n,m,a,b):\n\n  r=0\n\n  x,y,z=0,0,0\n\n  while 1:\n\n    if b>=m:\n\n      x=b//m\n\n    else:\n\n      x=0\n\n    if a>=m:\n\n      y=a//m\n\n    else:\n\n      y=0\n\n    r+=x*n\n\n    b-=x*m\n\n    r+=(y*n*(n-1))>>1\n\n    a-=y*m\n\n    x=(a*n+b)//m\n\n    if x==0:\n\n      break\n\n    y=b-x*m\n\n    z=y//a\n\n    r+=(n+z)*x\n\n    a,b,n,m=m,y-z*a,x,a\n\n  return r\n\n\n\nfor i in range(int(eval(input()))):\n\n  print((floor_sum(*list(map(int,input().split()))))) \nB. import sys\n\nS=sys.stdin.readlines()\n\ndef floor_sum(n,m,a,b):\n\n  r=0\n\n  x,y,z=0,0,0\n\n  while 1:\n\n    if b>=m:\n\n      x=b//m\n\n    else:\n\n      x=0\n\n    if a>=m:\n\n      y=a//m\n\n    else:\n\n      y=0\n\n    r+=x*n\n\n    b-=x*m\n\n    r+=(y*n*(n-1))>>1\n\n    a-=y*m\n\n    x=(a*n+b)//m\n\n    if x==0:\n\n      break\n\n    y=b-x*m\n\n    z=y//a\n\n    r+=(n+z)*x\n\n    a,b,n,m=m,y-z*a,x,a\n\n  return r\n\n\n\nfor i in range(int(S[0])):\n\n  print((floor_sum(*list(map(int,S[i+1].split())))))", "output": "A", "improve_diff": 1.0087587257, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # jsc2019-qualB - Kleene Inversion\n\nfrom collections import Counter\n\nfrom itertools import accumulate\n\n\n\n\n\ndef main():\n\n    N, K = tuple(map(int, input().split()))\n\n    A = tuple(map(int, input().split()))\n\n    MOD = 10 ** 9 + 7\n\n    C = list(Counter(A).values())\n\n    ac = list(accumulate(C[:-1]))\n\n    x = sum(i * j for i, j in zip(C[1:], ac)) % MOD\n\n    y = 0\n\n    for i, a in enumerate(A[:-1]):\n\n        y += sum(b > a for b in A[i + 1 :])\n\n    ans = (x * (1 + K) * K // 2) % MOD\n\n    ans = (ans - y * K) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. # jsc2019-qualB - Kleene Inversion\n\nfrom collections import Counter\n\n\n\n\n\ndef main():\n\n    N, K = tuple(map(int, input().split()))\n\n    A = tuple(map(int, input().split()))\n\n    MOD = 10 ** 9 + 7\n\n    C = Counter(A)\n\n    x = sum(sum(j > i for j in A) * c for i, c in list(C.items()))\n\n    y = sum(sum(b > a for b in A[i + 1 :]) for i, a in enumerate(A[:-1]))\n\n    ans = (x * K * (1 + K) // 2) % MOD\n\n    ans = (ans - y * K) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.0569928508, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    n = int(eval(input()))\n\n    v = list(map(int, input().split()))\n\n\n\n    dic1 = {0:0}\n\n    for i in range(0, n, 2):\n\n        if v[i] in dic1:\n\n            dic1[v[i]] += 1\n\n        else:\n\n            dic1[v[i]] = 1\n\n    \n\n    dic2 = {0:0}\n\n    for i in range(1, n, 2):\n\n        if v[i] in dic2:\n\n            dic2[v[i]] += 1\n\n        else:\n\n            dic2[v[i]] = 1\n\n    \n\n    dic1 = sorted(list(dic1.items()), key=lambda x: -x[1])\n\n    dic2 = sorted(list(dic2.items()), key=lambda x: -x[1])\n\n    # print(dic1)\n\n    # print(dic2)\n\n    if dic1[0][0] != dic2[0][0]:\n\n        print((n-dic1[0][1]-dic2[0][1]))\n\n    else:\n\n        print((min(n-dic1[0][1]-dic2[1][1], n-dic1[1][1]-dic2[0][1])))\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. import sys\n\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    v = np.array(list(map(int, input().split())))\n\n\n\n    len1 = n//2 + n&1\n\n    len2 = n//2\n\n\n\n    d1 = {0:0}\n\n    d2 = {0:0}\n\n    for i in range(0,n,2):\n\n        if v[i] in d1:\n\n            d1[v[i]] += 1\n\n        else:\n\n            d1[v[i]] = 1\n\n    for i in range(1,n,2):\n\n        if v[i] in d2:\n\n            d2[v[i]] += 1\n\n        else:\n\n            d2[v[i]] = 1\n\n\n\n    a = sorted(list(d1.items()), key = lambda x: (x[1], x[0]) , reverse=True)\n\n    b = sorted(list(d2.items()), key = lambda x: (x[1], -x[0]), reverse=True)\n\n    a1_key, a1_val = a[0]\n\n    a2_key, a2_val = a[1]\n\n    b1_key, b1_val = b[0]\n\n    b2_key, b2_val = b[1]\n\n    if a1_key != b1_key:\n\n        print((n - a1_val - b1_val))\n\n    else:\n\n        print((min(n - a1_val - b2_val, n - a2_val - b1_val)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "A", "improve_diff": 10.4210565053, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,t = inpl()\n\nwv = [inpl() for _ in range(n)]\n\nwv.sort(key = lambda x:x[1],reverse = True)\n\nres = 0\n\ntmp = min(n,5)\n\nfor i in range(tmp):\n\n    dp = [[0] * (t+5) for _ in range(n+5)]\n\n    for j in range(n):\n\n        w,v = wv[j]\n\n        for k in range(t):\n\n            if k < w or i == j:\n\n                dp[j+1][k] = dp[j][k]\n\n            else:\n\n                dp[j+1][k] = max(dp[j][k], dp[j][k-w] + v)\n\n    # print(dp[n][t-1])\n\n    res = max(dp[n][t-1] + wv[i][1], res)\n\nprint(res) \nB. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,t = inpl()\n\nwv = [inpl() for _ in range(n)]\n\nrwv = wv[::-1]\n\nudp = [[0] * t for _ in range(n)]\n\nddp = [[0] * t for _ in range(n)]\n\n\n\nfor i in range(n-1):\n\n    w,v = wv[i]\n\n    for j in range(t):\n\n        if j < w:\n\n            udp[i+1][j] = udp[i][j]\n\n        else:\n\n            udp[i+1][j] = max(udp[i][j], udp[i][j-w] + v)\n\nres = udp[n-1][t-1] + wv[n-1][1]\n\n\n\nfor i in range(n-1):\n\n    w,v = rwv[i]\n\n    for j in range(t):\n\n        if j < w:\n\n            ddp[i+1][j] = ddp[i][j]\n\n        else:\n\n            ddp[i+1][j] = max(ddp[i][j], ddp[i][j-w] + v)\n\n    res = max(res,ddp[n-1][t-1] + wv[0][1])\n\n# print(res)\n\nfor i in range(1,n-1):\n\n    u = i; d = n-i-1\n\n    mx = 0\n\n    for j in range(t):\n\n        tmp = udp[u][j] + ddp[d][t-1-j]\n\n        mx = max(mx, tmp)\n\n    res = max(res, mx + wv[i][1])\n\nprint(res)", "output": "B", "improve_diff": 1.065382987, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    n, d, a = list(map(int, input().split()))\n\n    XH = []\n\n    for i in range(n):\n\n        x, h = list(map(int, input().split()))\n\n        XH.append((x, h))\n\n\n\n    XH.sort()\n\n    from collections import deque\n\n    q = deque()\n\n\n\n    ans = 0\n\n    t = 0\n\n    import copy\n\n    for x, h in XH:\n\n        while q:\n\n            r, s = q.popleft()\n\n            if r+d < x:\n\n                t -= s\n\n            else:\n\n                q.appendleft((r, s))\n\n                break\n\n        h -= t\n\n        if h > 0:\n\n            if h%a == 0:\n\n                b = h//a\n\n                ans += b\n\n                t += a*b\n\n                q.append((x+d, a*b))\n\n            else:\n\n                b = h//a+1\n\n                ans += b\n\n                t += a*b\n\n                q.append((x+d, a*b))\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. class BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.bit = [0]*(self.n+1) # 1-indexed\n\n\n\n    def init(self, init_val):\n\n        for i, v in enumerate(init_val):\n\n            self.add(i, v)\n\n\n\n    def add(self, i, x):\n\n        # i: 0-indexed\n\n        i += 1 # to 1-indexed\n\n        while i <= self.n:\n\n            self.bit[i] += x\n\n            i += (i & -i)\n\n\n\n    def sum(self, i, j):\n\n        # return sum of [i, j)\n\n        # i, j: 0-indexed\n\n        return self._sum(j) - self._sum(i)\n\n\n\n    def _sum(self, i):\n\n        # return sum of [0, i)\n\n        # i: 0-indexed\n\n        res = 0\n\n        while i > 0:\n\n            res += self.bit[i]\n\n            i -= i & (-i)\n\n        return res\n\n\n\nclass RangeAddBIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.bit1 = BIT(n)\n\n        self.bit2 = BIT(n)\n\n\n\n    def init(self, init_val):\n\n        self.bit2.init(init_val)\n\n\n\n    def add(self, l, r, x):\n\n        # add x to [l, r)\n\n        # l, r: 0-indexed\n\n        self.bit1.add(l, x)\n\n        self.bit1.add(r, -x)\n\n        self.bit2.add(l, -x*l)\n\n        self.bit2.add(r, x*r)\n\n\n\n    def sum(self, l, r):\n\n        # return sum of [l, r)\n\n        # l, r: 0-indexed\n\n        return self._sum(r) - self._sum(l)\n\n\n\n    def _sum(self, i):\n\n        # return sum of [0, i)\n\n        # i: 0-indexed\n\n        return self.bit1._sum(i)*i + self.bit2._sum(i)\n\n\n\nimport sys\n\nimport io, os\n\n#input = sys.stdin.buffer.readline\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\n\n\nn, d, a = list(map(int, input().split()))\n\nXH = []\n\nfor i in range(n):\n\n    x, h = list(map(int, input().split()))\n\n    XH.append((x-d, h))\n\nXH.sort()\n\nX = []\n\nH = []\n\nfor x, h in XH:\n\n    X.append(x)\n\n    H.append(h)\n\n\n\nbit = RangeAddBIT(n+1)\n\nbit.init(H)\n\nimport bisect\n\nans = 0\n\nfor i in range(n):\n\n    h = bit.sum(i, i+1)\n\n    if h > 0:\n\n        q = (h+a-1)//a\n\n        ans += q\n\n        j = bisect.bisect_right(X, X[i]+2*d)\n\n        bit.add(i, j, -q*a)\n\nprint(ans)\n", "output": "B", "improve_diff": 1.1914367553, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nH, W, M = list(map(int, input().split()))\n\ns = set()\n\nys = [0] * (H + 1)\n\nxs = [0] * (W + 1)\n\nfor _ in range(M):\n\n  y, x = list(map(int, input().split()))\n\n  s.add((y, x))\n\n  ys[y] += 1\n\n  xs[x] += 1\n\n\n\nres = 0\n\nmxy = []\n\nmx = max(ys)\n\nfor i in range(H + 1):\n\n  if ys[i] == mx: mxy.append(i)\n\nres += mx\n\n\n\nmxx = []\n\nmx = max(xs)\n\nfor i in range(W + 1):\n\n  if xs[i] == mx: mxx.append(i)\n\nres += mx - 1\n\n\n\nfor x in mxx:\n\n  for y in mxy:\n\n    if (y, x) in s: continue\n\n    res += 1\n\n    break\n\n  else: continue\n\n  break\n\nprint(res) \nB. import sys\n\nfrom bisect import bisect_left as bl\n\ninput = sys.stdin.readline\n\nH, W, N = list(map(int, input().split()))\n\nys = [0] * (H + 1)\n\nxs = [0] * (W + 1)\n\na = []\n\nbase = 10 ** 6\n\nfor i in range(N):\n\n  y, x = list(map(int, input().split()))\n\n  ys[y] += 1\n\n  xs[x] += 1\n\n  a.append((y, x))\n\nsy = sorted(ys[1: ])\n\nsx = sorted(xs[1: ])\n\n#print(sy, sx)\n\ndef check(k):\n\n  res = 0\n\n  for y, x in a:\n\n    res -= (ys[y] + xs[x]) == k\n\n    res += (ys[y] + xs[x]) > k\n\n\n\n  #print(res, k)\n\n  for y in sy:\n\n    i = bl(sx, k - y)\n\n    res += W - i\n\n    #print(W - i, y, k, res)\n\n  return res > 0\n\n\n\nok = 0\n\nng = N + 1\n\nwhile ng - ok > 1:\n\n  m = (ok + ng) // 2\n\n  if check(m): ok = m\n\n  else: ng = m\n\nprint(ok)", "output": "A", "improve_diff": 1.3285684654, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    d = {}\n\n    for _ in range(n):\n\n        a, b = input().split()\n\n        d[a] = b\n\n    m = int(eval(input()))\n\n    ans = []\n\n    for _ in range(m):\n\n        a = input().strip()\n\n        ans.append(d.get(a, a))\n\n    print((\"\".join(ans))) \nB. while True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    d = {}\n\n    for _ in range(n):\n\n        a, b = input().split()\n\n        d[a] = b\n\n    m = int(eval(input()))\n\n    ans = \"\"\n\n    for _ in range(m):\n\n        a = input().strip()\n\n        ans += d.get(a, a)\n\n    print(ans)", "output": "A", "improve_diff": 1.0092510026, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    n, a, b = list(map(int, input().split()))\n\n    p = 10 ** 9 + 7\n\n    r = pow(2, n, p) - 1\n\n    if (n - a) < a:\n\n        a = n - a\n\n    if (n - b) < b:\n\n        b = n - b\n\n    fac_na = 1\n\n    for i1 in range(n, n - a, -1):\n\n        fac_na = (fac_na * i1) % p\n\n    fac_nb = 1\n\n    for i1 in range(n, n - b, -1):\n\n        fac_nb = (fac_nb * i1) % p\n\n    fac_a = 1\n\n    for i1 in range(1, a+1):\n\n        fac_a = (fac_a * i1) % p\n\n    fac_b = 1\n\n    for i1 in range(1, b+1):\n\n        fac_b = (fac_b * i1) % p\n\n\n\n    an = fac_na * pow(fac_a, p-2, p)\n\n    bn = fac_nb * pow(fac_b, p-2, p)\n\n    an = an % p\n\n    bn = bn % p\n\n    r -= an\n\n    if r < 0:\n\n        r += p\n\n    r -= bn\n\n    if r < 0:\n\n        r += p\n\n    if r < 0:\n\n        r += p\n\n    print((int(r)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. def main():\n\n    from math import factorial\n\n    n, a, b = list(map(int, input().split()))\n\n    p = 1000000007\n\n\n\n    # 1:(mod p)\n\n    n_all = pow(2, n, p) -1\n\n\n\n    # 2:ab(mod p)\n\n    a_comb = 0      # a\n\n    a_comb_x = 1    # an*(n-1)*\u2026*(n-r+1)mod p\n\n    a_comb_y = 1    # ar!mod p\n\n    for i in range(n, n-a ,-1):\n\n        a_comb_x *= i\n\n        a_comb_x %= p\n\n    a_comb_y = factorial(a)\n\n    a_comb_y = pow(a_comb_y, p-2,p)\n\n    a_comb = (a_comb_x * a_comb_y) % p\n\n\n\n    b_comb = 0      \n\n    b_comb_x = 1    \n\n    b_comb_y = 1    \n\n    for i in range(n, n-b ,-1):\n\n        b_comb_x *= i\n\n        b_comb_x %= p\n\n    b_comb_y = factorial(b)\n\n    b_comb_y = pow(b_comb_y, p-2,p)\n\n    b_comb = (b_comb_x * b_comb_y) % p\n\n\n\n    # 3: 1\uff12+p\n\n    r = n_all - a_comb\n\n    if r < 0:\n\n        r += p\n\n    r -= b_comb\n\n    if r < 0:\n\n        r += p\n\n    print(r)\n\n\n\nmain()", "output": "A", "improve_diff": 7.9783785152, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nimport math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom operator import itemgetter\n\nimport sys\n\nsys.setrecursionlimit(2*10**5)\n\nINF = 2**60\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn, k = list(map(int, input().split()))\n\nab = [readints() for _ in range(n)]\n\n# print(ab)\n\nabab = sorted(ab)\n\n# print(abab)\n\ntmp = 0\n\nfor i in range(n):\n\n    tmp += abab[i][1]\n\n    if tmp >= k:\n\n        print((abab[i][0]))\n\n        break\n \nB. import math\n\nimport string\n\nimport collections\n\nfrom collections import Counter\n\nfrom collections import deque\n\nfrom decimal import Decimal\n\nimport sys\n\nimport fractions\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\nn, k = list(map(int, input().split()))\n\nx = [0]*((10**5)+1)\n\nfor i in range(n):\n\n    a, b = list(map(int, input().split()))\n\n    x[a] += b\n\ny = 0\n\nfor i in range(len(x)):\n\n    y += x[i]\n\n    if y >= k:\n\n        print(i)\n\n        exit()\n", "output": "A", "improve_diff": 1.1036997582, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    eval(input())\n\n    array = sorted(int(x) for x in input().split())\n\n    maximum = 1000003\n\n\n\n    counter = defaultdict(int)\n\n    for x in array:\n\n        counter[x] += 1\n\n    maximum = array[-1] + 1\n\n    candidates = [True] * maximum\n\n    for key, value in list(counter.items()):\n\n        if value > 1:  # duplicate\n\n            candidates[key] = False\n\n        for i in range(key * 2, maximum, key):\n\n            candidates[i] = False\n\n\n\n    ans = sum(candidates[x] for x in array)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    eval(input())\n\n    array = sorted(int(x) for x in input().split())\n\n    maximum = array[-1] + 1\n\n    counter = [0] * maximum\n\n\n\n    for x in array:\n\n        if counter[x] != 0:\n\n            counter[x] = 2\n\n            continue\n\n        else:\n\n            for multiple in range(x, maximum, x):\n\n                counter[multiple] += 1\n\n    ans = 0\n\n    for x in array:\n\n        if counter[x] == 1:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.5240933528, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from collections import Counter\n\n    import sys\n\n\n\n    input = sys.stdin.readline\n\n\n\n    N = int(eval(input()))  # <= 10**5\n\n    a = [int(eval(input())) for _ in range(N)]\n\n    ctr = Counter(a)\n\n\n\n    ans = 0\n\n    for cnt in list(ctr.values()):\n\n        ans += cnt % 2\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n#\n\n# sys.setrecursionlimit(10 ** 7)\n\n#\n\n# input = sys.stdin.readline\n\n# rstrip()\n\n# int(input())\n\n# map(int, input().split())\n \nB. n = int(eval(input()))\n\na = list(int(eval(input())) for _ in range(n))\n\nd = {}\n\nfor i in range(n):\n\n    d[a[i]] = d.get(a[i], 0) + 1\n\nans = 0\n\nfor v in list(d.values()):\n\n    if v % 2 == 1:\n\n        ans += 1\n\nprint(ans)", "output": "B", "improve_diff": 1.5319340158, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import accumulate\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\ndef check(d):\n\n    r = sorted([v % d for v in A])\n\n    r_inv = [d - v for v in r]    \n\n    r_cs = [0] + list(accumulate(r))\n\n    r_inv_cs = list(accumulate(r_inv[::-1]))[::-1] + [0]\n\n\n\n    ret = False\n\n    for i in range(N + 1):\n\n        flg1 = r_cs[i] <= K\n\n        flg2 = r_cs[i] == r_inv_cs[i]\n\n        ret = (flg1 and flg2) or ret\n\n    \n\n    return ret\n\n\n\nM = sum(A)\n\nans = 0\n\nfor i in reversed(list(range(1, int(M ** 0.5) + 1))):\n\n    if M % i == 0 and check(i):\n\n        ans = max(ans, i)\n\n    if M % (M // i) == 0 and check(M // i):\n\n        ans = max(ans, M // i)\n\n        \n\nprint(ans)\n \nB. from itertools import accumulate\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\ns = sum(A)\n\ndivisor = []\n\nfor i in range(1, int(s ** 0.5) + 1):\n\n    if s % i == 0:\n\n        divisor.append(i)\n\n        if i != s // i:\n\n            divisor.append(s // i)\n\n\n\nans = 0\n\nfor d in divisor:\n\n    x = sorted(v % d for v in A)\n\n    y = [d - r for r in x]\n\n    x_s = [0] + list(accumulate(x))\n\n    y_s = list(accumulate(y[::-1]))[::-1] + [0]\n\n\n\n    for i in range(N + 1):\n\n        if x_s[i] <= K and x_s[i] == y_s[i]:\n\n            ans = max(ans, d)\n\n            break\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0154627917, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nif N == 2:\n\n    print((1))\n\n    exit()\n\n\n\nif N == 3:\n\n    print((2))\n\n    exit()\n\n\n\nans = []\n\nfor n in range(1, int(N ** 0.5) + 1):\n\n    if (N - 1) % n == 0:\n\n        ans.append(n)\n\n        ans.append((N - 1) // n)\n\n\n\nfor k in range(2, int(N ** 0.5) + 1):\n\n    x = N\n\n    while x % k == 0:\n\n        x //= k\n\n\n\n    if 1 in (x % k - k, x % k):\n\n        ans.append(k)\n\n\n\nprint((len(set(ans))))\n \nB. N = int(eval(input()))\n\n\n\nans = []\n\nfor n in range(1, int(N ** 0.5) + 1):\n\n    if (N - 1) % n == 0:\n\n        ans.append(n)\n\n        ans.append((N - 1) // n)\n\n\n\nfor k in range(2, int(N ** 0.5) + 1):\n\n    if N % k != 0:\n\n        continue\n\n\n\n    x = N\n\n    while x % k == 0:\n\n        x //= k\n\n\n\n    if x % k == 1:\n\n        ans.append(k)\n\n\n\nprint((len(set(ans))))\n", "output": "B", "improve_diff": 1.830273448, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. h,w,d=list(map(int,input().split()))\n\nl=[[0,0]]+[[]for _ in range(h*w)]\n\nfor i in range(h):\n\n    for j,a in enumerate(map(int,input().split())):\n\n        l[a]=[i,j]\n\nfor i in range(h*w+1):\n\n    if i<d:\n\n        l[i].append(0)\n\n    else:\n\n        a,b=l[i]\n\n        x,y,v=l[i-d]\n\n        l[i].append(abs(x-a)+abs(y-b)+v)\n\nl=[a[2]for a in l]\n\nfor _ in range(int(eval(input()))):\n\n    a,b=list(map(int,input().split()))\n\n    print((l[b]-l[a])) \nB. h,w,d=list(map(int,input().split()))\n\nl=[[0,0]]+[[]for _ in range(h*w)]\n\nfor i in range(h):\n\n    for j,a in enumerate(map(int,input().split())):\n\n        l[a]=[i,j]\n\nfor i in range(h*w+1):\n\n    if i<d:\n\n        l[i].append(0)\n\n    else:\n\n        a,b=l[i]\n\n        x,y,v=l[i-d]\n\n        l[i].append(abs(x-a)+abs(y-b)+v)\n\nfor _ in range(int(eval(input()))):\n\n    a,b=list(map(int,input().split()))\n\n    print((l[b][2]-l[a][2]))", "output": "A", "improve_diff": 1.0214304985, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K=int(eval(input()))\n\nA,B=list(map(int,input().split()))\n\nfor i in range(A,B+1):\n\n    if i%K==0:\n\n        print(\"OK\")\n\n        exit()\n\nprint(\"NG\") \nB. K=int(eval(input()))\n\nA,B=list(map(int,input().split()))\n\nfor n in range(A,B+1):\n\n    if n%K==0:\n\n        print(\"OK\")\n\n        exit()\n\nprint(\"NG\")\n", "output": "B", "improve_diff": 1.0249672447, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x, n = list(map(int, input().split(' ')))\n\nmin_num = 100\n\n\n\nls = [0] * 201\n\nfor i in range(0, 201):\n\n    ls[i] = i\n\n\n\nls_in = [0] * n\n\nif n > 0:\n\n    ls_in = list(map(int, input().split(' ')))\n\n    for i in ls_in:\n\n        ls.remove(i)\n\n    ls.reverse()\n\n    for i in ls:\n\n        min_num = min(abs(x-i), min_num)\n\n        if abs(x-i) == min_num:\n\n            ans = i \n\n    print(ans)\n\nelse:\n\n    print(x) \nB. x, n = list(map(int, input().split(' ')))\n\ndiff = x\n\nresult = 0\n\n\n\nif n != 0:\n\n    ls = list(map(int, input().split(' ')))\n\n    ls_remaind = []\n\n    for i in range(1, 102):\n\n        if i not in ls:\n\n            ls_remaind.append(i)\n\n    for j in ls_remaind:\n\n        if abs(x-j) == diff:\n\n            result = min(result, j)\n\n        elif abs(x-j) < diff:\n\n            diff = abs(x-j)\n\n            result = j\n\nelse:\n\n    result = x\n\n\n\nprint(result)", "output": "B", "improve_diff": 1.0387850089, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from collections import namedtuple\n\n    from itertools import combinations\n\n\n\n    City = namedtuple('City', 'x y')\n\n\n\n    def dist(a: City, b: City) -> float:\n\n        dx = a.x - b.x\n\n        dy = a.y - b.y\n\n        return (dx * dx + dy * dy) ** 0.5\n\n\n\n    N = int(eval(input()))\n\n\n\n    cities = []\n\n    for _ in range(N):\n\n        x, y = list(map(int, input().split()))\n\n        c = City(x=x, y=y)\n\n        cities.append(c)\n\n\n\n    total = 0\n\n    for comb in combinations(cities, r=2):\n\n        total += dist(*comb)\n\n\n\n    ans = total * 2 / N\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# 2 + \n\n# [oo]ooo... 4\n\n# (n-1)! * 2!\n\n# 2(n-1)! * 2!\n\n# 2*(n-1)! * 2! / n!\n\n# 2*2/n\n \nB. def main():\n\n    from itertools import permutations\n\n    from math import hypot\n\n\n\n    N = int(eval(input()))\n\n    cities = [tuple(map(int, input().split())) for _ in range(N)]\n\n\n\n    def dist(c1, c2):\n\n        return hypot(c1[0] - c2[0], c1[1] - c2[1])\n\n\n\n    ans = 0\n\n    for perm in permutations(cities, r=2):\n\n        ans += dist(*perm)\n\n    ans /= N\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.1655251802, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. K = int(eval(input()))\n\n\n\nfrom math import gcd\n\n\n\nans = 0\n\n\n\nfor a in range(1, K + 1):\n\n\tfor b in range(1, K + 1):\n\n\t\tt = gcd(a, b)\n\n\t\tfor c in range(1, K + 1):\n\n\t\t\tans += gcd(t, c)\n\nprint(ans)\n \nB. K = int(eval(input()))\n\n\n\ndef gcd(x, y):\n\n    while y:\n\n        x, y = y, x % y\n\n    return x\n\n\n\nans = 0\n\nfor a in range(1, K + 1):\n\n    for b in range(1, K + 1):\n\n        for c in range(1, K + 1):\n\n            ans += gcd(gcd(a, b), c)\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.3825046028, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math \n\n\n\nN=int(eval(input()))\n\n\n\nli=[]\n\nl=0\n\nm=0\n\n\n\nfor i in range(math.floor(math.sqrt(N))):\n\n  if N%(i+1)==0:\n\n    l=i\n\n    m=N/(i+1)-1\n\n    li.append(l+m)\n\n  else:\n\n    pass\n\n\n\nprint((int(min(li))))\n\n\n \nB. N=int(eval(input()))\n\n\n\nanswer=0\n\n\n\nfor i in range(int(pow(N,1/2)),0,-1):\n\n    if N%i==0:\n\n        answer=(i-1)+(N//i-1)\n\n        break\n\nprint(answer)\n", "output": "B", "improve_diff": 1.3131880915, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import lru_cache\n\n\n\n\n\ndef popcnt(x):\n\n    return bin(x).count(\"1\")\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(n):\n\n    if n == 0:\n\n        return 0\n\n    else:\n\n        return rec(n % popcnt(n)) + 1\n\n\n\n\n\nret = [rec(x) for x in range(2 * 10**5 + 1)]\n\n\n\n\n\nn = int(input())\n\narr = input()\n\n\n\nALL_ARR = int(arr, 2)\n\n\n\ncnt = popcnt(int(arr, 2))\n\ninit_big = ALL_ARR % (cnt + 1)\n\nif cnt == 1:\n\n    init_small = 0\n\nelse:\n\n    init_small = ALL_ARR % (cnt - 1)\n\n\n\n\n\nli = [0] * n\n\nfor i in range(n):\n\n    if arr[i] == \"0\":\n\n        li[i] = (init_big + pow(2, n - i - 1, cnt + 1)) % (cnt + 1)\n\n    elif ALL_ARR - (1 << (n - i - 1)) == 0 or cnt - 1 == 0:\n\n        li[i] = \"flg\"\n\n    else:\n\n        li[i] = (init_small - pow(2, n - i - 1, cnt - 1)) % (cnt - 1)\n\n\n\n\n\nans = []\n\n\n\nfor x in li:\n\n    if x == \"flg\":\n\n        ans.append(0)\n\n    else:\n\n        ans.append(ret[x] + 1)\n\n\n\nprint(*ans, sep=\"\\n\")\n \nB. from functools import lru_cache\n\n\n\n\n\ndef popcnt(x):\n\n    return bin(x).count(\"1\")\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(n):\n\n    if n == 0:\n\n        return 0\n\n    else:\n\n        return rec(n % popcnt(n)) + 1\n\n\n\n\n\nn = int(input())\n\narr = input()\n\n\n\nALL_ARR = int(arr, 2)\n\n\n\ncnt = popcnt(int(arr, 2))\n\ninit_big = ALL_ARR % (cnt + 1)\n\nif cnt == 1:\n\n    init_small = 0\n\nelse:\n\n    init_small = ALL_ARR % (cnt - 1)\n\n\n\n\n\nli = [0] * n\n\nfor i in range(n):\n\n    if arr[i] == \"0\":\n\n        li[i] = (init_big + pow(2, n - i - 1, cnt + 1)) % (cnt + 1)\n\n    elif ALL_ARR - (1 << (n - i - 1)) == 0 or cnt - 1 == 0:\n\n        li[i] = \"flg\"\n\n    else:\n\n        li[i] = (init_small - pow(2, n - i - 1, cnt - 1)) % (cnt - 1)\n\n\n\n\n\nans = []\n\n\n\nfor x in li:\n\n    if x == \"flg\":\n\n        ans.append(0)\n\n    else:\n\n        ans.append(rec(x) + 1)\n\n\n\nprint(*ans, sep=\"\\n\")\n", "output": "B", "improve_diff": 6.2792358875, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from sys import stdin\n\n    readline = stdin.readline\n\n    H, N = list(map(int, readline().split()))\n\n    AB = [list(map(int, readline().split())) for _ in range(N)]\n\n\n\n    dp = [100000000] * (H + 10 ** 4 + 1)\n\n    dp[0] = 0\n\n    for i in range(H):\n\n        if dp[i] == 100000000:\n\n            continue\n\n        for a, b in AB:\n\n            t = dp[i] + b\n\n            if t < dp[i + a]:\n\n                dp[i + a] = t\n\n    print((min(dp[H:])))\n\n\n\n\n\nmain()\n \nB. H, N = list(map(int, input().split()))\n\nAB = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nA_max = 10 ** 4\n\nINF = float('inf')\n\n\n\ndp = [INF] * (H + A_max + 1)\n\ndp[0] = 0\n\nfor i in range(H):\n\n    if dp[i] == INF:\n\n        continue\n\n    for a, b in AB:\n\n        if dp[i] + b < dp[i + a]:\n\n            dp[i + a] = dp[i] + b\n\nprint((min(dp[H:])))\n", "output": "A", "improve_diff": 1.2114767163, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nb=[s.split(',')[1][:-1] for s in sys.stdin]\n\nfor e in [\"A\",\"B\",\"AB\",\"O\"]:\n\n    print(b.count(e)) \nB. import sys\n\n\n\nL=[\"A\",\"B\",\"AB\",\"O\"]\n\nb={}\n\nfor e in L:\n\n    b[e]=0\n\nfor s in sys.stdin:\n\n    i = s[s.index(',')+1:-1]\n\n    b[i]+=1\n\nfor e in L:\n\n    print(b[e])", "output": "B", "improve_diff": 1.0288290666, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\ns=sum(a)\n\n\n\ncandidates=set()\n\nfor i in range(1,int(s**0.5)+1):\n\n  if s%i==0:\n\n    candidates.add(i)\n\n    candidates.add(s//i)\n\n\n\nans=0\n\nfor cdd in candidates:\n\n  div_cdd=[0]*n\n\n  for i in range(n):\n\n    div_cdd[i]=a[i]%cdd\n\n  div_cdd=sorted(div_cdd)\n\n  pstv,ngtv=0,-sum(div_cdd)\n\n  # calc need\n\n  if pstv==-ngtv:\n\n    ans=max(ans,cdd)\n\n    continue\n\n  for i in range(n):\n\n    pstv+=cdd-div_cdd[-1-i]\n\n    ngtv+=div_cdd[-1-i]\n\n    if pstv==-ngtv: break\n\n  ans=max(ans,cdd) if pstv<=k else ans\n\n    \n\nprint(ans) \nB. n,k=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\ns=sum(a)\n\n\n\ncandidates=set()\n\nfor i in range(1,int(s**0.5)+1):\n\n  if s%i==0:\n\n    candidates.add(i)\n\n    candidates.add(s//i)\n\n\n\nans=0\n\nfor cdd in candidates:\n\n  div_cdd=[0]*n\n\n  for i in range(n):\n\n    div_cdd[i]=a[i]%cdd\n\n  div_cdd=sorted(div_cdd)\n\n  # calc need\n\n  idx=n-sum(div_cdd)//cdd\n\n  need=0\n\n  for i in range(idx):\n\n    need+=div_cdd[i]\n\n  ans=max(ans,cdd) if need<=k else ans\n\n    \n\nprint(ans)", "output": "B", "improve_diff": 1.0297175766, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nM = 10**9 + 7\n\n\n\nif N < 3:\n\n    print((0))\n\nelif N < 6:\n\n    print((1))\n\nelse:\n\n    dp = [0] * (N + 1)\n\n    dp[3] = 1\n\n    dp[4] = 1\n\n    dp[5] = 1\n\n    P = dp[3]\n\n    for i in range(6, N + 1):\n\n        dp[i] = (P + 1) % M\n\n        P = (P + dp[i - 2]) % M\n\n    print((dp[-1] % M)) \nB. N = int(eval(input()))\n\nM = 10**9 + 7\n\n\n\nif N < 3:\n\n    print((0))\n\nelif N < 6:\n\n    print((1))\n\nelse:\n\n    dp = [0] * (N + 1)\n\n\n\n    dp[3] = 1\n\n    dp[4] = 1\n\n    dp[5] = 1\n\n    for i in range(6, N + 1):\n\n        dp[i] = sum(dp[3:i - 3 + 1]) + 1\n\n        dp[i] %= M\n\n\n\n    print((dp[-1] % M))", "output": "A", "improve_diff": 1.2114543608, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k=list(map(int,input().split()))\n\n\n\nret=0\n\nfor i in range(1,n+1):\n\n    now=i\n\n    tmp=1/n\n\n    while now<k:\n\n        now*=2\n\n        tmp/=2\n\n    ret+=tmp \n\n\n\nprint(ret)\n \nB. n,k=list(map(int,input().split()))\n\n\n\np=0.0\n\nfor i in range(1,n+1):\n\n    m=0\n\n#    print(k,i,m,i*2**m)\n\n    while k>i*2**m:\n\n#        print(k,i,m,i*2**m)\n\n        m=m+1\n\n#    print(m)\n\n    p=p+(0.5)**m/n\n\nprint(p)", "output": "A", "improve_diff": 1.0490456165, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. (_,k),*t=[list(map(int,t.split()))for t in open(0)]\n\nA,F=list(map(sorted,t))\n\no=10**12\n\ng=-1\n\nwhile~g+o:\n\n m,l=o+g>>1,k\n\n for a,f in zip(A,F[::-1]):l-=max(0,a-m//f)\n\n if l<0:g=m\n\n else:o=m\n\nprint(o) \nB. from numpy import*\n\nk,A,F=[int64(t.split())for t in open(0)]\n\nl=-1\n\nr=10**12\n\nwhile~l+r:\n\n m=l+r>>1\n\n if sum(A-minimum(sort(A),m//sort(F)[::-1]))>k[1]:l=m\n\n else:r=m\n\nprint(r)", "output": "A", "improve_diff": 10.7146927318, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # Union find\n\n# \n\n# https://www.youtube.com/watch?time_continue=916&v=zxor0DdwoXA&feature=emb_logo\n\n# https://www.slideshare.net/chokudai/union-find-49066733\n\n\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nn, m = list(map(int, input().split()))\n\nAB = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nroot = [-1]*n\n\n\n\ndef find(x):\n\n    if root[x] < 0:\n\n        return x\n\n    else:\n\n        root[x] = find(root[x])\n\n        return root[x]\n\n\n\ndef unite(x, y):\n\n    gx = find(x)\n\n    gy = find(y)\n\n    \n\n    if gx == gy:\n\n        return\n\n      \n\n    if root[gx] > root[gy]:\n\n        gx, gy = gy, gx\n\n        \n\n    root[gx] += root[gy]\n\n    root[gy] = gx\n\n\n\ndef size(x):\n\n    x = find(x)\n\n    return -root[x]\n\n\n\nfor a, b in AB:\n\n    a -= 1\n\n    b -= 1\n\n    unite(a, b)\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans = max(ans, size(i))\n\nprint(ans) \nB. import sys\n\nsys.setrecursionlimit(10**9)\n\n\n\nn, m = list(map(int, input().split()))\n\nAB = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nroot = [-1] * n\n\n\n\ndef find(x):\n\n    if root[x] < 0:\n\n        return x\n\n    else:\n\n        return find(root[x])\n\n\n\ndef unity(x, y):\n\n    gx = find(x)\n\n    gy = find(y)\n\n\n\n    if gx == gy:\n\n        return\n\n\n\n    if root[gx] > root[gy]:\n\n        gx, gy = gy, gx\n\n\n\n    root[gx] += root[gy]\n\n    root[gy] = gx\n\n\n\nfor a, b in AB:\n\n    a -= 1\n\n    b -= 1\n\n    unity(a, b)\n\n\n\nprint((-min(root)))", "output": "B", "improve_diff": 1.0158963642, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A, B, N = list(map(int, input().split()))\n\nalpha = A // B\n\nbeta = A % B\n\nq = min(N, B - 1)\n\n\n\nans = alpha * q + (beta*q//B)\n\nprint(ans) \nB. A, B, N = list(map(int, input().split()))\n\nx = min(N, B-1)\n\nprint((A*x//B - A*(x//B)))", "output": "A", "improve_diff": 1.0489850256, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,*A=list(map(int,open(0)));p=f=0\n\nfor a,b in zip(A,A[1:]):d,m=divmod(a-f,2);f=min(m,b);p+=d+f\n\nprint((p+(A[-1]-f)//2)) \nB. N,*A=list(map(int,open(0)));p=f=0\n\nfor a in A:d,m=divmod(a+f,2);p+=d;f=m&(a>0)\n\nprint(p)", "output": "B", "improve_diff": 1.1075870817, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nd = [0] * n\n\npresent = [[] for i in range(n)]\n\nfor i in range(n - 1):\n\n    u, v = list(map(int, input().split()))\n\n    u -= 1\n\n    v -= 1\n\n    if u > v:\n\n        u, v = v, u\n\n    d[v] += 1\n\n    present[u].append(v)\n\nans = 0\n\ncur = 0\n\nfor v in range(n):\n\n    cur += (n - v) * d[v]\n\nfor l in range(n):\n\n    ans += (l + 1) * (l + 2) // 2\n\n    ans -= cur\n\n    for v in present[l]:\n\n        cur -= (n - v)\n\nprint(ans)\n \nB. import sys\n\n\n\n\n\ndef read():\n\n    return sys.stdin.readline()\n\n\n\n\n\ndef main():\n\n    n = int(read())\n\n    d = [0] * n\n\n    present = [[] for i in range(n)]\n\n    for i in range(n - 1):\n\n        u, v = sorted([int(x) - 1 for x in read().split()])\n\n        d[v] += 1\n\n        present[u].append(v)\n\n    ans, cur = 0, 0\n\n    for v in range(n):\n\n        cur += (n - v) * d[v]\n\n    for L in range(n):\n\n        ans += (L + 1) * (L + 2) // 2 - cur\n\n        for v in present[L]:\n\n            cur -= (n - v)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.052813192, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N = int(eval(input()))\n\n    s_dict = dict()\n\n\n\n    for i in range(1, N + 1):\n\n        S, P = input().split()\n\n        if S in s_dict:\n\n            s_dict[S].append((i, int(P)))\n\n        else:\n\n            s_dict[S] = [(i, int(P))]\n\n\n\n    s_dict_keys = sorted(list(s_dict.keys()))\n\n\n\n    for key in s_dict_keys:\n\n        s_dict[key].sort(key=lambda x: x[1], reverse=True)\n\n        for i, _ in s_dict[key]:\n\n            print(i)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. def main():\n\n    N = int(eval(input()))\n\n    sp_lst = [0 for _ in range(N)]\n\n\n\n    for i in range(N):\n\n        S, P = input().split()\n\n        sp_lst[i] = [i + 1, S, int(P)]\n\n\n\n    sp_lst.sort(key=lambda x: x[2], reverse=True)\n\n    sp_lst.sort(key=lambda x: x[1])\n\n\n\n    for i, _, _ in sp_lst:\n\n        print(i)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "A", "improve_diff": 1.0477646957, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\ndp = [1e9 for _ in range(n)]\n\n#dp[i]...\n\ndp[0] = 0\n\ndp[1] = abs(a[1] - a[0])\n\nfor i in range(n-2):\n\n  dp[i+2] = min(dp[i+1] + abs(a[i+2] - a[i+1]), dp[i] + abs(a[i+2] - a[i]))\n\nprint((dp[n-1]))\n \nB. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\ndp = [1e9]*n\n\ndp[0] = 0\n\nfor i in range(1, n):\n\n  dp[i] = min(dp[i], dp[i-1] + abs(a[i] - a[i-1]))\n\n  if i > 1:\n\n    dp[i] = min(dp[i], dp[i-2] + abs(a[i] - a[i-2]))\n\nprint((dp[n-1]))\n", "output": "B", "improve_diff": 1.0352380564, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    n = int(eval(input()))\n\n    max_a, max_b = 0, 0 # type:int\n\n    for _ in range(n):\n\n        a, b = input().split()\n\n        a = int(a)\n\n        if max_a < a:\n\n            max_a = a\n\n            max_b = int(b)\n\n    print((max_a + max_b))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. def main():\n\n    n = int(eval(input()))\n\n    ab = [] # type:[[int]] \n\n    for i in range(n):\n\n        ab.append([int(x) for x in input().split()])\n\n    a, b = max(ab, key=lambda x: x[0])\n\n    print((a + b))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.0359354189, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC084D - 2017-like Number\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nfrom bisect import bisect_left, bisect_right\n\n\n\n\n\ndef get_primes(n):\n\n    # return a list of primes <= n\n\n    n += 1  # include n itself\n\n    sieve = [1] * n\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n\n        if sieve[i]:\n\n            sieve[i * i :: 2 * i] = [0] * ((n - i * i - 1) // (2 * i) + 1)\n\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\n\n\n\n\ndef main():\n\n    Q = int(input())\n\n    A = tuple(tuple(map(int, input().split())) for _ in range(Q))\n\n    _, R = zip(*A)\n\n    lim = max(R)\n\n    P = get_primes(lim)\n\n    S = set(P)\n\n    selected_P = [p for p in P if (p + 1) // 2 in S]\n\n    ans = []\n\n    for l, r in A:\n\n        x = bisect_right(selected_P, r) - bisect_left(selected_P, l)\n\n        ans += [x]\n\n    print(*ans, sep=\"\\n\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. # ABC084D - 2017-like Number\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nfrom bisect import bisect_left, bisect_right\n\n\n\n\n\ndef get_primes(n: int) -> list:\n\n    # return a list of primes <= n\n\n    n += 1  # include n itself\n\n    sieve = [1] * n\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n\n        if sieve[i]:\n\n            sieve[i * i :: 2 * i] = [0] * ((n - i * i - 1) // (2 * i) + 1)\n\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\n\n\n\n\ndef main():\n\n    Q = int(input())\n\n    A = tuple(tuple(map(int, input().split())) for _ in range(Q))\n\n    P = get_primes(10 ** 5)\n\n    S = set(P)\n\n    selected_P = [p for p in P if (p + 1) // 2 in S]\n\n    ans = []\n\n    bsr, bsl = bisect_right, bisect_left\n\n    for l, r in A:\n\n        x = bsr(selected_P, r) - bsl(selected_P, l)\n\n        ans += [x]\n\n    print(*ans, sep=\"\\n\")\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "A", "improve_diff": 1.2494288311, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \"\"\"\n\n    Author: _YL_\n\n\"\"\"\n\n# b:blue, r:red\n\nn, b, r = list(map(int, input().split()))\n\n\n\nif b == 0:\n\n    print(\"0\")\n\nelif r == 0:\n\n    print(n)\n\nelse:\n\n    remainder = n % (b+r)\n\n    if remainder > b:\n\n        remainder = b\n\n\n\n    print((n//(b+r)*b+remainder)) \nB. N, A, B = [int(x) for x in input().strip().split()]\n\np = N // (A + B) * A\n\nq = N % (A + B)\n\nif q > A:\n\n    q = A\n\nprint((p + q))\n", "output": "A", "improve_diff": 1.0284494483, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\nprint(((m*1900+(n-m)*100)*2**m)) \nB. n,m=[int(i) for i in input().split()]\n\nans=(n-m)*100\n\nans=(ans+1900*m)*2**m\n\nprint(ans)", "output": "A", "improve_diff": 1.0523025172, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #  O(NC) = O(3 * 10 ** 6)\n\nimport sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n\n\nN, C = list(map(int, input().split()))\n\n\n\n# \n\nlst = [[0] * (10 ** 5 + 10) for _ in range(C + 1)]\n\nlst_max = [[1] * (10 ** 5 + 10) for _ in range(C + 1)]\n\n\n\n# lst = [[0] * (10) for _ in range(C + 1)]\n\n# lst_max = [[1] * (10) for _ in range(C + 1)]\n\n\n\nfor _ in range(N):\n\n    s, t, c = list(map(int, input().split()))\n\n    lst[c][s] += 1\n\n    lst[c][t + 1] -= 1\n\n\n\nlst = np.array(lst)\n\nnp.cumsum(lst, axis = 1, out = lst)\n\nnp.minimum(lst, lst_max, out = lst)\n\nnp.cumsum(lst, axis = 0, out = lst)\n\n\n\nprint((np.max(lst[-1]))) \nB. #  O(NC) = O(3 * 10 ** 6)\n\nimport sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n\n\nN, C = list(map(int, input().split()))\n\n\n\n# \n\nlst = [[0] * (10 ** 5 + 10) for _ in range(C + 1)]\n\n# lst_max = [[1] * (10 ** 5 + 10) for _ in range(C + 1)]\n\n\n\n# lst = [[0] * (10) for _ in range(C + 1)]\n\n# lst_max = [[1] * (10) for _ in range(C + 1)]\n\n\n\nfor _ in range(N):\n\n    s, t, c = list(map(int, input().split()))\n\n    lst[c][s] += 1\n\n    lst[c][t + 1] -= 1\n\n\n\nlst = np.array(lst)\n\nnp.cumsum(lst, axis = 1, out = lst)\n\nnp.minimum(lst, 1, out = lst)\n\nnp.cumsum(lst, axis = 0, out = lst)\n\n\n\nprint((np.max(lst[-1])))", "output": "B", "improve_diff": 1.1142714717, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,q=list(map(int, input().split()))\n\n*a,=list(map(int, input().split()))\n\nbit=[0]*(2*n+1)\n\n\n\ndef add(t,x):\n\n    while t<=n:\n\n        bit[t]+=x\n\n        t+=t&(-t)\n\n\n\ndef que(t):\n\n    res=0\n\n    while t:\n\n        res+=bit[t]\n\n        t-=t&(-t)\n\n    return res\n\n\n\nfor i in range(n):\n\n    add(i+1,a[i])\n\n\n\n\n\nfor _ in range(q):\n\n    i,p,x=list(map(int, input().split()))\n\n    if i:\n\n        ans=que(x)-que(p)\n\n        print(ans)\n\n    else:\n\n        add(p+1,x)\n \nB. import sys\n\ninput=sys.stdin.readline\n\nn,q=list(map(int, input().split()))\n\n*a,=list(map(int, input().split()))\n\nbit=[0]*(n+1)\n\n\n\ndef add(t,x):\n\n    while t<=n:\n\n        bit[t]+=x\n\n        t+=t&(-t)\n\n\n\ndef que(t):\n\n    res=0\n\n    while t:\n\n        res+=bit[t]\n\n        t-=t&(-t)\n\n    return res\n\n\n\nfor i in range(n):\n\n    add(i+1,a[i])\n\n\n\n\n\nfor _ in range(q):\n\n    i,p,x=list(map(int, input().split()))\n\n    if i:\n\n        ans=que(x)-que(p)\n\n        print(ans)\n\n    else:\n\n        add(p+1,x)\n", "output": "A", "improve_diff": 1.0485372358, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. d, n = list(map(int, input().split()))\n\n\n\n\n\nfor i in range(1, 100000000):\n\n    if i % (100 ** d) == 0 and i % (100 * 100 ** d) != 0:\n\n        n -= 1\n\n    if n == 0:\n\n        print(i)\n\n        exit()\n \nB. # Problem B - Ringo's Favorite Numbers\n\n\n\n# input\n\nD, N = list(map(int, input().split()))\n\n\n\n# initialization\n\nans = 0\n\ntmp = 100**D\n\n\n\n# count\n\ni = 1\n\nwhile i<=N:\n\n    if i==100:\n\n        ans = tmp * (i + 1)\n\n        break\n\n    ans = tmp * i\n\n    i += 1\n\n\n\n# output\n\nprint(ans)\n", "output": "B", "improve_diff": 3.3286862522, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\ninput = stdin.readline\n\n\n\nN, M, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\n\n\nsumA = [0]\n\nsumB = [0]\n\n\n\n\n\nfor i in range(N):\n\n    sumA.append(sumA[i] + A[i])\n\n\n\nfor i in range(M):\n\n    sumB.append(sumB[i] + B[i])\n\n\n\nans = 0\n\nt = M\n\n\n\nfor i in range(N + 1):\n\n    for j in range(t, -1, -1):\n\n        if K < sumA[i] + sumB[j]:\n\n            t -= 1\n\n            continue\n\n        else:\n\n            ans = max(ans, i + j)\n\n            break\n\n\n\nprint(ans)\n \nB. from sys import stdin\n\nfrom bisect import bisect\n\ninput = stdin.readline\n\n\n\nN, M, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\n\n\nfor i in range(1, N):\n\n    A[i] += A[i - 1]\n\n\n\nfor i in range(1, M):\n\n    B[i] += B[i - 1]\n\n\n\nans = 0\n\n\n\nfor i, a in enumerate(A):\n\n    time = K - a\n\n    if time < 0:\n\n        break\n\n    cnt = i + 1\n\n    if time != 0:\n\n        tmp = bisect(B, time)\n\n        cnt += tmp\n\n    ans = max(ans, cnt)\n\n\n\nfor i, b in enumerate(B):\n\n    time = K - b\n\n    if time < 0:\n\n        break\n\n    cnt = i + 1\n\n    if time != 0:\n\n        tmp = bisect(A, time)\n\n        cnt += tmp\n\n    ans = max(ans, cnt)\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.4256953384, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,X,Y = map(int, input().split())\n\nD = [0] * N\n\nfor i in range(1,N):\n\n  for j in range(i+1,N+1):\n\n    D[min(abs(i-j),abs(X-i)+abs(Y-j)+1,abs(Y-i)+abs(X-j)+1)] += 1 \n\nprint (*D[1:], sep=\"\\n\")\n \nB. from collections import Counter\n\nN,X,Y = list(map(int, input().split()))\n\nX -= 1\n\nY -= 1\n\nL = []\n\nfor i in range(N-1):\n\n  for j in range(i+1,N):\n\n    L.append(min(abs(i-j),abs(X-i)+abs(Y-j)+1,abs(Y-i)+abs(X-j)+1))\n\nD = Counter(L)\n\nfor k in range(1,N):\n\n  print((D[k]))", "output": "A", "improve_diff": 1.4601600382, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_left, bisect_right\n\na, b, q = list(map(int, input().split()))\n\ninf = 10**18\n\nshrine = [-inf] + [int(eval(input())) for _ in range(a)] + [inf]\n\ntemple = [-inf] + [int(eval(input())) for _ in range(b)] + [inf]\n\n\n\nfor _ in range(q):\n\n    ans = inf\n\n    x = int(eval(input()))\n\n    index_s = bisect_left(shrine, x)\n\n    index_t = bisect_right(temple, x)\n\n    \n\n    for s in [shrine[index_s-1], shrine[index_s]]:\n\n        for t in [temple[index_t-1], temple[index_t]]:\n\n            ans = min(\n\n                ans,\n\n                abs(x-s) + abs(s-t),\n\n                abs(x-t) + abs(s-t)\n\n            )\n\n\n\n    print(ans) \nB. from bisect import bisect_left, bisect_right\n\na, b, q = list(map(int, input().split()))\n\ninf = 10**18\n\nshrine = [-inf] + [int(eval(input())) for _ in range(a)] + [inf]\n\ntemple = [-inf] + [int(eval(input())) for _ in range(b)] + [inf]\n\n\n\nfor _ in range(q):\n\n    ans = inf\n\n    x = int(eval(input()))\n\n    index_s = bisect_left(shrine, x)\n\n    index_t = bisect_right(temple, x)\n\n    for i in range(index_s-1, index_s+1):\n\n        s = shrine[i]\n\n        i_t = index_t\n\n        t0, t1 = temple[i_t-1], temple[i_t]\n\n        ans = min(\n\n            ans,\n\n            abs(x - s) + abs(s - t0),\n\n            abs(x - s) + abs(s - t1),\n\n        )\n\n\n\n    for i in range(index_t-1, index_t+1):\n\n        t = temple[i]\n\n        i_s = index_s\n\n        s0 = shrine[i_s - 1]\n\n        s1 = shrine[i_s]\n\n        ans = min(\n\n            ans,\n\n            abs(x - t) + abs(t - s0),\n\n            abs(x - t) + abs(t - s1),\n\n        )\n\n\n\n    print(ans)\n", "output": "A", "improve_diff": 1.0185745799, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [int(a) for a in input().split()]\n\nP = 10**9+7\n\n\n\ndef inv(a):\n\n    return pow(a, P-2, P)\n\n\n\ns = 0\n\nfor i in range(N):\n\n    s += inv(i+1)\n\n    \n\nans = 0\n\nfor i in range(N):\n\n    ans += s * A[i]\n\n    ans %= P\n\n    s += inv(i+2) - inv(N-i)\n\n    \n\nfor i in range(1, N+1):\n\n    ans = ans * i % P\n\n    \n\nprint(ans) \nB. def mod_inv(n,p):\n\n    if n<0:\n\n        return - mod_inv(-n,p) % p\n\n    if n>p:\n\n        return mod_inv(n % p, p)\n\n    \n\n    def mod_inv_calc(a,b):\n\n        if b==0:\n\n            return (a,1)\n\n        else:\n\n            s,t = mod_inv_calc(b, a % b)\n\n            d = a//b\n\n            return (t, -t*d+s)\n\n\n\n    return mod_inv_calc(p,n)[1] % p\n\n\n\nN = int(eval(input()))\n\nA = [int(a) for a in input().split()]\n\np = 10**9+7\n\ninv_list = [mod_inv(i+1,p) for i in range(N+2)]\n\n\n\nfact_list = [1]\n\nfor i in range(N):\n\n    fact_list.append(fact_list[i] * (i+1) % p)\n\ns = 0\n\nsum_list = [inv_list[i] * fact_list[N] % p for i in range(N+2)]\n\n\n\nfor i in range(N):\n\n    s += inv_list[i]\n\n    \n\ns *= fact_list[N]\n\ns %= p\n\nans = 0\n\nfor i in range(N):\n\n    ans += A[i]*s\n\n    ans %= p\n\n    s += (sum_list[i+1] - sum_list[N-i-1])\n\n    s %= p\n\n    \n\nprint (ans)", "output": "A", "improve_diff": 1.0232224791, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nsys.setrecursionlimit(10**7)\n\ndef I(): return int(sys.stdin.readline().rstrip())\n\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\n\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #\n\ndef S(): return sys.stdin.readline().rstrip()\n\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #\n\ndef LS2(): return list(sys.stdin.readline().rstrip())  #\n\n\n\n\n\nD,T,S = MI()\n\nprint(('Yes' if S*T >= D else 'No'))\n \nB. import sys\n\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\n\n\n\nD,T,S = MI()\n\nprint(('Yes' if S*T >= D else 'No'))\n", "output": "B", "improve_diff": 1.0134141804, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,A,B=list(map(int,input().split()))\n\nX=list(map(int,input().split()))\n\nfrom collections import deque\n\nX=deque(X)\n\ncost=0\n\nnow=X.popleft()\n\nwhile len(X)>0:\n\n    if (X[0]-now)*A<=B:\n\n        cost+=(X[0]-now)*A\n\n    else:cost+=B\n\n    now=X.popleft()\n\nprint(cost) \nB. N,A,B=list(map(int,input().split()))\n\nnow=0\n\nans=0\n\nfor x in map(int,input().split()):\n\n    if now!=0:\n\n        if (x-now)*A>B:\n\n            ans+=B\n\n        else:\n\n            ans+=(x-now)*A\n\n    now=x\n\nprint(ans)", "output": "B", "improve_diff": 1.4458179735, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. H, W, D = list(map(int,input().split()))\n\ndist = [0]*(H*W+1)#dist[i]ii+D\n\npos = [[0,0] for i in range(H*W+1)]\n\nfor i in range(H):\n\n  A = list(map(int,input().split()))\n\n  for j in range(W):\n\n    pos[A[j]] = [i+1, j+1]\n\n    \n\nfor i in range(H*W+1-D):\n\n  dist[i] = abs(pos[i][0]-pos[i+D][0])+abs(pos[i][1]-pos[i+D][1])\n\n\n\ndistances = [[] for i in range(D)]#i\n\nfor i in range(1,H*W+1-D):\n\n  distances[i%D]+=[dist[i]]\n\ndistances2 = [[0] for i in range(D)]#\n\nfor i in range(D):\n\n  for j in range(len(distances[i])):\n\n    distances2[i]+=[distances2[i][-1]+distances[i][j]]\n\n\n\nQ = int(eval(input()))\n\nfor i in range(Q):\n\n  L, R = list(map(int, input().split()))\n\n  l, r = (L-1)//D, (R-1)//D\n\n  print((distances2[L%D][r]-distances2[L%D][l])) \nB. H, W, D = list(map(int,input().split()))\n\ndist = [0]*(H*W+1)#dist[i]ii+D\n\npos = [[0,0] for i in range(H*W+1)]\n\nfor i in range(H):\n\n  A = list(map(int,input().split()))\n\n  for j in range(W):\n\n    pos[A[j]] = [i+1, j+1]\n\nfor i in range(H*W+1-D):\n\n  dist[i] = abs(pos[i][0]-pos[i+D][0])+abs(pos[i][1]-pos[i+D][1])\n\ndistances = [[] for i in range(D)]#i\n\nfor i in range(1,H*W+1-D):\n\n  d = dist[i]\n\n  distances[i%D]+=[d]\n\ndistances2 = [[0] for i in range(D)]#\n\nfor i in range(D):\n\n  for j in range(len(distances[i])):\n\n    distances2[i]+=[distances2[i][-1]+distances[i][j]]\n\nQ = int(eval(input()))\n\nfor i in range(Q):\n\n  L, R = list(map(int, input().split()))\n\n  q = L%D\n\n  l, r = (L-1)//D, (R-1)//D\n\n  print((distances2[q][r]-distances2[q][l]))", "output": "B", "improve_diff": 1.0503891508, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nP = [list(map(int, input().split())) for _ in range(N)]\n\nans = 0\n\nc = 0\n\n\n\ndef dfs(i, dis, passed):\n\n    if len(passed) == N:\n\n        global c, ans\n\n        c += 1\n\n        ans += dis\n\n        return\n\n    x = P[i][0]\n\n    y = P[i][1]\n\n    for ii in range(N):\n\n        if P[ii] in passed:\n\n            continue\n\n        xx = P[ii][0]\n\n        yy = P[ii][1]\n\n        passed.append([xx, yy])\n\n        dfs(ii, dis + ((x - xx)**2 + (y - yy)**2)**0.5, passed)\n\n        passed.pop(-1)\n\n\n\nfor i in range(N):\n\n    dfs(i, 0, [P[i]])\n\nprint((ans / c)) \nB. import math\n\n\n\nN = int(eval(input()))\n\nP = [list(map(int, input().split())) for _ in range(N)]\n\ndis = 0\n\nc = 0\n\n\n\nfor i in range(N):\n\n    xi = P[i][0]\n\n    yi = P[i][1]\n\n    for ii in range(i + 1, N):\n\n        xj = P[ii][0]\n\n        yj = P[ii][1]\n\n        dis += ((xi - xj)**2 + (yi - yj)**2)**0.5\n\n        c += 1\n\nprint((dis / c * (N - 1)))\n\n        \n\n    \n\n    ", "output": "A", "improve_diff": 1.2749305536, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while 1:\n\n    n,a,b=list(map(int,input().split()))\n\n    if n==a==b==0:break\n\n    c=0;d=[1]+[0]*2000000\n\n    for i in range(0,n+1):\n\n        if d[i]:d[i+a]=d[i+b]=1\n\n        else:c+=1\n\n    print(c) \nB. while 1:\n\n    n,a,b=list(map(int,input().split()))\n\n    if n==a==b==0:break\n\n    c=0;d=[1]*(n+1)\n\n    for x in range(a):\n\n        for i in range(x*b,n+1,a):d[i]=0\n\n    print((sum(d)))", "output": "B", "improve_diff": 7.3812448689, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. inf = float('inf')\n\n\n\nN,K = list(map(int,input().split()))\n\nans = inf\n\nX = []\n\nY = []\n\nXY = []\n\nfor _ in range(N):\n\n    x,y = list(map(int,input().split()))\n\n    X.append(x)\n\n    Y.append(y)\n\n    XY.append((x,y))\n\n\n\nX = sorted(X)\n\nY = sorted(Y)\n\n\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        for k in range(N):\n\n            for l in range(k+1,N):\n\n                cnt = 0\n\n                for x, y in XY:\n\n                    if X[i] <= x <= X[j] and Y[k] <= y <= Y[l]:\n\n                        cnt += 1\n\n                if cnt < K: continue\n\n                S = (Y[l]-Y[k])*(X[j]-X[i])\n\n                if S < ans:\n\n                    ans = S\n\n\n\nprint(ans) \nB. inf = float('inf')\n\n\n\nN,K = list(map(int,input().split()))\n\nans = inf\n\nX = []\n\nY = []\n\nXY = []\n\nfor _ in range(N):\n\n    x,y = list(map(int,input().split()))\n\n    X.append(x)\n\n    Y.append(y)\n\n    XY.append((x,y))\n\n\n\nX = sorted(X)\n\nY = sorted(Y)\n\n\n\nfor i, left in enumerate(X):\n\n    for right in X[i+1:]:\n\n        for j, bottom in enumerate(Y):\n\n            for top in Y[j+1:]:\n\n                cnt = 0\n\n                for x, y in XY:\n\n                    if left <= x <= right and bottom <= y <= top:\n\n                        cnt += 1\n\n                if cnt < K: continue\n\n                S = (right-left)*(top-bottom)\n\n                if S < ans:\n\n                    ans = S\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.0539027905, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\nN,W = LI()\n\nwv = [LI() for _ in range(N)]\n\nV = N*10**3\n\ndp = [[float('INF')]*(V+1) for _ in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(1,N+1):\n\n    w,v = wv[i-1]\n\n    for j in range(V+1):\n\n        if j-v>=0 and dp[i-1][j-v]+w<=W:\n\n            dp[i][j] = min(dp[i][j],dp[i-1][j-v]+w)\n\n        dp[i][j] = min(dp[i][j],dp[i-1][j])\n\nprint((max([i for i in range(V+1) if dp[-1][i]<=W])))\n \nB. import itertools,sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\nN,W = LI()\n\nwv = [LI() for _ in range(N)]\n\nV = 10**5\n\ndp = [[float('INF')]*(V+1) for _ in range(N+1)]\n\ndp[0][0] = 0\n\nfor i,j in itertools.product(list(range(1,N+1)),list(range(V+1))):\n\n    w,v = wv[i-1]\n\n    if j-v>=0 and dp[i-1][j-v]+w<=W:\n\n        dp[i][j] = min(dp[i][j],dp[i-1][j-v]+w)\n\n    dp[i][j] = min(dp[i][j],dp[i-1][j])\n\nprint((max([i for i in range(V+1) if dp[-1][i]<=W])))\n", "output": "A", "improve_diff": 12.7469937593, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nC = Counter(A)\n\nans = len(C)\n\nif (N-ans) % 2 == 1:\n\n    ans -= 1\n\nprint(ans)\n \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nS = set(A)\n\nans = len(S)\n\nif (N-ans) % 2 == 1:\n\n    ans -= 1\n\nprint(ans)\n", "output": "B", "improve_diff": 1.4891420691, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nh, w, d = map(int, input().split())\n\nX = np.zeros(h*w, dtype=int)\n\nY = np.zeros(h*w, dtype=int)\n\nscore = np.zeros(h*w, dtype=int)\n\nfor x in range(h):\n\n    inp = tuple(map(int, input().split()))\n\n    for y in range(w):\n\n        i = int(inp[y]) - 1\n\n        X[i] = x\n\n        Y[i] = y\n\n\n\nscore[d:] += np.abs(X[d:] - X[:-d]) + np.abs(Y[d:] - Y[:-d])\n\nfor i in range(len(score) - d):\n\n    score[i+d] += score[i]\n\n\n\nq = int(input())\n\nans = []\n\nfor _ in range(q):\n\n    l, r = map(int, input().split())\n\n    l -= 1\n\n    r -= 1\n\n    ans.append(score[r]-score[l])\n\n\n\nprint(*ans, sep=\"\\n\")\n \nB. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nH, W, D = map(int, readline().split())\n\nA = [list(map(int, readline().split())) for _ in range(H)]\n\nQ = int(readline())\n\nquery = [tuple(map(int, readline().split())) for _ in range(Q)]\n\n\n\npath = [[(-1, -1)]*((H*W)//D+1) for _ in range(D)]\n\nfor i in range(H):\n\n    for j in range(W):\n\n        a = A[i][j]\n\n        div, mod = divmod(a, D)\n\n        path[mod][div] = (i, j)\n\npath[0][0] = path[0][1]\n\n\n\ncost = []\n\nfor i in range(D):\n\n    tmp = [0]\n\n    for l, r in zip(path[i][:-1], path[i][1:]):\n\n        x, y = l\n\n        z, w = r\n\n        tmp.append(tmp[-1] + abs(z - x) + abs(w - y))\n\n    cost.append(tmp)\n\n\n\nans = []\n\nfor L, R in query:\n\n    vl, md = divmod(L, D)\n\n    vr = R // D\n\n\n\n    tmp = cost[md][vr] - cost[md][vl]\n\n    ans.append(tmp)\n\n\n\nprint(*ans, sep=\"\\n\")\n", "output": "B", "improve_diff": 9.958973429, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b = list(map(int, input().split()))\n\n\n\nans = -1\n\nfor i in range(10,12501):\n\n    if int(i*0.08) == a and int(i * 0.1) == b:\n\n        ans = i\n\n        break\n\n        \n\nprint(ans) \nB. a,b = list(map(int, input().split()))\n\n\n\nimport math\n\n\n\nif math.ceil((a+1)*12.5) <= math.ceil(b*10) or math.ceil(a*12.5) >= math.ceil((b+1)*10):\n\n    print((-1))\n\nelse:\n\n    print((max(math.ceil(a*12.5),math.ceil(b*10))))", "output": "A", "improve_diff": 1.2794296097, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nans = 9999999\n\nfor a in range(1,N):\n\n    b = N-a\n\n    tmp = 0\n\n    for ac in str(a):\n\n        tmp += int(ac)\n\n    for bc in str(b):\n\n        tmp += int(bc)\n\n    ans = min(ans, tmp)\n\nprint(ans)\n \nB. N = int(eval(input()))\n\n\n\nans = 9999\n\nfor a in range(1,N):\n\n    b = N-a\n\n    x = sum(map(int,str(a)))\n\n    y = sum(map(int,str(b)))\n\n    ans = min(ans, x+y)\n\nprint(ans)", "output": "B", "improve_diff": 1.3379269849, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, T = list(map(int, input().split()))\n\nt = list(map(int, input().split()))\n\nlastOn = t[0]\n\nans = 0\n\nfor i in range(1,N):\n\n    ti = t[i]\n\n    ans += min(T, ti-lastOn)\n\n    lastOn = ti\n\nans += T\n\nprint(ans)\n \nB. N, T = list(map(int, input().split()))\n\n*t, = list(map(int, input().split()))\n\nans = 0\n\nlast = -10**10\n\nfor a in t:\n\n    ans += T - max(last + T - a, 0)\n\n    last = a\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0248120867, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nr = N % 1000\n\n\n\nif not r:\n\n  print((0))\n\nelse:\n\n  q = N // 1000\n\n  print(((q+1) * 1000 - N)) \nB. N = int(eval(input()))\n\n\n\nr = N % 1000\n\n\n\nif r == 0:\n\n  print((0))\n\nelse:\n\n  q = (N // 1000) + 1\n\n  print((q*1000 - N))", "output": "B", "improve_diff": 1.0131873525, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom itertools import accumulate\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\nN, M, Q = map(int, input().split())\n\nG = [[0] * N for _ in range(N)]\n\nfor _ in range(M):\n\n    l, r = map(int, input().split())\n\n    G[l - 1][r - 1] += 1\n\n\n\ncsum = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(N):\n\n    for j in range(N):\n\n        csum[i + 1][j + 1] = csum[i + 1][j] + csum[i][j + 1] - csum[i][j] + G[i][j]\n\n\n\nans = []\n\nfor _ in range(Q):\n\n    p, q = map(int, input().split())\n\n    ans.append(csum[q][q] - csum[q][p - 1] - csum[p - 1][q] + csum[p - 1][p - 1])\n\n\n\nprint(*ans, sep='\\n')\n \nB. import sys\n\nfrom itertools import accumulate\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\nN, M, Q = map(int, readline().split())\n\nG = [[0] * N for _ in range(N)]\n\nfor _ in range(M):\n\n    l, r = map(int, readline().split())\n\n    G[l - 1][r - 1] += 1\n\n\n\ncsum = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(N):\n\n    for j in range(N):\n\n        csum[i + 1][j + 1] = csum[i + 1][j] + csum[i][j + 1] - csum[i][j] + G[i][j]\n\n\n\nans = []\n\nfor _ in range(Q):\n\n    p, q = map(int, readline().split())\n\n    ans.append(csum[q][q] - csum[q][p - 1] - csum[p - 1][q] + csum[p - 1][p - 1])\n\n\n\nprint(*ans, sep='\\n')\n", "output": "A", "improve_diff": 1.0194032444, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\nimport sys\n\n#from operator import itemgetter\n\nsysread = sys.stdin.readline\n\nread = sys.stdin.read\n\n#from heapq import heappop, heappush\n\n#from collections import defaultdict\n\nsys.setrecursionlimit(10**7)\n\nimport math\n\nfrom itertools import combinations, product\n\n#import bisect# lower_bound etc\n\n#import numpy as np\n\ndef run():\n\n    N,K = list(map(int, read().split()))\n\n    k = int(math.log(N, 10))\n\n    s = N // (10 ** k)\n\n\n\n    tmp1, tmp2, div = 1, 1, 1\n\n    for i in range(K-1):\n\n        tmp1 *= k-i\n\n        div *= i+1\n\n        tmp2 *= 9\n\n    ret = tmp1//div * tmp2\n\n    ret *= s-1\n\n\n\n    tmp1 *= k - (K-1)\n\n    tmp2 *= 9\n\n    div *= K\n\n\n\n    ret += tmp1 * tmp2 // div\n\n    lis = list(range(k))\n\n    nums = list(range(1,10))\n\n    base = s * 10 ** k\n\n\n\n    for A in combinations(lis, K-1):\n\n        for X in product(nums, repeat = K-1):\n\n            tmp = base\n\n            for a,x in zip(A,X):\n\n                tmp += 10 ** a * x\n\n            if tmp <= N:\n\n                ret += 1\n\n    print(ret)\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    run() \nB. # coding: utf-8\n\nimport sys\n\n#from operator import itemgetter\n\nsysread = sys.stdin.readline\n\nread = sys.stdin.read\n\n#from heapq import heappop, heappush\n\n#from collections import defaultdict\n\nsys.setrecursionlimit(10**7)\n\nimport math\n\nfrom itertools import combinations, product\n\n#import bisect# lower_bound etc\n\n#import numpy as np\n\ndef run():\n\n    N,K = read().split()\n\n\n\n    N = list(map(int,N))\n\n    K = int(K)\n\n    max_i = len(N)\n\n    dp2 = [0] * max_i\n\n    r = 0\n\n    for i, v in enumerate(N):\n\n        if v != 0:\n\n            r += 1\n\n        dp2[i] = r\n\n\n\n    dp1 = [[0] * (K+1) for _ in range(max_i)]\n\n\n\n    dp1[0][1] = int(N[0]-1)\n\n    dp1[0][0] = 1\n\n    for i in range(1, max_i):\n\n        for j in range(0, K+1):\n\n            if j == 0:\n\n                dp1[i][j] += dp1[i - 1][j]\n\n            else:\n\n                dp1[i][j] += dp1[i - 1][j] + dp1[i - 1][j - 1] * 9\n\n        if N[i] == 0:continue\n\n        if dp2[i-1] <= K:\n\n            dp1[i][dp2[i-1]] += 1\n\n        if dp2[i-1] < K:\n\n            dp1[i][dp2[i-1]+1] += N[i] - 1\n\n    plus = 0\n\n    if dp2[-1] == K:\n\n        plus = 1\n\n    print((dp1[max_i-1][K] + plus))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    run()", "output": "B", "improve_diff": 4.8946734178, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nt = 0\n\nfor j in range(1,N+1):\n\n  m = N//j\n\n  t += (1+m)*m//2 * j\n\n#\n\nprint(t)\n \nB. N = int(eval(input()))\n\n\n\nnn = N//2\n\nt = 0\n\nfor j in range(1,nn+1):\n\n  m = N//j\n\n  t += (1+m)*m//2 * j\n\n#\n\nt += ((nn+1)+N)*(N-nn)//2\n\nprint(t)\n", "output": "B", "improve_diff": 1.9613542622, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef dfs(v):\n\n    print(counter)\n\n    for nv in g[v]:\n\n        if nv in visited:\n\n            continue\n\n        visited.add(nv)\n\n        counter[nv] += counter[v]\n\n        dfs(nv)\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().strip()\n\n\n\n\n\nN, Q = list(map(int, input().split()))\n\ng = [set() for _ in range(N)]\n\nfor _ in range(N - 1):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    g[a].add(b)\n\n    g[b].add(a)\n\ncounter = [0] * N\n\nfor _ in range(Q):\n\n    p, x = list(map(int, input().split()))\n\n    p -= 1\n\n    counter[p] += x\n\n\n\nstack = [0]\n\nvisited = {0}\n\nwhile stack:\n\n    v = stack.pop()\n\n    for nv in g[v]:\n\n        if nv in visited:\n\n            continue\n\n        stack.append(nv)\n\n        visited.add(nv)\n\n        counter[nv] += counter[v]\n\nprint((\" \".join(map(str, counter))))\n \nB. import sys\n\n\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef solve():\n\n    def dfs(v):\n\n        print(counter)\n\n        for nv in g[v]:\n\n            if nv in visited:\n\n                continue\n\n            visited.add(nv)\n\n            counter[nv] += counter[v]\n\n            dfs(nv)\n\n\n\n    def input():\n\n        return sys.stdin.readline().strip()\n\n\n\n    N, Q = list(map(int, input().split()))\n\n    g = [set() for _ in range(N)]\n\n    for _ in range(N - 1):\n\n        a, b = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        g[a].add(b)\n\n        g[b].add(a)\n\n    counter = [0] * N\n\n    for _ in range(Q):\n\n        p, x = list(map(int, input().split()))\n\n        p -= 1\n\n        counter[p] += x\n\n\n\n    stack = [0]\n\n    visited = {0}\n\n    while stack:\n\n        v = stack.pop()\n\n        for nv in g[v]:\n\n            if nv in visited:\n\n                continue\n\n            stack.append(nv)\n\n            visited.add(nv)\n\n            counter[nv] += counter[v]\n\n    return counter\n\n\n\n\n\nprint((\" \".join(map(str, solve()))))\n", "output": "A", "improve_diff": 1.0689381599, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #!/usr/bin/env python3\n\n\n\nimport collections\n\nimport sys\n\ninput=sys.stdin.readline\n\n\n\ndef gcd(a,b):\n\n    if b==0:\n\n        return a\n\n    else:\n\n        return gcd(b,a%b)\n\n\n\ndef judge(n,arr):\n\n    MAX=10**6\n\n    table=[i for i in range(MAX+1)]\n\n    for i in range(2,MAX+1):\n\n        if table[i]<i:\n\n            continue\n\n        for j in range(i,MAX+1,i):\n\n            table[j]=i\n\n    cnt=collections.defaultdict(int)\n\n    for val in arr:\n\n        s=set()\n\n        while val!=1:\n\n            prime=table[val]\n\n            s.add(prime)\n\n            val//=prime\n\n        for tmp in s:\n\n            cnt[tmp]+=1\n\n    for val in list(cnt.values()):\n\n        if val>=2:\n\n            return False\n\n    return True\n\n    \n\nn=int(eval(input()))\n\narr=list(map(int,input().split()))\n\ntmp=arr[0]\n\nfor val in arr:\n\n    tmp=gcd(tmp,val)\n\nif tmp==1:\n\n    is_setwise=True\n\nelse:\n\n    is_setwise=False\n\nis_pairwise=judge(n,arr)\n\nif is_pairwise==True:\n\n    print('pairwise coprime')\n\nelif is_setwise==True:\n\n    print('setwise coprime')\n\nelse:\n\n    print('not coprime') \nB. import collections\n\nimport sys\n\ninput=sys.stdin.readline\n\n\n\ndef divisors(n):\n\n  ret=[]\n\n  for i in range(2,int(n**0.5)+1):\n\n    if n%i==0:\n\n      ret.append(i)\n\n      while n%i==0:\n\n        n//=i\n\n  if n!=1:\n\n    ret.append(n)\n\n  return ret\n\n\n\ndef gcd(a,b):\n\n  if b==0:\n\n    return a\n\n  else:\n\n    return gcd(b,a%b)\n\n\n\nn=int(eval(input()))\n\narr=list(map(int,input().split()))\n\ncnt=[False]*(max(arr)+1)\n\nis_pairwise=True\n\ntmp=arr[0]\n\nfor val in arr:\n\n  tmp=gcd(tmp,val)\n\n  if is_pairwise==False:\n\n    continue\n\n  divisor=divisors(val)\n\n  for val2 in divisor:\n\n    if cnt[val2]==True:\n\n      is_pairwise=False\n\n      break\n\n    cnt[val2]=True\n\nif tmp==1:\n\n  is_setwise=True\n\nelse:\n\n  is_setwise=False\n\nif is_pairwise==True:\n\n  print('pairwise coprime')\n\nelif is_setwise==True:\n\n  print('setwise coprime')\n\nelse:\n\n  print('not coprime')", "output": "B", "improve_diff": 13.431478234, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #\n\n# -*- coding: utf-8 -*-\n\nn, m, q = list(map(int, input().split()))\n\ninteger_set = [list(map(int, input().split())) for _ in range(q)]\n\na = [1]\n\nscore = 0\n\n \n\n# (Depth First Search)\n\ndef dfs(seq):\n\n    if len(seq) == n:\n\n        global score\n\n        tmp_score = 0\n\n        for a, b, c, d in integer_set:\n\n            if seq[b-1] - seq[a-1] == c:\n\n                tmp_score += d\n\n            else:\n\n                tmp_score += 0\n\n        score = max(score, tmp_score)\n\n    else:\n\n        for i in range(seq[-1], m+1):\n\n            tmp_seq = seq.copy()\n\n            tmp_seq.append(i)\n\n            dfs(tmp_seq)\n\n \n\ndfs(a)\n\nprint(score) \nB. N,M,Q=list(map(int,input().split()))\n\nR=[list(map(int,input().split())) for i in range(Q)]\n\nS=[1]*N#1N\n\n \n\ndef dfs(d):\n\n    if d==N-1:\n\n        t=0\n\n        for a,b,c,d in R:\n\n            if S[b-1]-S[a-1]==c:\n\n                t+=d\n\n        return t\n\n    else:\n\n        m=0\n\n        for i in range(S[d],M+1):\n\n            S[d+1]=i\n\n            m=max(m,dfs(d+1))\n\n        return m\n\n\n\nprint((dfs(0)))", "output": "B", "improve_diff": 1.0847813588, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\n\n\nn, m = list(map(int, input().split()))\n\ngraph = [[] * n for _ in range(n)]\n\nfor _ in range(m):\n\n    x, y, z = list(map(int, input().split()))\n\n    x -= 1\n\n    y -= 1\n\n    z %= 2\n\n    graph[x].append((y))\n\n    graph[y].append((x))\n\n\n\nseen = [False] * n\n\nans = 0\n\nfor i in range(n):\n\n    if not seen[i]:\n\n        seen[i] = True\n\n        node = deque(graph[i])\n\n        while node:\n\n            v = node.popleft()\n\n            if seen[v]:\n\n                continue\n\n            seen[v] = True\n\n            node.extend(graph[v])\n\n        ans += 1\n\n\n\nprint(ans)\n \nB. class UnionFind:\n\n    def __init__(self, n):\n\n        self.root = [i for i in range(n + 1)]\n\n        self.rank = [0] * (n + 1)\n\n\n\n    def find(self, x):\n\n        if self.root[x] == x:\n\n            return x\n\n        else:\n\n            self.root[x] = self.find(self.root[x])\n\n            return self.root[x]\n\n\n\n    def isSame(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n\n            self.root[x] = y\n\n        else:\n\n            self.root[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nuf = UnionFind(n)\n\nfor _ in range(m):\n\n    x, y, z = list(map(int, input().split()))\n\n    uf.union(x, y)\n\n\n\nfor i in range(1, n + 1):\n\n    uf.find(i)\n\n\n\nn_tree = set(uf.root)\n\nans = len(n_tree) - 1\n\nprint(ans)\n", "output": "B", "improve_diff": 1.7908804795, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import collections\n\nN, M, *AB = [int(_) for _ in open(0).read().split()]\n\nparent_children = collections.defaultdict(set)\n\nchild_parents = collections.defaultdict(set)\n\nfor a, b in zip(AB[::2], AB[1::2]):\n\n    parent_children[a].add(b)\n\n    child_parents[b].add(a)\n\nroot = (set(range(1, N + 1)) - set(child_parents.keys())).pop()\n\n\n\n\n\ndef bfs(root):\n\n    Q = collections.deque([root])\n\n    while Q:\n\n        cur = Q.pop()\n\n        for to in parent_children[cur]:\n\n            if len(child_parents[to]) > 1:\n\n                child_parents[to].remove(cur)\n\n            else:\n\n                Q += [to]\n\n\n\n\n\nbfs(root)\n\nchild_parents[root] = {0}\n\nfor i in range(1, N + 1):\n\n    print((child_parents[i].pop()))\n \nB. import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\n\nN, M = [int(_) for _ in input().split()]\n\nAB = [[int(_) for _ in input().split()] for _ in range(N - 1 + M)]\n\n\n\nG = [set() for _ in range(N + 1)]\n\ncount = [0] * (N + 1)\n\nans = [0] * (N + 1)\n\nfor a, b in AB:\n\n    G[a].add(b)\n\n    count[b] += 1\n\nfor i in range(1, N):\n\n    if count[i] == 0:\n\n        root = collections.deque([i])\n\n        break\n\nwhile root:\n\n    p = root.popleft()\n\n    for c in G[p]:\n\n        count[c] -= 1\n\n        if count[c] == 0:\n\n            ans[c] = p\n\n            root.append(c)\n\nprint(*ans[1:], sep='\\n')\n", "output": "A", "improve_diff": 1.7475708548, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nf=[]\n\nfor i in range(n):\n\n    tmp=0\n\n    op=list(map(int,input().split()))\n\n    for j in range(10):\n\n        tmp+=op[j]<<j\n\n    f.append(tmp)\n\n\n\np=[]\n\nfor i in range(n):\n\n    p.append(list(map(int,input().split())))\n\n\n\nans=-10**12\n\nfor i in range(1, 1<<10):\n\n    tmp=0\n\n    for j in range(n):\n\n        consist=f[j]&i\n\n        cnt=0\n\n        for k in range(10):\n\n            if (consist>>k)%2:\n\n                cnt+=1\n\n        tmp+=p[j][cnt]\n\n    ans=max(ans,tmp)\n\nprint(ans) \nB. n=int(eval(input()))\n\nf=[]\n\nfor i in range(n):\n\n    tmp=0\n\n    op=list(map(int,input().split()))\n\n    for j in range(10):\n\n        tmp+=op[j]<<j\n\n    f.append(tmp)\n\n\n\np=[]\n\nfor i in range(n):\n\n    p.append(list(map(int,input().split())))\n\n\n\nans=-10**12\n\nfor i in range(1, 1<<10):\n\n    tmp=0\n\n    for j in range(n):\n\n        consist=list(bin(f[j]&i)[2:])\n\n        cnt=0\n\n        for k in consist:\n\n            if k=='1':\n\n                cnt+=1\n\n        tmp+=p[j][cnt]\n\n    ans=max(ans,tmp)\n\nprint(ans)", "output": "A", "improve_diff": 1.0238726281, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def calc():\n\n  n,ma,mb=list(map(int,input().split()))\n\n  dp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\n  arr=[list(map(int,input().split())) for _ in range(n)]\n\n  dp[0][0][0]=0\n\n  for t in range(n):\n\n    a,b,c=arr[t]\n\n    for i in range(401):\n\n      for j in range(401):\n\n        if dp[t][i][j]==5000:\n\n          continue\n\n        dp[t+1][i][j]=min(dp[t+1][i][j],dp[t][i][j])\n\n        dp[t+1][i+a][j+b]=min(dp[t+1][i+a][j+b],dp[t][i][j]+c)\n\n  ans=5000\n\n  for i in range(1,401):\n\n    if i*ma>400 or i*mb>400:\n\n      break\n\n    ans=min(ans,dp[n][i*ma][i*mb])\n\n  if ans==5000:\n\n    print((-1))\n\n  else:\n\n    print(ans)\n\n    \n\ncalc() \nB. N , Ma, Mb = list(map(int, input().split()))\n\n\n\n# \n\n\n\narr=[list(map(int,input().split())) for _ in range(N)]\n\n\n\n#a = [0] * N\n\n#b = [0] * N\n\n#c = [0] * N\n\n\n\n#for i in range(N):\n\n#    a[i], b[i], c[i] = map(int, input().split())\n\n\n\n\n\n\n\n# TLEinf5000\n\nINF = 5000\n\n# 10 * N + 1 \u2192\n\n\n\n# inf\n\n# dp[i][sun_a][sum_b]\n\ndp = [[[INF] * (10 * N + 1) for _ in range(10 * N + 1)] for _ in range(N+1)]\n\n\n\n# 0\n\n\n\ndp[0][0][0] = 0\n\nfor i in range(N):\n\n    a,b,c=arr[i]\n\n    for j in range(10*N+1):\n\n        for k in range(10*N+1):\n\n            if dp[i][j][k] == INF:\n\n                continue\n\n            \n\n            # \n\n            dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k])\n\n            # \n\n            dp[i+1][j+a][k+b] = min(dp[i+1][j+a][k+b], dp[i][j][k] + c)\n\n\n\n\n\nans = INF\n\n# 001\n\n\n\n# TLE\n\n#for i in range(1,10 * N + 1):\n\n#    for j in range(1,10 * N + 1):\n\n#        if i * Mb != j * Ma:\n\n#            continue\n\n#        ans = min(ans, dp[N][i][j])\n\n#\n\n\n\nfor i in range(1, 10*N+1):\n\n        if i*Ma>10*N or i*Mb>10*N:\n\n            break\n\n        ans = min(ans, dp[N][i*Ma][i*Mb])\n\n\n\nif ans == INF:\n\n    print((-1))\n\nelse:\n\n    print(ans)", "output": "B", "improve_diff": 8.6662420928, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. H, W = list(map(int, input().split()))\n\nS = H * W\n\nans = S\n\n\n\nfor h in range(1,H):\n\n    s1 = h * W\n\n    s2 = W // 2 * (H-h)\n\n    s3 = S-s1-s2\n\n    ans = min(ans,max(s1,s2,s3)-min(s1,s2,s3))\n\n\n\n    s2 = (H-h) // 2 * W\n\n    s3 = S-s1-s2\n\n    ans = min(ans,max(s1,s2,s3)-min(s1,s2,s3))\n\n\n\nfor w in range(1,W):\n\n    s1 = H * w\n\n    s2 = H // 2 * (W-w)\n\n    s3 = S-s1-s2\n\n    ans = min(ans,max(s1,s2,s3)-min(s1,s2,s3))\n\n\n\n    s2 = (W-w) // 2 * H\n\n    s3 = S-s1-s2\n\n    ans = min(ans,max(s1,s2,s3)-min(s1,s2,s3))\n\n\n\nprint(ans) \nB. H, W = list(map(int, input().split()))\n\nans = float('inf')\n\nfor h in range(1,H):\n\n    S = [h * W]\n\n    w = W // 2\n\n    S += [(H-h) * w]\n\n    S += [(H-h) * (W-w)]\n\n    ans = min(ans,max(S)-min(S))\n\n\n\nfor h in range(1,H):\n\n    S = [h * W]\n\n    hb = (H-h) // 2\n\n    S += [hb * W]\n\n    S += [(H-h-hb) * W]\n\n    ans = min(ans,max(S)-min(S))\n\n\n\nfor w in range(1,W):\n\n    S = [H * w]\n\n    h = H // 2\n\n    S += [h * (W-w)]\n\n    S += [(H-h) * (W-w)]\n\n    ans = min(ans,max(S)-min(S))\n\n\n\nfor w in range(1,W):\n\n    S = [w * H]\n\n    wb = (W-w) // 2\n\n    S += [wb * H]\n\n    S += [(W-w-wb) * H]\n\n    ans = min(ans,max(S)-min(S))\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.2721749701, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\na, b, c, d = list(map(int, input().split()))\n\n\n\nhoge = []\n\nhoge.append(a*c)\n\nhoge.append(a*d)\n\nhoge.append(b*c)\n\nhoge.append(b*d)\n\n\n\nif max(hoge) < 0:\n\n  if np.sign(a) != np.sign(b) or np.sign(c) != np.sign(d):\n\n    print((0))\n\n  else:\n\n    print((max(hoge)))\n\nelse:\n\n  print((max(hoge))) \nB. import numpy as np\n\na, b, c, d = list(map(int, input().split()))\n\n\n\nhoge = []\n\nhoge.append(a*c)\n\nhoge.append(a*d)\n\nhoge.append(b*c)\n\nhoge.append(b*d)\n\n\n\nprint((max(hoge)))", "output": "B", "improve_diff": 1.0270563738, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom itertools import combinations_with_replacement, product\n\nimport numpy as np\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\ndef main():\n\n    n, m, x = list(map(int, input().split()))\n\n    data = np.zeros((n,m),int)\n\n    clist = np.zeros(n, int)\n\n    ans=10**10\n\n    for i in range(n):\n\n        ca = list(map(int, input().split()))\n\n        clist[i]=ca[0]\n\n        data[i]=np.array(ca[1:])\n\n    for bit in list(product([0,1],repeat=n)):\n\n        if all(np.dot(np.array(bit), data)>=x):\n\n            ans=min(ans,np.dot(np.array(bit),clist.T))\n\n    \n\n    if ans==10**10:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. import sys\n\nfrom itertools import combinations_with_replacement, product\n\nimport numpy as np\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    n, m, x = list(map(int, input().split()))\n\n    data = np.zeros((n,m+1),int)\n\n    ans=10**10\n\n    for i in range(n):\n\n        data[i]=np.array(list(map(int, input().split())))\n\n    for bit in list(product([0,1],repeat=n)):\n\n        calc=np.dot(np.array(bit), data)\n\n        if all(calc[1:]>=x):\n\n            ans=min(ans,calc[0])\n\n    \n\n    if ans==10**10:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()", "output": "B", "improve_diff": 1.0295770186, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(input())\n\nA = list(map(int, input().split()))\n\n\n\n\n\ndef ans():\n\n    if 0 in A:\n\n        return print(0)\n\n    product = 1\n\n    for num in A:\n\n        product = product * num\n\n        if product > 10 ** 18:\n\n            return print(-1)\n\n\n\n    print(product)\n\n\n\n\n\nans()\n \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nif 0 in A:\n\n    print((0))\n\n    exit()\n\nproduct = 1\n\nfor num in A:\n\n    product = product * num\n\n    if product > 10 ** 18:\n\n        print((-1))\n\n        exit()\n\n\n\nprint(product)", "output": "B", "improve_diff": 1.0463743025, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. H,W = list(map(int,input().split()))\n\n#l = sorted([int(input()) for i in range(N)],reverse=True)\n\ndef three(h,w):\n\n    ans = h*w\n\n    for i in range(1,h):\n\n        A = w*i\n\n        B = w*((h-i)//2)\n\n        C = w*((h-i+1)//2)\n\n        ans = min(ans,max(A,B,C)-min(A,B,C))\n\n    return ans\n\ndef onetwo(h,w):\n\n    ans = h*w\n\n    for i in range(1,h):\n\n        A = w*i\n\n        B = (h-i)*(w//2)\n\n        C = (h-i)*((w+1)//2)\n\n        ans = min(ans,max(A,B,C)-min(A,B,C))\n\n    return ans\n\nprint((min(three(H,W),three(W,H),onetwo(H,W),onetwo(W,H)))) \nB. H,W = list(map(int,input().split()))\n\n#l = sorted([int(input()) for i in range(N)],reverse=True)\n\ndef three(h,w):\n\n    ans = h*w\n\n    for i in range(h//3,h//3+2):\n\n        A = w*i\n\n        B = w*((h-i)//2)\n\n        C = w*((h-i+1)//2)\n\n        ans = min(ans,max(A,B,C)-min(A,B,C))\n\n    return ans\n\ndef onetwo(h,w):\n\n    ans = h*w\n\n    for i in range(h//3,h//3+2):\n\n        A = w*i\n\n        B = (h-i)*(w//2)\n\n        C = (h-i)*((w+1)//2)\n\n        ans = min(ans,max(A,B,C)-min(A,B,C))\n\n    return ans\n\nprint((min(three(H,W),three(W,H),onetwo(H,W),onetwo(W,H))))", "output": "B", "improve_diff": 5.3755709321, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nlis = []\n\nfor i in range(N):\n\n    lis.append(list(map(int,input().split())))\n\nlis = sorted(lis, key = lambda x:x[1])\n\na = 0\n\nfor j in range(N):\n\n    a += lis[j][0]\n\n    if a > lis[j][1]:\n\n        print('No')\n\n        exit()\n\nprint('Yes') \nB. N = int(eval(input()))\n\nlis = []\n\nfor i in range(N):\n\n    lis.append(list(map(int,input().split())))\n\nlis.sort(key = lambda x:x[1])\n\na = 0\n\nfor j in range(N):\n\n    a += lis[j][0]\n\n    if a > lis[j][1]:\n\n        print('No')\n\n        exit()\n\nprint('Yes')", "output": "B", "improve_diff": 1.0309671304, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools as i;d=[0]*91\n\nfor _ in[0]*int(eval(input())):d[ord(input()[0])]+=1\n\nprint((sum(d[p]*d[q]*d[r]for p,q,r in i.combinations(list(map(ord,'MARCH')),3)))) \nB. import itertools as i,collections as c\n\nn,*a=open(0).read().split()\n\nb=c.Counter(s[0]for s in a if s[0]in\"MARCH\")\n\nprint((sum(p*q*r for p,q,r in i.combinations(list(b.values()),3))))", "output": "A", "improve_diff": 1.4927729412, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k = list(map(int, input().split()))\n\nmod = 10**9+7\n\n\n\ndef power(a, n, mod):\n\n    bi=str(format(n,\"b\")) #2\n\n    res=1\n\n    for i in range(len(bi)):\n\n        res=(res*res) %mod\n\n        if bi[i]==\"1\":\n\n            res=(res*a) %mod\n\n    return res\n\n\n\nD = [0]*(k+1)\n\nans = 0\n\nfor i in reversed(list(range(1, k+1))):\n\n    a = k//i\n\n    d = power(a, n, mod)\n\n    j = 1\n\n    while i*j <= k:\n\n        d -= D[i*j]\n\n        j += 1\n\n    D[i] = d\n\n    ans += (d*i)%mod\n\n\n\nprint((ans%mod)) \nB. n, k = list(map(int, input().split()))\n\n\n\nmod = 10**9+7\n\n\n\ndef power(a, n, mod):\n\n  bi=str(format(n,\"b\")) #2\n\n  res=1\n\n  for i in range(len(bi)):\n\n    res=(res*res) %mod\n\n    if bi[i]==\"1\":\n\n      res=(res*a) %mod\n\n  return res\n\n\n\n\n\nX = [0]*(k+1)\n\nans = 0\n\nfor i in reversed(list(range(1, k+1))):\n\n    temp = power(k//i, n, mod)\n\n    j = i+i\n\n    while j <= k:\n\n        temp -= X[j]\n\n        j += i\n\n    X[i] = temp\n\n    ans += (temp*i)%mod\n\nprint((ans%mod))\n", "output": "B", "improve_diff": 1.2033756126, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from heapq import heappush, heappop, heapify\n\nfrom collections import deque, defaultdict, Counter\n\nimport itertools\n\nfrom itertools import permutations, combinations, accumulate\n\nimport sys\n\nimport bisect\n\nimport string\n\nimport math\n\nimport time\n\n\n\n\n\ndef I(): return int(input())\n\n\n\n\n\ndef MI(): return map(int, input().split())\n\n\n\n\n\ndef S(): return input()\n\n\n\n\n\ndef MS(): return map(str, input().split())\n\n\n\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\n\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\n\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\n\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\n\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef show(*inp, end='\\n'):\n\n    if show_flg:\n\n        print(*inp, end=end)\n\n\n\n\n\nYN = {False: 'No', True: 'Yes'}\n\nMOD = 10**9+7\n\ninf = float('inf')\n\nIINF = 10**10\n\nl_alp = string.ascii_lowercase\n\nu_alp = string.ascii_uppercase\n\nts = time.time()\n\nsys.setrecursionlimit(10**6)\n\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\n\n\n\n\nshow_flg = True\n\nshow_flg = False\n\n\n\n\n\ndef main():\n\n    H, N = MI()\n\n    A = [0] * N\n\n    B = [0] * N\n\n    dp = [[IINF] * (H+2) for i in range(N+1)]\n\n    dp[0][0] = 0\n\n\n\n    for i in range(N):\n\n        A[i], B[i] = MI()\n\n        # AB[i] = (A / B, A, B)\n\n\n\n    # print(dp)\n\n    for i in range(N):\n\n        for j in range(H+1):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            max_h = min(H, j+A[i])\n\n            dp[i+1][max_h] = min(dp[i+1][max_h], dp[i+1][j] + B[i])\n\n    print(dp[N][H])\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. from heapq import heappush, heappop, heapify\n\nfrom collections import deque, defaultdict, Counter\n\nimport itertools\n\nfrom itertools import permutations, combinations, accumulate\n\nimport sys\n\nimport bisect\n\nimport string\n\nimport math\n\nimport time\n\n\n\n\n\ndef I(): return int(input())\n\n\n\n\n\ndef MI(): return map(int, input().split())\n\n\n\n\n\ndef S(): return input()\n\n\n\n\n\ndef MS(): return map(str, input().split())\n\n\n\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\n\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\n\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\n\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\n\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef show(*inp, end='\\n'):\n\n    if show_flg:\n\n        print(*inp, end=end)\n\n\n\n\n\nYN = {False: 'No', True: 'Yes'}\n\nMOD = 10**9+7\n\ninf = float('inf')\n\nIINF = 10**10\n\nl_alp = string.ascii_lowercase\n\nu_alp = string.ascii_uppercase\n\nts = time.time()\n\nsys.setrecursionlimit(10**6)\n\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\n\n\n\n\nshow_flg = True\n\nshow_flg = False\n\n\n\n\n\ndef main():\n\n    H, N = MI()\n\n    A = [0] * N\n\n    B = [0] * N\n\n    dp = [IINF] * (H+1)\n\n    dp[0] = 0\n\n\n\n    for i in range(N):\n\n        A[i], B[i] = MI()\n\n        # AB[i] = (A / B, A, B)\n\n\n\n    for i in range(N):\n\n        dp_next = [IINF] * (H + 1)\n\n        for j in range(H+1):\n\n            dp_next[j] = min(dp[j], dp_next[j])\n\n            if j + A[i] <= H:\n\n                dp_next[j+A[i]] = min(dp_next[j+A[i]], dp_next[j] + B[i])\n\n            else:\n\n                # print(i, j, dp_next[j] + B[i], dp_next[j])\n\n                dp_next[H] = min(dp_next[H], dp_next[j] + B[i])\n\n                # print(dp_next[H])\n\n        dp = dp_next\n\n        # print(dp)\n\n\n\n    print(dp[H])\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.0473809808, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput=lambda: sys.stdin.readline().rstrip()\n\nmod=10**9+7\n\nn,k=list(map(int,input().split()))\n\nn_max=2*(10**5+1)\n\nF,FI=[0]*(n_max+1),[0]*(n_max+1)\n\nF[0],FI[0]=1,1\n\nfor i in range(n_max):\n\n  F[i+1]=(F[i]*(i+1))%mod\n\nFI[n_max-1]=pow(F[n_max-1],mod-2,mod)\n\nfor i in reversed(list(range(n_max-1))):\n\n  FI[i]=(FI[i+1]*(i+1))%mod\n\ndef comb(x,y):\n\n  return (F[x]*FI[x-y]*FI[y])%mod\n\n\n\nfor i in range(1,k+1):\n\n  if n-k<i-1:\n\n    print((0))\n\n  else:\n\n    print(((comb(k-i+i-1,k-i)*comb(n-k-(i-1)+i,n-k-(i-1)))%mod)) \nB. import math\n\nmod=10**9+7\n\nn,k=list(map(int,input().split()))\n\ndef f(x):\n\n  if x<0:\n\n    return 1\n\n  else:\n\n    return math.factorial(x)\n\ndef c(x,y):\n\n  if x<y or y<0:\n\n    return 0\n\n  elif y==0:\n\n    return 1\n\n  else:\n\n    return f(x)//f(x-y)//f(y)\n\nif k==1:\n\n  print(n)\n\nelif n==k:\n\n  print((1))\n\n  for i in range(n-1):\n\n    print((0))\n\nelse:  \n\n  for i in range(1,k+1):\n\n    ans=c(k-1,i-1)\n\n    ans*=(c(n-k-1,i)+2*c(n-k-1,i-1)+c(n-k-1,i-2))\n\n    print((ans%mod))", "output": "B", "improve_diff": 6.347915529, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nA = list([-x for x in A])\n\nheapq.heapify(A)\n\n\n\nwhile M > 0:\n\n    heapq.heappush(A, -(-heapq.heappop(A) // 2))\n\n    M -= 1\n\n\n\nprint((-sum(A)))\n \nB. import heapq\n\ndef f(str):\n\n    return -int(str)\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list(map(f, input().split()))\n\nheapq.heapify(A)\n\n\n\nwhile M > 0:\n\n    heapq.heappush(A, -(-heapq.heappop(A) // 2))\n\n    M -= 1\n\n\n\nprint((-sum(A)))\n", "output": "A", "improve_diff": 1.0217826034, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\n\n\nN,A,B,C = list(map(int,input().split()))\n\nComb = itertools.product([0,1,2,3],repeat=N)\n\n\n\nL = []\n\nfor i in range(N):\n\n  l = int(eval(input()))\n\n  L.append(l)\n\n  \n\n#   \n\n# 0 : \n\n# 1 : A  \n\n# 2 : B \n\n# 3 : C\n\n# A,B,C :\n\n#  \u2192 \n\n\n\nans = float('inf')\n\nfor X in Comb:\n\n  tmp = 0\n\n  m_A,m_B,m_C = [],[],[]\n\n  for i in range(N):\n\n    if(X[i] == 1): m_A.append(L[i])\n\n    elif(X[i] == 2): m_B.append(L[i])\n\n    elif(X[i] == 3): m_C.append(L[i])\n\n  #     \n\n  if(len(m_A)*len(m_B)*len(m_C) != 0):      \n\n    for take_list,take_len in zip([m_A,m_B,m_C],[A,B,C]):\n\n      tmp += (len(take_list)-1)*10 # \n\n      tmp += (abs(take_len-sum(take_list)))*1 # or\n\n    ans = min(ans,tmp)\n\n  \n\nprint(ans)   \nB. import itertools\n\n\n\nN,A,B,C = list(map(int,input().split()))\n\ncomb = [] #0:,1:A,2:B,3:C\n\nL = []\n\nfor i in range(N):\n\n  l = int(eval(input()))\n\n  L.append(l)\n\n  comb.append([0,1,2,3])\n\n\n\nAll_comb =  list(itertools.product(*comb))\n\nmin_MP = float('inf')\n\nfor i in range(len(All_comb)):\n\n  tmp = All_comb[i]\n\n  Non_material = []\n\n  A_material = []\n\n  B_material = []\n\n  C_material = []\n\n  for j in range(len(tmp)):\n\n    if(tmp[j] == 0): Non_material.append(L[j])\n\n    elif(tmp[j] == 1): A_material.append(L[j])\n\n    elif(tmp[j] == 2): B_material.append(L[j])\n\n    elif(tmp[j] == 3): C_material.append(L[j])\n\n    a,b,c = len(A_material),len(B_material),len(C_material)\n\n    if((a>=1)and(b>=1)and(c>=1)):\n\n     sum_A,sum_B,sum_C = sum(A_material),sum(B_material),sum(C_material)\n\n     MP = abs(A-sum_A)+abs(B-sum_B)+abs(C-sum_C) +10*(a+b+c-3)\n\n     min_MP = min(MP,min_MP)\n\n\n\nprint(min_MP)\n\n    ", "output": "A", "improve_diff": 1.9488922936, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    A = [int(a) for a in input().split()]\n\n    AD = dict()\n\n    for a in A:\n\n        if a in AD: AD[a] += 1\n\n        else: AD[a] = 1\n\n\n\n    count = 0\n\n    for key in AD:\n\n        if AD[key] == key: continue\n\n        elif AD[key] > key: count += AD[key] - key\n\n        else: count += AD[key]\n\n    print(count)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. from collections import defaultdict\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nD = defaultdict(int)\n\n\n\nfor i in range(N):\n\n    D[A[i]] += 1\n\n\n\ndelete = 0\n\nfor d in D:\n\n    if d < D[d]:\n\n        delete += D[d] - d\n\n    elif d > D[d]:\n\n        delete += D[d]\n\nprint(delete)\n", "output": "A", "improve_diff": 1.3957117579, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    X, Y = (int(i) for i in input().split())\n\n    if (X+Y) % 3 != 0:\n\n        return print(0)\n\n    m = (X + Y)//3 + 3\n\n    fac = [0] * m\n\n    finv = [0] * m\n\n    inv = [0] * m\n\n    MOD = 10**9 + 7\n\n\n\n    def COMBinitialize(m):\n\n        fac[0] = 1\n\n        finv[0] = 1\n\n        if m > 1:\n\n            fac[1] = 1\n\n            finv[1] = 1\n\n            inv[1] = 1\n\n            for i in range(2, m):\n\n                fac[i] = fac[i-1] * i % MOD\n\n                inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\n                finv[i] = finv[i - 1] * inv[i] % MOD\n\n\n\n    def COMB(n, k):\n\n        if n < k:\n\n            return 0\n\n        if n < 0 or k < 0:\n\n            return 0\n\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\n\n\n    COMBinitialize(m)\n\n    n = (X+Y)//3\n\n    k = X - n\n\n    print(COMB(n, k))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    X, Y = (int(i) for i in input().split())\n\n    fac = [0] * max(X, Y)\n\n    finv = [0] * max(X, Y)\n\n    inv = [0] * max(X, Y)\n\n    MOD = (10**9) + 7\n\n\n\n    def COMinit(m):\n\n        fac[0] = 1\n\n        finv[0] = 1\n\n        if m > 1:\n\n            fac[1] = 1\n\n            finv[1] = 1\n\n            inv[1] = 1\n\n            for i in range(2, m):\n\n                fac[i] = fac[i-1] * i % MOD\n\n                inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\n                finv[i] = finv[i - 1] * inv[i] % MOD\n\n\n\n    def COM(n, k):\n\n        if n < k:\n\n            return 0\n\n        if n < 0 or k < 0:\n\n            return 0\n\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\n\n\n    COMinit(max(X, Y))\n\n    if (X+Y) % 3 != 0:\n\n        return print(0)\n\n    n = (2*Y - X) // 3\n\n    m = (2*X - Y) // 3\n\n    print(COM(n+m, m))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.3843938341, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\n\n\n\n\ndef dijkstra(s):\n\n    inf=float(\"inf\")\n\n    color=[\"white\" for _ in range(n)]\n\n    D=[inf for _ in range(n)]\n\n\n\n    M=[[] for _ in range(n)]\n\n    for a,b,c in ABC:\n\n        M[a-1].append([b-1,c])\n\n        M[b-1].append([a-1,c])\n\n\n\n    D[s]=0\n\n\n\n    H=[(0,s)]\n\n    heapq.heapify(H)\n\n\n\n    while len(H)>=1:\n\n        u=heapq.heappop(H)[1]\n\n        if color[u]==\"black\":continue\n\n        color[u]=\"black\"\n\n\n\n        V=[(i,j) for i,j in M[u] if color[i]!=\"black\"]\n\n        while len(V)!=0:\n\n            for i,j in V:\n\n                if D[u]+j<D[i]:\n\n                    D[i]=D[u]+j\n\n                    color[i]=\"gray\"\n\n                    heapq.heappush(H,(D[i],i))\n\n            break\n\n\n\n    return D\n\n\n\n\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n-1)]\n\nq,k=list(map(int,input().split()))\n\nXY=[list(map(int,input().split())) for _ in range(q)]\n\nD=dijkstra(k-1)\n\nfor x,y in XY:\n\n    print((D[x-1]+D[y-1])) \nB. import heapq\n\nimport sys\n\ninput=sys.stdin.readline\n\n\n\n\n\ndef dijkstra(s):\n\n    inf=float(\"inf\")\n\n    color=[\"white\" for _ in range(n)]\n\n    D=[inf for _ in range(n)]\n\n\n\n    M=[[] for _ in range(n)]\n\n    for a,b,c in ABC:\n\n        M[a-1].append([b-1,c])\n\n        M[b-1].append([a-1,c])\n\n\n\n    D[s]=0\n\n\n\n    H=[(0,s)]\n\n    heapq.heapify(H)\n\n\n\n    while len(H)>=1:\n\n        u=heapq.heappop(H)[1]\n\n        if color[u]==\"black\":continue\n\n        color[u]=\"black\"\n\n\n\n        V=[(i,j) for i,j in M[u] if color[i]!=\"black\"]\n\n        while len(V)!=0:\n\n            for i,j in V:\n\n                if D[u]+j<D[i]:\n\n                    D[i]=D[u]+j\n\n                    color[i]=\"gray\"\n\n                    heapq.heappush(H,(D[i],i))\n\n            break\n\n\n\n    return D\n\n\n\n\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n-1)]\n\nq,k=list(map(int,input().split()))\n\nXY=[list(map(int,input().split())) for _ in range(q)]\n\nD=dijkstra(k-1)\n\nfor x,y in XY:\n\n    print((D[x-1]+D[y-1]))", "output": "B", "improve_diff": 1.0784920339, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nf = list(map(int,input().split()))\n\nf.sort(reverse = True)\n\nans = 0\n\nif n%2 == 0:\n\n    for i in range(n//2):\n\n        ans += f[i] * 2\n\n    ans -= f[0]\n\nelse:\n\n    for i in range(n//2):\n\n        ans += f[i] * 2\n\n    ans += f[n//2]-f[0]\n\n\n\nprint(ans)\n \nB. import math\n\n\n\nn = int(eval(input()))\n\nf = list(map(int,input().split()))\n\nf.sort()\n\nans = 0\n\n\n\nfor i in range(1,n):\n\n    ans += f[n-math.floor(i/2)-1]\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.191800079, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nD = list(map(int, input().split()))\n\nm = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\nd1 = {}\n\nfor d in D:\n\n    if d not in d1:\n\n        d1[d] = 1\n\n    else:\n\n        d1[d] += 1\n\nd2 = {}\n\nfor t in T:\n\n    if t not in d2:\n\n        d2[t] = 1\n\n    else:\n\n        d2[t] += 1\n\n\n\nfor k2, v2 in list(d2.items()):\n\n    if k2 not in d1:\n\n        print('NO')\n\n        exit()\n\n    else:\n\n        v1 = d1[k2]\n\n        if v1 < v2:\n\n            print('NO')\n\n            exit()\n\nelse:\n\n    print('YES')\n \nB. n= int(eval(input()))\n\nD = list(map(int, input().split()))\n\nm = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\nfrom collections import Counter\n\nC = Counter(D)\n\nfor t in T:\n\n    if t not in C:\n\n        print('NO')\n\n        exit()\n\n    else:\n\n        if C[t] == 0:\n\n            print('NO')\n\n            exit()\n\n        else:\n\n            C[t] -= 1\n\nelse:\n\n    print('YES')\n", "output": "A", "improve_diff": 1.4416802962, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=int(eval(input()))\n\np=[int(i) for i in input().split()]\n\nflag=1\n\nfor k in range(N-1):\n\n    if p[k]>p[k+1]:\n\n        flag=0\n\n        break\n\nif flag==1:\n\n    print(\"YES\")\n\n    exit()\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if i>=j:\n\n            continue\n\n        q=[p[i] for i in range(N)]\n\n        q[i],q[j]=q[j],q[i]\n\n        flag=1\n\n        for k in range(N-1):\n\n            if q[k]>q[k+1]:\n\n                flag=0\n\n                break\n\n        if flag==1:\n\n            print(\"YES\")\n\n            exit()\n\nprint(\"NO\")\n \nB. N=int(eval(input()))\n\np=[int(i) for i in input().split()]\n\ntmp=0\n\nfor i in range(N):\n\n    if p[i]!=i+1:\n\n        tmp+=1\n\nif tmp<=2:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")\n", "output": "B", "improve_diff": 1.0351171821, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\nfrom collections import deque\n\ndef main():\n\n    #\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n\n\n    #dfs\n\n    count=0\n\n    stack=deque([\"0\"])\n\n    while len(stack)>=1:\n\n        t=stack.pop()\n\n        for s in \"357\":\n\n            now=t+s\n\n            if int(now)>N:\n\n                break\n\n            if (\"7\" in now) and (\"5\" in now) and (\"3\" in now):\n\n                count+=1\n\n            stack.append(now)\n\n    \n\n    print(count)\n\n\n\nif __name__==\"__main__\":\n\n    main() \nB. N=int(eval(input()))\n\n\n\ndef dfs(s):\n\n    if int(s)>N:\n\n        return 0\n\n    else:\n\n        if all(s.count(c)>=1 for c in \"753\"):\n\n            res=1\n\n        else:\n\n            res=0\n\n        for c in \"753\":\n\n            res+=dfs(s+c)\n\n        return res\n\n\n\nprint((dfs(\"0\")))", "output": "A", "improve_diff": 1.0737552055, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nxx = (100 * n // 108) + 1\n\n# print(xx)\n\nfor x in range(xx + 1):\n\n    nn = int(x * 1.08 // 1)\n\n    if n == nn:\n\n        print(x)\n\n        exit(0)\n\nprint(':(')\n \nB. import math\n\n\n\nn = int(eval(input()))\n\nx = math.ceil(n / 1.08)\n\n\n\nif n == int(x * 1.08):\n\n  print(x)\n\nelse:\n\n  print(':(')\n", "output": "A", "improve_diff": 1.2658594122, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nN, A, B = list(map(int, input().split()))\n\nh = [0] * N\n\nfor i in range(N): h[i] = int(eval(input()))\n\nh.sort()\n\n\n\ndef check(x):\n\n  t = [h[i] - x * B for i in range(N)]\n\n  for i in range(N):\n\n    if t[i] > 0:\n\n      x -= -(-t[i] // (A - B))\n\n      if x < 0: return False\n\n  return x >= 0\n\n\n\nok = 10 ** 9\n\nng = 0\n\nwhile ok - ng > 1:\n\n  m = (ok + ng) // 2\n\n  if check(m): ok = m\n\n  else: ng = m\n\nprint(ok) \nB. import sys\n\ninput = sys.stdin.readline\n\nN, A, B = list(map(int, input().split()))\n\nh = []\n\nfor _ in range(N):\n\n  h.append(int(eval(input())))\n\nh.sort()\n\ndef explosive(x):\n\n  c = 0\n\n  for i in range(N):\n\n    if h[i] > x * B:\n\n      c += -(-(h[i] - x * B) // (A - B))\n\n  if c <= x: return True\n\n  else: return False\n\nng = 0\n\nok = 10 ** 9\n\nm = 0\n\nwhile ok - ng > 1:\n\n  m = (ng + ok) // 2\n\n  #print(m, explosive(m))\n\n  if explosive(m):\n\n    ok = m\n\n  else:\n\n    ng = m\n\nprint(ok)", "output": "B", "improve_diff": 1.0579065947, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\na,M,d=1,10**9+7,[1]\n\nfor i in range(1,n+1):\n\n  d.append(((m-n+i-1)*d[i-1]+(i-1)*d[i-2])%M)\n\n  a=a*(m-i+1)%M\n\nprint((a*d[-1]%M)) \nB. n,m=list(map(int,input().split()))\n\na,M,d=1,10**9+7,[1]\n\nfor i in range(n):\n\n  d.append(((m-n+i)*d[i]+i*d[i-1])%M)\n\n  a=a*(m-i)%M\n\nprint((a*d[-1]%M))", "output": "B", "improve_diff": 1.0506723037, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(a)]\n\nc = 1\n\nd = 0\n\ne = {}\n\nwhile True:\n\n    d += 1\n\n    if b[c-1] == 2:\n\n        print(d)\n\n        exit()\n\n    else:\n\n        if (c-1) not in e:\n\n            e.setdefault((c-1), \"\")\n\n        else:\n\n            print((-1))\n\n            exit()\n\n        c = b[c - 1]\n \nB. a = int(eval(input()))\n\nb = [[int(eval(input())), False]for i in range(a)]\n\nc = 1\n\nd = 0\n\nwhile True:\n\n    d += 1\n\n    if b[c-1][0] == 2:\n\n        print(d)\n\n        exit()\n\n    else:\n\n        b[c-1][1] = not b[c-1][1]\n\n        if b[c-1][1]:\n\n            c = b[c-1][0]\n\n        else:\n\n            print((-1))\n\n            exit()\n", "output": "B", "improve_diff": 1.0458187187, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import accumulate\n\n\n\ndef main():\n\n    n, k = list(map(int, input().split()))\n\n    a = [0] + list(accumulate(list(map(int, input().split()))))\n\n\n\n    btfl = []\n\n    for i in range(0, n):\n\n        for j in range(i + 1, n + 1):\n\n            btfl.append(a[j] - a[i])\n\n\n\n    # AC\n\n    ans = 0\n\n    for i in range(50)[::-1]:\n\n        num, cnt = ans + pow(2, i), 0\n\n        for b in btfl:\n\n            if num == num & b:\n\n                cnt += 1\n\n        if cnt >= k:\n\n            ans = num\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. from itertools import accumulate\n\nn, k = list(map(int, input().split()))\n\na = [0] + list(accumulate(list(map(int, input().split()))))\n\n\n\nbtfl = []\n\nfor i in range(0, n):\n\n    for j in range(i + 1, n + 1):\n\n        btfl.append(a[j] - a[i])\n\n\n\n# AC\n\nans = 0\n\nfor i in range(50)[::-1]:\n\n    num, cnt = ans + pow(2, i), 0\n\n    for b in btfl:\n\n        if num == num & b:\n\n            cnt += 1\n\n    if cnt >= k:\n\n        ans = num\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0341013461, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nq = int(eval(input()))\n\n\n\nfrom collections import Counter\n\nC = Counter(A)\n\nC = dict(C)\n\nS = sum(A)\n\nfor i in range(q):\n\n    b, c = list(map(int, input().split()))\n\n    if b in C:\n\n        vb = C[b]\n\n        C[b] = 0\n\n        S -= b*vb\n\n        S += c*vb\n\n        print(S)\n\n        if c in C:\n\n            C[c] += vb\n\n        else:\n\n            C[c] = vb\n\n    else:\n\n        print(S)\n \nB. import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nS = sum(A)\n\n\n\nD = [0]*(10**5+1)\n\nfor a in A:\n\n    D[a] += 1\n\n\n\nq = int(eval(input()))\n\nfor i in range(q):\n\n    b, c = list(map(int, input().split()))\n\n    S -= D[b]*b\n\n    S += D[b]*c\n\n    D[c] += D[b]\n\n    D[b] = 0\n\n    print(S)\n", "output": "B", "improve_diff": 1.4050684386, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x // y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef dijkstra(N: int, nodes: list, src: int) -> list:\n\n    \"\"\" (, (0-indexed), ) \"\"\"\n\n    from heapq import heappush, heappop\n\n\n\n    # []\n\n    res = [INF] * N\n\n    # \n\n    que = [src]\n\n    res[src] = 0\n\n    # \n\n    while len(que) != 0:\n\n        # *N + \n\n        cur = heappop(que)\n\n        # \n\n        dist = cur // N\n\n        cur %= N\n\n        # cur\n\n        for nxt, cost in nodes[cur]:\n\n            # \n\n            if dist + cost < res[nxt]:\n\n                res[nxt] = dist + cost\n\n                # *N+ \n\n                heappush(que, (dist+cost)*N+nxt)\n\n    # src\n\n    return res\n\n\n\nN = INT()\n\nnodes = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    a, b, c = MAP()\n\n    a -= 1; b -= 1\n\n    nodes[a].append((b, c))\n\n    nodes[b].append((a, c))\n\n\n\nQ, K = MAP()\n\nK -= 1\n\nres = dijkstra(N, nodes, K)\n\nfor i in range(Q):\n\n    x, y = MAP()\n\n    x -= 1; y -= 1\n\n    ans = res[x] + res[y]\n\n    print(ans)\n \nB. # -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\n# (1000)\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nN = int(eval(input()))\n\nnodes = [[] for _ in range(N+1)]\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    # nodes[](, ))\n\n    nodes[a].append((b, c))\n\n    # \n\n    nodes[b].append((a, c))\n\n\n\nmemo = [0] * (N+1)\n\ndef dfs(cur, prev, dist):\n\n    memo[cur] = dist\n\n    for nxt, cost in nodes[cur]:\n\n        if nxt == prev:\n\n            continue\n\n        dfs(nxt, cur, dist+cost)\n\n\n\nQ, K = list(map(int, input().split()))\n\ndfs(K, -1, 0)\n\n\n\nfor i in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    # KK\n\n    print((memo[x] + memo[y]))\n", "output": "B", "improve_diff": 1.4094833395, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. c = [list(map(int, input().split())) for i in range(3) ]\n\n\n\nans = False\n\n\n\nfor i in range(101) :\n\n    for j in range(101) :\n\n        for k in range(101) :\n\n            b1 = c[0][0] - i\n\n            b2 = c[1][0] - i\n\n            b3 = c[2][0] - i\n\n            if j + b1 != c[0][1] :\n\n                continue\n\n            elif j + b2 != c[1][1] :\n\n                continue\n\n            elif j + b3 != c[2][1] :\n\n                continue\n\n            elif k + b1 != c[0][2] :\n\n                continue\n\n            elif k + b2 != c[1][2] :\n\n                continue\n\n            elif k + b3 != c[2][2] :\n\n                continue\n\n            ans = True\n\n\n\nif ans :\n\n    print('Yes')\n\nelse :\n\n    print('No')\n \nB. c = [list(map(int, input().split())) for i in range(3) ]\n\n\n\nans = False\n\n\n\nfor i in range(101) :\n\n    a1 = 0\n\n    b1 = c[0][0]\n\n    b2 = c[0][1]\n\n    b3 = c[0][2]\n\n    a2 = c[1][0] - b1\n\n    a3 = c[2][0] - b1\n\n    a = []\n\n    a.append(a1)\n\n    a.append(a2)\n\n    a.append(a3)\n\n    if a2 + b2 != c[1][1] :\n\n        continue\n\n    elif a3 + b2 != c[2][1] :\n\n        continue\n\n    elif a2 + b3 != c[1][2] :\n\n        continue\n\n    elif a3 + b3 != c[2][2] :\n\n        continue\n\n    ans = True\n\n    break\n\n\n\nif ans :\n\n    print('Yes')\n\nelse :\n\n    print('No')\n", "output": "B", "improve_diff": 24.7766181325, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import itertools\n\nimport math\n\nimport fractions\n\nimport functools\n\nimport copy\n\nn, m = list(map(int, input().split()))\n\npyi = []\n\nfor i in range(m):\n\n    p,y= list(map(int, input().split()))\n\n    pyi.append([p,y,i])\n\n\n\npyi.sort(key=lambda x: x[1])\n\npyi.sort(key=lambda x: x[0])\n\n\n\nken = 0\n\nfor i in range(m):\n\n    if pyi[i][0] != ken:\n\n        ken = pyi[i][0]\n\n        x = 1\n\n    else:\n\n        x += 1\n\n    pyi[i].append(x)\n\n\n\n\n\npyi.sort(key=lambda x: x[2])\n\nfor i in range(m):\n\n    print((str(pyi[i][0]).zfill(6)+str(pyi[i][3]).zfill(6))) \nB. def main():\n\n    # n = int(input())\n\n    n, m = list(map(int, input().split()))\n\n    # v = list(map(int, input().split()))\n\n    # s = input()\n\n    py = []\n\n    for i in range(m):\n\n        p, y = list(map(int, input().split()))\n\n        py.append([i, p, y])\n\n\n\n    py.sort(key=lambda x: (x[1], x[2]))\n\n\n\n    num = 1\n\n    for i in range(0, m):\n\n        if i == 0:\n\n            py[i].append(num)\n\n        else:\n\n            if py[i][1] == py[i-1][1]:\n\n                num += 1\n\n            else:\n\n                num = 1\n\n            py[i].append(num)\n\n\n\n    py.sort(key=lambda x: x[0])\n\n\n\n    for i in range(m):\n\n        print((str(py[i][1]).zfill(6) + str(py[i][3]).zfill(6)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 2.1917991509, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import*\n\nfrom heapq import*\n\nimport sys\n\ninput=sys.stdin.readline\n\n \n\ndef BFS(point,d):\n\n    cost=[1e18]*(n+1)\n\n    cost[point]=0\n\n    Q=deque()\n\n    Q.appendleft((0,point))\n\n    \n\n    while Q:\n\n        c,p=Q.pop()\n\n        for np,co in d[p]:\n\n            if cost[np]==1e18:\n\n                cost[np]=c+co\n\n                Q.appendleft((c+co,np))\n\n    return cost\n\n\n\nn=int(eval(input()))\n\nd=[[]for i in range(n+1)]\n\nfor i in range(n-1):\n\n    a,b,c=list(map(int,input().split()))\n\n    d[a].append([b,c])\n\n    d[b].append([a,c])\n\n#print(d)\n\nq,k=list(map(int,input().split()))\n\ny=BFS(k,d)\n\n \n\nfor i in range(q):\n\n    a,b=list(map(int,input().split()))\n\n    print((y[a]+y[b]))\n \nB. \n\nfrom heapq import*\n\nimport sys\n\ninput=sys.stdin.readline\n\n \n\ndef DIJKSTRA(point,d):\n\n    cost      = [1e18]*(n+1)\n\n    Q         = []  #\n\n    cost[point]=0  #\uff08\n\n    heappush(Q,(point,cost[point]))\n\n    while Q:\n\n        prefnd,tmpC=heappop(Q)\n\n        if cost[prefnd]<tmpC:\n\n            continue\n\n        for node,c in d[prefnd]:\n\n            altC=c+tmpC\n\n            if cost[node]>altC:\n\n                cost[node]=altC\n\n                heappush(Q,(node,altC))\n\n    return cost\n\n\n\nn=int(eval(input()))\n\nd=[[]for i in range(n+1)]\n\nfor i in range(n-1):\n\n    a,b,c=list(map(int,input().split()))\n\n    d[a].append([b,c])\n\n    d[b].append([a,c])\n\n\n\nq,k=list(map(int,input().split()))\n\ny=DIJKSTRA(k,d)\n\n \n\nfor i in range(q):\n\n    a,b=list(map(int,input().split()))\n\n    print((y[a]+y[b]))\n", "output": "B", "improve_diff": 1.195887585, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n\n\n# inputList=[]\n\n# for i in range(6):\n\n#     inputNum = input()\n\n#     inputList.append(inputNum)\n\ninputa = input().split()\n\n# inputb = input().split()\n\n\n\na = int(inputa[0])\n\nb = int(inputa[1])\n\nc = int(inputa[2])\n\n\n\n# x = int(inputb[0])\n\n# y = int(inputb[1])\n\n\n\nans = int(math.floor(float(b)/float(a)))\n\n\n\nif ans > c:\n\n    ans = c\n\n\n\nprint(ans) \nB. import sys\n\nimport re\n\nimport math\n\n\n\n# import bisect\n\n\n\n# import copy\n\n# import heapq\n\n# from collections import deque\n\n# import decimal\n\n\n\n# sys.setrecursionlimit(100001)\n\nINF = sys.maxsize\n\n# MOD = 10 ** 9 + 7\n\n\n\nni = lambda: int(sys.stdin.readline())\n\nns = lambda: list(map(int, sys.stdin.readline().split()))\n\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n\n\n\n# ===CODE===\n\n\n\n\n\ndef main():\n\n    a,b,c=ns()\n\n    print((min(c, b//a)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.5040705455, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\nK, N = list(map(int, input().split()))\n\nA = deque(list(map(int, input().split())))\n\nA.appendleft(K - A[-1] + A[0])\n\nsa_max = A[0]\n\nfor i in range(1, N):\n\n    sa = A[i + 1] - A[i]\n\n    if sa_max < sa:\n\n        sa_max = sa\n\nprint((A[-1] + A[0] - (sa_max + A[1])))\n \nB. K, N = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nA.append(K - A[-1] + A[0])\n\nsa_max = A[-1]\n\nfor i in range(N - 1):\n\n    sa = A[i + 1] - A[i]\n\n    if sa_max < sa:\n\n        sa_max = sa\n\nprint(((A[-2] - A[0]) + A[-1] - sa_max))\n", "output": "B", "improve_diff": 1.5096697861, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = list(map(int,input().split()))\n\nmax = -float('inf')\n\nx = []\n\ny = []\n\nz = []\n\nfor i in range(N):\n\n\txx,yy,zz = list(map(int,input().split()))\n\n\tx.append(xx)\n\n\ty.append(yy)\n\n\tz.append(zz)\n\nfor i in range(-1,2,2):\n\n\tfor j in range(-1,2,2):\n\n\t\tfor k in range(-1,2,2):\n\n\t\t\ts = []\n\n\t\t\tfor m in range(N):\n\n\t\t\t\ts.append(i*x[m]+j*y[m]+k*z[m])\n\n\t\t\ts = sorted(s)\n\n\t\t\ttmp = sum(s[-1*M:])\n\n\t\t\tif tmp > max:\n\n\t\t\t\tmax = tmp\n\nif M==0:\n\n\tprint((0))\n\nelse:\n\n\tprint(max) \nB. n,m = list(map(int,input().split()))\n\nxyz = [list(map(int,input().split())) for _ in range(n)]\n\nres = 0\n\nfor a in (1,-1):\n\n    for b in (1,-1):\n\n        for c in (1,-1):\n\n            l = []\n\n            for (x,y,z) in xyz:\n\n                l.append(x*a+y*b+z*c)\n\n            l = sorted(l,reverse=True)\n\n            res = max(res, sum(l[:m]))\n\nprint(res)\n", "output": "A", "improve_diff": 1.0185745656, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import accumulate\n\n\n\nn = int(eval(input()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort()\n\n\n\n# 12\n\ncumsum = list(accumulate(arr))\n\n\n\nresult = []\n\nfor x, y in zip(arr[1:], cumsum[:-1]):\n\n    if x <= y * 2:\n\n        result.append(True)\n\n    else:\n\n        result.append(False)\n\n\n\nif all(result):\n\n    ans = n\n\nelse:\n\n    ans = result[::-1].index(False) + 1\n\n\n\nprint(ans) \nB. import numpy as np\n\nimport sys\n\n\n\nn = int(eval(input()))\n\narr = np.array(list(map(int, input().split())))\n\n\n\narr.sort()\n\narr_cs = arr.cumsum()\n\n\n\nans = 0\n\nfor i in range(n - 1):\n\n    if arr_cs[i] * 2 < arr[i + 1]:\n\n        ans = i + 1\n\nelse:\n\n    print((n - ans))", "output": "A", "improve_diff": 9.2563030783, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n \nB. def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    left = 1\n\n    right = N\n\n\n\n    for _ in range(M):\n\n        l, r = list(map(int, input().split()))\n\n\n\n        if left < l:\n\n            left = l\n\n        if right > r:\n\n            right = r\n\n\n\n    ans = right - left\n\n\n\n    print((ans + 1 if ans >= 0 else 0))\n\n\n\n\n\nmain()\n", "output": "A", "improve_diff": 1.0280720538, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, l = list(map(int, input().split()))\n\na, b = sorted([l, l + n - 1])\n\nprint((sum(range((a + 1 if a > 0 else a),\n\n                (b - 1 if b < 0 else b) + 1)))) \nB. n, l = list(map(int, input().split()))\n\nif l > 0:\n\n    c = l\n\nelif l + n - 1 < 0:\n\n    c = l + n - 1\n\nelse:\n\n    c = 0\n\nprint((l * n + n * (n - 1) // 2 - c))", "output": "B", "improve_diff": 1.0347986703, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n  n,k = input_list()\n\n  a = input_list()\n\n  ans = 0\n\n  r = 1\n\n  while True:\n\n    r += k-1\n\n    ans += 1\n\n    if r >= n:\n\n      break\n\n  print(ans)\n\n  \n\ndef input_list():\n\n  return list(map(int, input().split()))\n\n\n\ndef input_list_str():\n\n  return list(map(str, input().split()))\n\n\n\ndef lcm_base(x, y):\n\n    return (x * y) // fractions.gcd(x, y)\n\n\n\ndef lcm_list(numbers):\n\n    return reduce(lcm_base, numbers, 1)\n\n\n\ndef gcd(*numbers):\n\n    return reduce(fractions.gcd, numbers)\n\n\n\ndef gcd_list(numbers):\n\n    return reduce(fractions.gcd, numbers)\n\n\n\n# 2\n\ndef divide_two(arg):\n\n  c = 0\n\n  while True:\n\n    if c >= 2:\n\n      break\n\n    if arg % 2 != 0:\n\n      break\n\n    arg //= 2\n\n    c += 1\n\n  return c \n\n\n\nimport math\n\nimport fractions\n\nimport collections\n\nfrom functools import reduce\n\nmain() \nB. import math\n\n\n\n\n\ndef main():\n\n    n, k = input_list()\n\n    a = input_list()\n\n    a = math.ceil((n-k)/(k-1))\n\n    print((1+a))\n\n\n\n\n\ndef input_list():\n\n    return list(map(int, input().split()))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "B", "improve_diff": 1.6754364485, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n'''Snippets for lcm.\n\nAvailable functions:\n\n- lcm: Compute least common multiple of a and b.\n\n'''\n\n\n\n\n\ndef lcm(a: int, b: int) -> int:\n\n    '''Compute least common multiple of a and b.\n\n    Args:\n\n        a: Int of number (greater than 0).\n\n        b: Int of number (greater than 0).\n\n    Returns:\n\n        least common multiple.\n\n    Landau notation: O(log n)\n\n    See:\n\n    https://gist.github.com/endolith/114336/eff2dc13535f139d0d6a2db68597fad2826b53c3\n\n    https://docs.python.org/3/library/sys.html#sys.version_info\n\n    '''\n\n\n\n    from sys import version_info\n\n\n\n    if version_info.major == 3 and version_info.minor >= 5:\n\n        from math import gcd\n\n    else:\n\n        from fractions import gcd\n\n\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    a, b, c, d = list(map(int, input().split()))\n\n    l = lcm(c, d)\n\n    x = b // c - (a - 1) // c\n\n    y = b // d - (a - 1) // d\n\n    z = b // l - (a - 1) // l\n\n    w = b - a + 1\n\n\n\n    print((w - (x + y - z)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. # -*- coding: utf-8 -*-\n\n'''Snippets for lcm.\n\nAvailable functions:\n\n- lcm: Compute least common multiple of a and b.\n\n'''\n\n\n\n\n\ndef lcm(a: int, b: int) -> int:\n\n    '''Compute least common multiple of a and b.\n\n    Args:\n\n        a: Int of number (greater than 0).\n\n        b: Int of number (greater than 0).\n\n    Returns:\n\n        least common multiple.\n\n    Landau notation: O(log n)\n\n    See:\n\n    https://gist.github.com/endolith/114336/eff2dc13535f139d0d6a2db68597fad2826b53c3\n\n    https://docs.python.org/3/library/sys.html#sys.version_info\n\n    '''\n\n\n\n    from sys import version_info\n\n\n\n    if version_info.major == 3 and version_info.minor >= 5:\n\n        from math import gcd\n\n    else:\n\n        from fractions import gcd\n\n\n\n    return a * b // gcd(a, b)\n\n\n\n\n\ndef main():\n\n    a, b, c, d = list(map(int, input().split()))\n\n    l = lcm(c, d)\n\n    x = b // c - (a - 1) // c\n\n    y = b // d - (a - 1) // d\n\n    z = b // l - (a - 1) // l\n\n    w = b - a + 1\n\n\n\n    if c % d == 0 or d % c == 0:\n\n        print((w - x))\n\n    else:\n\n        print((w - (x + y - z)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.054413886, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\n\n\n\"\"\"\n\n1X\uff0c\uff1f\n\nMX\uff0e\n\nM+2\uff0c2*X\n\n\n\nX\uff0c\n\n\n\n\"\"\"\n\ndef main():\n\n    import bisect\n\n    \n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    A.sort()\n\n    \n\n    def ch(X):\n\n        temp=0\n\n        \n\n        for i in range(N):#\n\n            l=A[i]\n\n            t=X-l\n\n            num=bisect.bisect_left(A,t)\n\n            temp+=N-num\n\n            \n\n        return temp>=M\n\n    \n\n    \n\n    ok=0\n\n    ng=2*(10**5) + 1\n\n    \n\n    while ng - ok > 1:\n\n        med=(ok+ng)//2\n\n        if ch(med):\n\n            ok=med\n\n        else:\n\n            ng=med\n\n            \n\n    # \uff0c\n\n    S=[0]*(N+1)\n\n    for i in range(N):\n\n        S[i+1]=S[i]+A[i]\n\n        \n\n    ans=0\n\n    temp=0\n\n    X=ok\n\n    for i in range(N):#\n\n        l=A[i]\n\n        t=X-l\n\n        num=bisect.bisect_left(A,t)\n\n        temp+=N-num\n\n        ans+=S[-1] - S[num] + (N-num)*l\n\n        # print(i,num,S[-1]-S[num],(N-num)*l)\n\n\n\n        \n\n    if temp>M:\n\n        ans-=X*(temp-M)\n\n        \n\n    print(ans)\n\n    \n\n        \n\n    \n\n        \n\n    \n\n            \n\n    \n\n            \n\n        \n\n            \n\n\n\nmain()\n \nB. import numpy as np\n\n\n\nN,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nAmax=max(A)\n\n\n\nn0 = 2**int(np.ceil(np.log2(2*Amax+1)))#Amax+12\n\n\n\nAfre=np.zeros(n0).astype(int)#(1~Amax+1)\n\nfor i in range(N):\n\n    Afre[A[i]]+=1\n\n\n\n#astype(int)\uff0crint\uff0e\n\nS = np.rint(np.fft.irfft(np.fft.rfft(Afre)*np.fft.rfft(Afre))).astype(int)\n\nScum =S.cumsum()#\n\nbd = N*N-M#M\n\ni=np.searchsorted(Scum,bd)#iM\n\n#i\n\nremove=((Scum[-1]-Scum[i])-M)*i\n\nans=0\n\nfor j in range(i+1,n0):\n\n    ans+=S[j]*j\n\nprint((ans-remove))", "output": "A", "improve_diff": 8.2873115252, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while True:\n\n    (n, x) =  [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for a in range(1, n+1):\n\n        for b in range(a+1, n+1):\n\n            for c in range(b+1, n+1):\n\n                if (a + b + c) == x:\n\n                    count += 1\n\n                elif (a + b + c) > x:\n\n                    break\n\n    print(count) \nB. while True:\n\n    (n, x) =  [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for a in range(1, n+1):\n\n        for b in range(a+1, n+1):\n\n            for c in range(b+1, n+1):\n\n                if (a + b + c) == x:\n\n                    count += 1\n\n    print(count)", "output": "A", "improve_diff": 1.0139152154, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. print(ord('\u0004\u0001\u000e 3\u0001\u0002 \u0005 \u000f  \u0005'[eval(input())%14])) \nB. print((b'\u0004\u0001\u000e 3\u0001\u0002 \u0005 \u000f  \u0005'[int(eval(input()))%14]))", "output": "B", "improve_diff": 1.025130421, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,X,Y=MI()\n\n    X-=1\n\n    Y-=1\n\n    \n\n    ##########################################\n\n    import heapq\n\n    class Dijkstra():\n\n        \"\"\"\n\n         / (\uff0c)\n\n        \n\n        O(E log|V|)\n\n        heap\uff08\uff0cque\uff09\n\n        \"\"\"\n\n        \n\n        #path\n\n        \n\n        \n\n        class Edge():\n\n            #\n\n            \n\n            def __init__(self, _to, _cost):\n\n                self.to =_to\n\n                self.cost = _cost\n\n        \n\n        def __init__(self, V):\n\n            #V\n\n            self.G = [[] for _ in range(V)] #G[u][i]ui\n\n            self. _E = 0 #\n\n            self._V = V #\n\n        \n\n        #proparty - \n\n        def E(self):\n\n            return self._E\n\n        \n\n        #proparty - \n\n        def V(self):\n\n            return self._V\n\n        \n\n        def add(self, _from, _to, _cost):\n\n            #2\n\n            self.G[_from].append(self.Edge(_to,_cost))\n\n            self._E +=1\n\n            \n\n        def add2(self, _from, _to, _cost):\n\n            #2\uff08\uff09\n\n            self.G[_from].append(self.Edge(_to, _cost))\n\n            self.G[_to].append(self.Edge(_from, _cost))\n\n            self._E +=1\n\n            \n\n        def shortest_path(self,s):\n\n            #si\n\n            \n\n            que = [] #priority queue\n\n            d = [float(\"inf\")] * self.V()\n\n            prev = [None]*self.V() #prev[j]\uff0csjj\n\n            d[s] = 0\n\n            heapq.heappush(que,(0,s)) #\n\n            \n\n            while len(que)!=0:\n\n                #\n\n                cost,v = heapq.heappop(que)\n\n                \n\n                #d\n\n                if d[v] < cost:\n\n                    continue\n\n                    \n\n                #vi\uff0cv\uff0cd[i]\n\n                for i in range(len(self.G[v])):\n\n                    e = self.G[v][i] #vi\n\n                    if d[e.to] > d[v] + e.cost:\n\n                        d[e.to] = d[v] + e.cost #\n\n                        prev[e.to] = v\n\n                        heapq.heappush(que,(d[e.to],e.to)) #que\n\n            \n\n                        \n\n            return d\n\n    ########################\n\n        \n\n    djk = Dijkstra(N)        \n\n    for i in range(N-1):\n\n        djk.add2(i,i+1,1)\n\n    djk.add2(X,Y,1)\n\n    \n\n    ans=[0]*(N+1)\n\n    \n\n    for i in range(N):\n\n        d=djk.shortest_path(i)\n\n        for j in range(N):\n\n            ans[d[j]]+=1\n\n            \n\n    for i in range(N-1):\n\n        print((ans[i+1]//2))\n\n        \n\n    \n\n\n\nmain()\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,X,Y=MI()\n\n    X-=1\n\n    Y-=1\n\n    \n\n    ans=[0]*N\n\n    \n\n    for i in range(N):\n\n        for j in range(i+1,N):\n\n            d=min(j-i,abs(X-i)+1+abs(Y-j))\n\n\n\n                \n\n            ans[d-1]+=1\n\n            \n\n    for i in range(N-1):\n\n        print((ans[i]))\n\n                \n\n\n\n                \n\n   \n\n\n\nmain()\n", "output": "B", "improve_diff": 1.4384849837, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nma = max(A)\n\nl = [0 for _ in range(ma + 10)]\n\nfor i in range(N):\n\n    temp = A[i]\n\n    while(temp <= ma + 5):\n\n        l[temp] += 1\n\n        temp += A[i]\n\nans = 0\n\nfor i in range(N):\n\n    if l[A[i]] == 1:  ans += 1\n\nprint(ans) \nB. N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nma = max(A)\n\nEr = [0 for _ in range(ma + 5)]\n\n\n\nfor i in range(N):\n\n    temp = A[i]\n\n    if Er[temp] != 2:\n\n        a = 0\n\n        while(1):\n\n            a += 1\n\n            tt = a * temp\n\n            if tt >= ma + 5:\n\n                break\n\n            Er[tt] += 1\n\n        \n\nans = 0\n\nfor i in range(N):\n\n    temp = A[i]\n\n    if Er[temp] == 1:  ans += 1\n\n        \n\nprint(ans)", "output": "A", "improve_diff": 1.0478626641, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, m, k = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\n\n\ntotal = 0\n\ncount = 0\n\nflag = n-1\n\nfor i in range(n):\n\n    total += a[i]\n\n    if total > k:\n\n        total -= a[i]\n\n        flag = i-1\n\n        break\n\n    count += 1\n\nans = count\n\nfor i in range(m):\n\n    if b[i] > k:\n\n        break\n\n    total += b[i]\n\n    count += 1\n\n    while total > k:\n\n        if flag == -1:\n\n            break\n\n        else:\n\n            total -= a[flag]\n\n            flag -= 1\n\n            count -= 1\n\n    if total > k: \n\n        break\n\n    ans = max(ans, count)\n\n\n\ntotal = 0\n\ncount = 0\n\nflag = m-1\n\nfor i in range(m):\n\n    total += b[i]\n\n    if total > k:\n\n        total -= b[i]\n\n        flag = i-1\n\n        break\n\n    count += 1\n\nfor i in range(n):\n\n    if a[i] > k:\n\n        break\n\n    total += a[i]\n\n    count += 1\n\n    while total > k:\n\n        if flag == -1:\n\n            break\n\n        else:\n\n            total -= b[flag]\n\n            flag -= 1\n\n            count -= 1\n\n    if total > k: \n\n        break\n\n    ans = max(ans, count)\n\n\n\n\n\nprint(ans) \nB. n, m, k = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\n\n\ntotal = 0\n\ncount = 0\n\nflag = n-1\n\nfor i in range(n):\n\n    total += a[i]\n\n    if total > k:\n\n        total -= a[i]\n\n        flag = i-1\n\n        break\n\n    count += 1\n\nans = count\n\nfor i in range(m):\n\n    if b[i] > k:\n\n        break\n\n    total += b[i]\n\n    count += 1\n\n    while total > k:\n\n        if flag == -1:\n\n            break\n\n        else:\n\n            total -= a[flag]\n\n            flag -= 1\n\n            count -= 1\n\n    if total > k: \n\n        break\n\n    ans = max(ans, count)\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.0258799233, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x, y, a, b, c = list(map(int, input().split()))\n\narrayP = list(map(int, input().split()))\n\narrayQ = list(map(int, input().split()))\n\narrayR = list(map(int, input().split()))\n\narrayP.sort(reverse=True)\n\narrayQ.sort(reverse=True)\n\narrayR.sort(reverse=True)\n\narrayAns = []\n\nfor i in range(x):\n\n    arrayAns.append(int(arrayP[i]))\n\nfor i in range(y):\n\n    arrayAns.append(int(arrayQ[i]))\n\narrayAns.sort()\n\nfor i in range(min(len(arrayR), len(arrayAns))):\n\n    if arrayAns[i] <= int(arrayR[i]):\n\n        arrayAns[i] = int(arrayR[i])\n\n    else:\n\n        break\n\nprint((sum(arrayAns))) \nB. X,Y,A,B,C = list(map(int, input().split()))\n\n\n\np = list(map(int, input().split()))\n\nq = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\n\n\np.sort(reverse=True)\n\nq.sort(reverse=True)\n\n\n\nhoge=p[:X]+q[:Y]+r\n\nhoge.sort(reverse=True)\n\nprint((sum(hoge[:X+Y])))\n\n\n\n\n", "output": "A", "improve_diff": 1.0213922501, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\n\"\"\"\n\n\n\n\n\n\"\"\"\n\n\n\n\n\ndef chmin(i, j):\n\n    a, b = dp[i+j], dp[i]+abs(h[i]-h[i+j])\n\n    if a > b:\n\n        dp[i+j] = b\n\n\n\n\n\nn, k = list(map(int, (input().split())))\n\nh = list(input().split())\n\nh = [int(i) for i in h]\n\ndp = [10**10]*n\n\ndp[0] = 0\n\nfor i in range(0, n):\n\n    for j in range(1, k+1):\n\n        if i+j < n:\n\n            chmin(i, j)\n\nprint((dp[n-1])) \nB. # -*- coding: utf-8 -*-\n\n\"\"\"\n\nB - Frog 2\n\nhttps://atcoder.jp/contests/dp/tasks/dp_b\n\nAC\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\n\n\n\n\ndef solve(ashiba, N, K):\n\n    dp = [float('inf')] * N\n\n    dp[0] = 0\n\n    for i in range(1, len(ashiba)):\n\n        paths = [dp[j]+abs(ashiba[j]-ashiba[i]) for j in range(max(0, i-K), i)]\n\n        dp[i] = min(paths)\n\n    return dp[-1]\n\n\n\n\n\ndef main(args):\n\n    N, K = list(map(int, input().split()))\n\n    ashiba = [int(i) for i in input().split()]\n\n    ans = solve(ashiba, N, K)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])\n", "output": "B", "improve_diff": 1.0959265937, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding: utf-8\n\nimport sys\n\nimport bisect\n\n\n\n\n\n\"\"\"Template\"\"\"\n\n\n\n\n\nclass IP:\n\n    \"\"\"\n\n    \n\n    \"\"\"\n\n    def __init__(self):\n\n        self.input = sys.stdin.readline\n\n\n\n    def I(self):\n\n        \"\"\"\n\n        1\n\n        :return: \n\n        \"\"\"\n\n        return int(eval(input()))\n\n\n\n    def IL(self):\n\n        \"\"\"\n\n        1(int\n\n        :return: \n\n        \"\"\"\n\n        return list(map(int, self.input().split()))\n\n\n\n    def SL(self):\n\n        \"\"\"\n\n        1\n\n        :return: \n\n        \"\"\"\n\n        return list(map(str, self.input().split()))\n\n\n\n    def ILS(self, n):\n\n        \"\"\"\n\n        1(int\n\n        :param n: \n\n        :return: \n\n        \"\"\"\n\n        return [int(self.input()) for _ in range(n)]\n\n\n\n    def SLS(self, n):\n\n        \"\"\"\n\n        1\uff08str\n\n        :param n: \n\n        :return: \n\n        \"\"\"\n\n        return [self.input() for _ in range(n)]\n\n\n\n\n\nclass Idea:\n\n    def __init__(self):\n\n        pass\n\n\n\n    def HF(self, p):\n\n        \"\"\"\n\n        Half enumeration\n\n        \n\n        p\n\n        \n\n        :param p: list : \n\n        :return: list : \n\n        \"\"\"\n\n        return sorted(set(p[i] + p[j] for i in range(len(p)) for j in range(i, len(p))))\n\n\n\n    def Bfs2(self, a):\n\n        \"\"\"\n\n        bit_full_search2\n\n        bit\n\n        210\n\n        :return: list\uff12 : \uff11 2(16)  2 10\n\n        \"\"\"\n\n        # \n\n        # https://blog.rossywhite.com/2018/08/06/bit-search/\n\n        # https://atcoder.jp/contests/abc105/submissions/4088632\n\n        value = []\n\n        for i in range(1 << len(a)):\n\n            output = []\n\n\n\n            for j in range(len(a)):\n\n                if ((i >> j) & 1) == 1:\n\n                    \"\"\"j+1i1\"\"\"\n\n                    # output.append(a[j])\n\n                    output.append(a[j])\n\n            value.append([format(i, 'b').zfill(16), sum(output)])\n\n\n\n        value.sort(key=lambda x: x[1])\n\n        bin = [value[k][0] for k in range(len(value))]\n\n        val = [value[k][1] for k in range(len(value))]\n\n        return bin, val\n\n\n\n\n\n\"\"\"\"\"\"\n\n\n\n\n\ndef main():\n\n    \"\"\"\"\"\"\n\n    # 1\n\n    r, e = range, enumerate\n\n    ip = IP()\n\n    id = Idea()\n\n\n\n    \"\"\"\"\"\"\n\n\n\n    \"\"\"\"\"\"\n\n    n = ip.I()\n\n    s = ''\n\n    while True:\n\n        r = n % (-2)\n\n        n //= -2\n\n        if r < 0:\n\n            r += 2\n\n            n += 1\n\n \nB. # coding: utf-8\n\nimport sys\n\nimport bisect\n\n\n\n\n\n\"\"\"Template\"\"\"\n\n\n\n\n\nclass IP:\n\n    \"\"\"\n\n    \n\n    \"\"\"\n\n    def __init__(self):\n\n        self.input = sys.stdin.readline\n\n\n\n    def I(self):\n\n        \"\"\"\n\n        1\n\n        :return: \n\n        \"\"\"\n\n        return int(eval(input()))\n\n\n\n    def IL(self):\n\n        \"\"\"\n\n        1(int\n\n        :return: \n\n        \"\"\"\n\n        return list(map(int, self.input().split()))\n\n\n\n    def SL(self):\n\n        \"\"\"\n\n        1\n\n        :return: \n\n        \"\"\"\n\n        return list(map(str, self.input().split()))\n\n\n\n    def ILS(self, n):\n\n        \"\"\"\n\n        1(int\n\n        :param n: \n\n        :return: \n\n        \"\"\"\n\n        return [int(self.input()) for _ in range(n)]\n\n\n\n    def SLS(self, n):\n\n        \"\"\"\n\n        1\uff08str\n\n        :param n: \n\n        :return: \n\n        \"\"\"\n\n        return [self.input() for _ in range(n)]\n\n\n\n\n\nclass Idea:\n\n    def __init__(self):\n\n        pass\n\n\n\n    def HF(self, p):\n\n        \"\"\"\n\n        Half enumeration\n\n        \n\n        p\n\n        \n\n        :param p: list : \n\n        :return: list : \n\n        \"\"\"\n\n        return sorted(set(p[i] + p[j] for i in range(len(p)) for j in range(i, len(p))))\n\n\n\n    def Bfs2(self, a):\n\n        \"\"\"\n\n        bit_full_search2\n\n        bit\n\n        210\n\n        :return: list\uff12 : \uff11 2(16)  2 10\n\n        \"\"\"\n\n        # \n\n        # https://blog.rossywhite.com/2018/08/06/bit-search/\n\n        # https://atcoder.jp/contests/abc105/submissions/4088632\n\n        value = []\n\n        for i in range(1 << len(a)):\n\n            output = []\n\n\n\n            for j in range(len(a)):\n\n                if ((i >> j) & 1) == 1:\n\n                    \"\"\"j+1i1\"\"\"\n\n                    # output.append(a[j])\n\n                    output.append(a[j])\n\n            value.append([format(i, 'b').zfill(16), sum(output)])\n\n\n\n        value.sort(key=lambda x: x[1])\n\n        bin = [value[k][0] for k in range(len(value))]\n\n        val = [value[k][1] for k in range(len(value))]\n\n        return bin, val\n\n\n\n\n\n\"\"\"\"\"\"\n\n\n\n\n\ndef main():\n\n    # 1\n\n    r, e = range, enumerate\n\n    ip = IP()\n\n    id = Idea()\n\n\n\n    \"\"\"https://atcoder.jp/contests/abc105/submissions/4088632 \n\n    \"\"\"\n\n    n = ip.I()\n\n    # \n\n    list1 = [(-2) ** i for i in r(16)]\n\n    list2 = [(-2) ** (i + 16) for i in r(16)]\n\n    list1_bin, list1_val = id.Bfs2(list1)\n\n    list2_bin, list2_val = id.Bfs2(list2)\n\n\n\n    # 2\n\n    ans = 0\n\n    for i in r(len(list1_val)):\n\n        j = bisect.bisect_left(list2_val, n - list1_val[i])\n\n\n\n        if j < len(list2_val) and list1_val[i] + list2_val[j] == n:\n\n            ans = l", "output": "A", "improve_diff": 16.1001027661, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\n\n\ndef dfs(s):\n\n  if s!=\"\" and int(s)>n:\n\n    return 0\n\n  \n\n  if len(set(list(s)))<3:\n\n    ret=0\n\n  else:\n\n    ret=1\n\n  \n\n  for i in \"753\":\n\n    ret+=dfs(s+i)\n\n  \n\n  return ret\n\n\n\nprint((dfs(\"\"))) \nB. n=int(eval(input()))\n\nnum=[3,5,7]\n\n#a[0]=3,a[1]=5,a[7]=5\n\nans=[3,5,7]\n\nansw=[]\n\nfor i1 in range(3):\n\n  for i2 in range(3):\n\n    for i3 in range(3):\n\n      a=set([i1,i2,i3])\n\n      if len(a)>2:\n\n        answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])))\n\n      for i4 in range(3):\n\n        a=set([i1,i2,i3,i4])\n\n        if len(a)>2:\n\n          answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i4])))\n\n        for i5 in range(3):\n\n          a=set([i1,i2,i3,i4,i5])\n\n          if len(a)>2:\n\n            answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i5])+str(num[i4])))\n\n          for i6 in range(3):\n\n            a=set([i1,i2,i3,i4,i5,i6])\n\n            if len(a)>2:\n\n              answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i6])+str(num[i5])+str(num[i4])))\n\n            for i7 in range(3):\n\n              a=set([i1,i2,i3,i4,i5,i6,i7])\n\n              if len(a)>2:\n\n                answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i7])+str(num[i6])+str(num[i5])+str(num[i4])))\n\n              for i8 in range(3):\n\n                a=set([i1,i2,i3,i4,i5,i6,i7,i8])\n\n                if len(a)>2:\n\n                  answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i8])+str(num[i7])+str(num[i6])+str(num[i5])+str(num[i4])))\n\n                for i9 in range(3):\n\n                  a=set([i1,i2,i3,i4,i5,i6,i7,i8,i9])\n\n                  if len(a)>2:\n\n                    answ.append(int(str(num[i1])+str(num[i2])+str(num[i3])+str(num[i9])+str(num[i8])+str(num[i7])+str(num[i6])+str(num[i5])+str(num[i4])))\n\nansw.sort()\n\nleft=0\n\nright=len(answ)\n\nwhile right-left>1:\n\n  mid=(left+right)//2\n\n  \n\n  if n<answ[mid]:\n\n    right=mid\n\n  else:\n\n    left=mid\n\nif 357>n:\n\n  print((0))\n\nelse:\n\n  print((left+1))\n\n                    \n\n                ", "output": "A", "improve_diff": 3.0022046927, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    H = list(map(int, open(0).read().split()[1:]))\n\n    ans = 0\n\n    prev = int(1e9+7)\n\n    cnt = -1\n\n    for cur in H:\n\n        if prev >= cur:\n\n            cnt += 1\n\n        else:\n\n            if ans < cnt:\n\n                ans = cnt\n\n            cnt = 0\n\n        prev = cur\n\n    if ans < cnt:\n\n        ans = cnt\n\n    print(ans)\n\n    return\n\n\n\n\n\nmain()\n \nB. from sys import stdin\n\n\n\nreadline = stdin.readline\n\n\n\ndef main():\n\n    eval(input())\n\n    H = list(map(int, readline().split()))\n\n    ans = 0\n\n    prev = int(1e9+7)\n\n    cnt = -1\n\n    for cur in H:\n\n        if prev >= cur:\n\n            cnt += 1\n\n        else:\n\n            if ans < cnt:\n\n                ans = cnt\n\n            cnt = 0\n\n        prev = cur\n\n    if ans < cnt:\n\n        ans = cnt\n\n    print(ans)\n\n    return\n\n\n\n\n\nmain()\n", "output": "A", "improve_diff": 1.062903961, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nread = sys.stdin.buffer.read\n\ninput = sys.stdin.buffer.readline\n\ninputs = sys.stdin.buffer.readlines\n\n\n\n\n\n# rstrip().decode('utf-8')\n\n# INF=float(\"inf\")\n\n# MOD=10**9+7\n\n# sys.setrecursionlimit(2147483647)\n\n# import math\n\nimport numpy as np\n\n# import operator\n\n# import bisect\n\n# from heapq import heapify,heappop,heappush\n\n# from math import gcd\n\n# from fractions import gcd\n\n# from collections import deque\n\n# from collections import defaultdict\n\n# from collections import Counter\n\n# from itertools import accumulate\n\n# from itertools import groupby\n\n# from itertools import permutations\n\n# from itertools import combinations\n\n# from scipy.sparse import csr_matrix\n\n# from scipy.sparse.csgraph import floyd_warshall\n\n# from scipy.sparse.csgraph import csgraph_from_dense\n\n# from scipy.sparse.csgraph import dijkstra\n\n# map(int,input().split())\n\n\n\n\n\ndef main():\n\n\tN, K = list(map(int, input().split()))\n\n\tans=0\n\n\tfor i in range(1,N+1):\n\n\t\tx=max(0,np.ceil(np.log2(K/i)))\n\n\t\tans+=2**(-x)\n\n\tprint((ans/N))\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\nif __name__ == '__main__':\n\n\tmain()\n \nB. import sys\n\n\n\nread = sys.stdin.buffer.read\n\ninput = sys.stdin.buffer.readline\n\ninputs = sys.stdin.buffer.readlines\n\n\n\n\n\n# rstrip().decode('utf-8')\n\n# INF=float(\"inf\")\n\n# MOD=10**9+7\n\n# sys.setrecursionlimit(2147483647)\n\n# import math\n\n#import numpy as np\n\n# import operator\n\n# import bisect\n\n# from heapq import heapify,heappop,heappush\n\n# from math import gcd\n\n# from fractions import gcd\n\n# from collections import deque\n\n# from collections import defaultdict\n\n# from collections import Counter\n\n# from itertools import accumulate\n\n# from itertools import groupby\n\n# from itertools import permutations\n\n# from itertools import combinations\n\n# from scipy.sparse import csr_matrix\n\n# from scipy.sparse.csgraph import floyd_warshall\n\n# from scipy.sparse.csgraph import csgraph_from_dense\n\n# from scipy.sparse.csgraph import dijkstra\n\n# map(int,input().split())\n\n\n\n\n\ndef main():\n\n\tN, K = list(map(int, input().split()))\n\n\tans=0\n\n\tfor i in range(1,N+1):\n\n\t\ta=0\n\n\t\twhile i*(2**a)<K:\n\n\t\t\ta+=1\n\n\t\tans+=(1/2**a)/N\n\n\tprint(ans)\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\nif __name__ == '__main__':\n\n\tmain()\n", "output": "B", "improve_diff": 10.7953657135, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #ABC170 D\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn = int(readline())\n\na = list(map(int,readline().split()))\n\na.sort()\n\n\n\nif a[0] == a[-1]: # n=1 \uff12\n\n  if n > 1:\n\n    print((0))\n\n  else:\n\n    print((1))\n\n  exit()\n\n\n\nif a[0] == 1: #\uff11\n\n  if a[0] == a[1]:\n\n    print((0))\n\n  else:\n\n    print((1))\n\n  exit()\n\n  \n\ndef divisorize(fct): # \n\n    b, e = fct.pop()\n\n    pre_div = divisorize(fct) if fct else [[]]\n\n    suf_div = [[(b, k)] for k in range(e + 1)]\n\n    return [pre + suf for pre in pre_div for suf in suf_div]\n\n\n\ndef factorize(n): #\n\n    fct = []\n\n    b, e = 2, 0\n\n    while b * b <= n:\n\n        while n % b == 0:\n\n            n = n // b\n\n            e = e + 1\n\n        if e > 0:\n\n            fct.append((b, e))\n\n        b, e = b + 1, 0\n\n    if n > 1:\n\n        fct.append((n, 1))\n\n    return fct\n\n \n\n \n\ndef num(fct):\n\n    a = 1\n\n    for base, exponent in fct:\n\n        a = a * base**exponent\n\n    return a\n\n    \n\ns = set()\n\nans = 0\n\nfor nm,i in enumerate(a):\n\n  c = set()\n\n  fct = factorize(i)\n\n  for div in divisorize(fct): # \n\n      c.add(num(div))\n\n\n\n# \n\n  if c&s == set() and ((nm < n-1 and a[nm+1] != i) or nm == n-1): \n\n    ans += 1\n\n  s.add(i) #\n\n\n\nprint(ans) \nB. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn = int(readline())\n\na = list(map(int,readline().split()))\n\na.sort()\n\n\n\nif a[0] == a[-1]:\n\n  if n > 1:\n\n    print((0))\n\n  else:\n\n    print((1))\n\n  exit()\n\n\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d // (d & -d)\n\n    L = [2, 7, 61] if n < 1<<32 else [2, 3, 5, 7, 11, 13, 17] if n < 1<<48 else [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = y * y % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() // 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n // g): return n // g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i * i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n //= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += i % 2 + (3 if i % 3 == 1 else 1)\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n //= j\n\n                        k += 1\n\n                    ret[j] = k\n\n \n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\n\n\ndef divisors(N):\n\n    pf = primeFactor(N)\n\n    ret = [1]\n\n    for p in pf:\n\n        ret_prev = ret\n\n        ret = []\n\n        for i in range(pf[p]+1):\n\n            for r in ret_prev:\n\n                ret.append(r * (p ** i))\n\n    return ret\n\n    \n\ns = set()\n\nans = 0\n\nfor nm,i in enumerate(a):\n\n  c = set(divisors(i))\n\n  if c&s == set() and ((nm < n-1 and a[nm+1] != i) or nm == n-1): \n\n    ans += 1\n\n  s.add(i)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0264689926, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k = list(map(int, input().split()))\n\ns = input()\n\ncd = 0\n\nd = None\n\nfor l in s:\n\n\tif d != l:\n\n\t\tcd +=1\n\n\t\td = l\n\nscore = 0\n\nfor u,v in zip(s,s[1:]):\n\n\tif u == v:\n\n\t\tscore +=1\n\n\n\nif cd > 2:\n\n\tt = min(k,((cd - 2)+1)/2)\n\n\tk -= t\n\n\tscore += 2 * t \n\n\tcd -= 2 * t\n\nif cd == 2 and k:\n\n\tscore +=1\n\n\tcd -= 1\n\nprint(score) \nB. n,k = list(map(int, input().split()))\n\nscore,d,cd = 0,None,0\n\ns = input()\n\nfor i,l in enumerate(s):\n\n\tif d != l:\n\n\t\tcd +=1\n\n\t\td = l\n\n\tif i and s[i-1] == s[i]:  score += 1\n\n\n\n\n\nif cd > 2:\n\n\tt = min(k,((cd - 2)+1)/2)\n\n\tk -= t\n\n\tscore += 2 * t \n\n\tcd -= 2 * t\n\nif cd == 2 and k:\n\n\tscore +=1\n\n\tcd -= 1\n\nprint(score)\n", "output": "A", "improve_diff": 1.0199905166, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nimport itertools\n\nQ = int(eval(input()))\n\nLR = [[int(x) for x in input().split()] for _ in range(Q)]\n\n\n\n\n\n## \n\nMAX = 10**5\n\nis_prime = np.full(MAX, True)\n\nis_prime[0] = is_prime[1] = False\n\nfor i in range(2, int(MAX**.5)+1):\n\n    if is_prime[i]:\n\n        is_prime[i*i::i] = False\n\n        \n\nNUM = np.zeros(MAX)\n\nfor p in range(MAX):\n\n    if is_prime[p] and is_prime[(p+1)//2]:\n\n        NUM[p] += 1\n\n\n\nNUMcum = [0] + list(itertools.accumulate(NUM))\n\n\n\nfor l, r in LR:\n\n    print((int(NUMcum[r+1] - NUMcum[l]))) \nB. import itertools\n\nQ = int(eval(input()))\n\nLR = [[int(x) for x in input().split()] for _ in range(Q)]\n\n\n\nMAX = 10**5\n\nis_prime = [True] * MAX\n\nis_prime[0] = is_prime[1] = False\n\nfor i in range(2, int(MAX**.5)+1):\n\n    if is_prime[i]:\n\n        for j in range(i*i, MAX, i):\n\n            is_prime[j] = False\n\n\n\nNUM = [0] * MAX\n\nfor p in range(MAX):\n\n    if is_prime[p] and is_prime[(p+1)//2]:\n\n        NUM[p] += 1\n\nNUMcum = [0] + list(itertools.accumulate(NUM))\n\nfor l, r in LR:\n\n    print((int(NUMcum[r+1] - NUMcum[l])))", "output": "B", "improve_diff": 4.0451396913, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. dp=[[1<<30 for _ in range(1001)] for _ in range(1001)]\n\ndp[0][0]=0\n\nn,m=list(map(int,input().split()))\n\nd=[int(eval(input())) for _ in range(n)]+[0]\n\nc=[int(eval(input())) for _ in range(m)]+[0]\n\nfor i in range(m):\n\n    for j in range(n+1):\n\n        if dp[i][j]< dp[i+1][j]:dp[i+1][j]=dp[i][j]\n\n        e=d[j]*c[i]\n\n        if dp[i][j]+e<dp[i+1][j+1]:dp[i+1][j+1]=dp[i][j]+e;\n\ndp=list(zip(*dp[::-1]))\n\nprint((min(dp[n]))) \nB. dp=[[1<<30 for _ in range(1001)] for _ in range(1001)]\n\ndp[0][0]=0\n\nn,m=list(map(int,input().split()))\n\nd=[int(eval(input())) for _ in range(n)]+[0]\n\nc=[int(eval(input())) for _ in range(m)]+[0]\n\nfor i in range(m):\n\n    for j in range(n+1):\n\n        if dp[i][j]< dp[i+1][j]:dp[i+1][j]=dp[i][j]\n\n        e=d[j]*c[i]\n\n        if dp[i][j]+e<dp[i+1][j+1]:dp[i+1][j+1]=dp[i][j]+e;\n\nprint((dp[m][n]))", "output": "B", "improve_diff": 1.4829428256, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\nN = int(eval(input()))\n\nA = [int(eval(input())) for _ in range(N)]\n\n\n\nc = Counter(A)\n\nans = 0\n\nfor k, v in list(c.items()):\n\n    ans += v % 2\n\nprint(ans) \nB. import sys\n\nfrom collections import Counter\n\n\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nA = [int(eval(input())) for _ in range(N)]\n\n\n\nans = len([v for v in list(Counter(A).values()) if v % 2 == 1])\n\nprint(ans)", "output": "B", "improve_diff": 1.0451642647, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom operator import mul\n\nfrom functools import reduce\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef com(n,r):\n\n    r = min(n-r,r)\n\n    if r == 0: return 1 \n\n    return reduce(mul,list(range(n,n-r,-1)))//reduce(mul,list(range(1,r+1)))\n\n\n\nn = int(readline())\n\n\n\nif n < 3:\n\n    print((0))\n\n    sys.exit()\n\n\n\nans = 0\n\nfor i in range(1,n//3+1):\n\n    num = n - i * 3\n\n    ans += com(num+i-1,i-1)\n\n    \n\nprint((ans%1000000007)) \nB. import sys\n\nfrom operator import mul\n\nfrom functools import reduce\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef com(n,r):\n\n    r = min(n-r,r)\n\n    if r == 0: return 1\n\n    over = reduce(mul, list(range(n, n - r, -1)))\n\n    under = reduce(mul, list(range(1,r + 1)))\n\n    return over // under\n\n\n\nn = int(readline())\n\nif n < 3:\n\n    print((0))\n\n    sys.exit()\n\n\n\nans = 0\n\nfor i in range(1,n//3+1):\n\n    num = n - i * 3\n\n    ans += com(num+i-1,i-1) % 1000000007\n\n    ans %= 1000000007\n\n\n\nprint(ans)\n\n    \n", "output": "A", "improve_diff": 1.0610861475, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A, B = list(map(int, input().split()))\n\n\n\nif A < 10 and B < 10:\n\n  print((A * B))\n\nelse:\n\n  print((-1)) \nB. A, B = list(map(int, input().split()))\n\n\n\nif 1 <= A <= 9 and 1 <= B <= 9:\n\n  print((A * B))\n\nelse:\n\n  print((-1))", "output": "A", "improve_diff": 1.0856287409, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport bisect\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\n\n\nin_n = lambda: int(readline())\n\nin_nn = lambda: list(map(int, readline().split()))\n\nin_s = lambda: readline().rstrip().decode('utf-8')\n\n\n\nINF = 10**12\n\nd = lambda a, b: abs(a - b)\n\n\n\n\n\ndef main():\n\n\n\n    A, B, Q = in_nn()\n\n    tmp = list(map(int, read().split()))\n\n    s = tmp[:A]\n\n    t = tmp[A:A + B]\n\n    x = tmp[A + B:]\n\n\n\n    a = [0] * Q\n\n\n\n    for i in range(Q):\n\n\n\n        n = x[i]\n\n\n\n        if n <= s[0]:\n\n            a1 = -INF\n\n            a2 = s[0]\n\n        elif n >= s[-1]:\n\n            a1 = s[-1]\n\n            a2 = INF\n\n        else:\n\n            si = bisect.bisect_right(s, n)\n\n            a1 = s[si - 1]\n\n            a2 = s[si]\n\n\n\n        if n <= t[0]:\n\n            b1 = -INF\n\n            b2 = t[0]\n\n        elif n >= t[-1]:\n\n            b1 = t[-1]\n\n            b2 = INF\n\n        else:\n\n            ti = bisect.bisect_right(t, n)\n\n            b1 = t[ti - 1]\n\n            b2 = t[ti]\n\n\n\n        # print(a1, a2, b1, b2)\n\n        ans = d(n, a1) + min(d(a1, b1), d(a1, b2))\n\n        ans = min(ans, d(n, a2) + min(d(a2, b1), d(a2, b2)))\n\n        ans = min(ans, d(n, b1) + min(d(b1, a1), d(b1, a2)))\n\n        ans = min(ans, d(n, b2) + min(d(b2, a1), d(b2, a2)))\n\n        a[i] = ans\n\n\n\n    print(('\\n'.join(map(str, a))))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nimport bisect\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\n\n\nin_n = lambda: int(readline())\n\nin_nn = lambda: list(map(int, readline().split()))\n\nin_s = lambda: readline().rstrip().decode('utf-8')\n\n\n\nINF = 10**12\n\n\n\n\n\ndef main():\n\n\n\n    A, B, Q = in_nn()\n\n    tmp = list(map(int, read().split()))\n\n    s = [-INF] + tmp[:A] + [INF]\n\n    t = [-INF] + tmp[A:A + B] + [INF]\n\n    x = tmp[A + B:]\n\n\n\n    a = [0] * Q\n\n    d = lambda a, b: abs(a - b)\n\n\n\n    for i in range(Q):\n\n\n\n        n = x[i]\n\n\n\n        si = bisect.bisect_right(s, n)\n\n        a1 = s[si - 1]\n\n        a2 = s[si]\n\n\n\n        ti = bisect.bisect_right(t, n)\n\n        b1 = t[ti - 1]\n\n        b2 = t[ti]\n\n\n\n        ans = d(n, a1) + min(d(a1, b1), d(a1, b2))\n\n        ans = min(ans, d(n, a2) + min(d(a2, b1), d(a2, b2)))\n\n        ans = min(ans, d(n, b1) + min(d(b1, a1), d(b1, a2)))\n\n        ans = min(ans, d(n, b2) + min(d(b2, a1), d(b2, a2)))\n\n        a[i] = ans\n\n\n\n    print(('\\n'.join(map(str, a))))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.0350064386, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def dist(a, b):\n\n    return min(\n\n        abs(a - b),\n\n        abs(a - x) + 1 + abs(y - b),\n\n        abs(a - y) + 1 + abs(x - b)\n\n    )\n\n\n\n\n\nn, x, y = map(int, input().split())\n\nx -= 1\n\ny -= 1\n\n\n\nd = [0] * n\n\n\n\nfor j in range(n):\n\n    for i in range(j):\n\n        d[dist(i, j)] += 1\n\n\n\nit = iter(d)\n\nnext(it)\n\n\n\nprint(*it, sep='\\n')\n \nB. def main():\n\n    N, X, Y = map(int, input().split())\n\n    X -= 1\n\n    Y -= 1\n\n\n\n    ans = [0] * N\n\n    for j in range(N):\n\n        for i in range(j):\n\n            d = min(\n\n                j - i,\n\n                abs(j - X) + 1 + abs(Y - i),\n\n                abs(j - Y) + 1 + abs(X - i)\n\n            )\n\n            ans[d] += 1\n\n\n\n    print(*ans[1:], sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0208180665, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nXY = [tuple(map(int,input().split())) for i in range(M)]\n\n\n\nclass UnionFind:\n\n    def __init__(self,N):\n\n        self.parent = [i for i in range(N)]\n\n        self.rank = [0] * N\n\n        self.count = 0\n\n    def root(self,a):\n\n        if self.parent[a] == a:\n\n            return a\n\n        else:\n\n            self.parent[a] = self.root(self.parent[a])\n\n            return self.parent[a]\n\n    def is_same(self,a,b):\n\n        return self.root(a) == self.root(b)\n\n    def unite(self,a,b):\n\n        ra = self.root(a)\n\n        rb = self.root(b)\n\n        if ra == rb: return\n\n        if self.rank[ra] < self.rank[rb]:\n\n            self.parent[ra] = rb\n\n        else:\n\n            self.parent[rb] = ra\n\n            if self.rank[ra] == self.rank[rb]: self.rank[ra] += 1\n\n        self.count += 1\n\n\n\nuf = UnionFind(N)\n\nfor x,y in XY:\n\n    if uf.is_same(x,y): continue\n\n    uf.unite(x,y)\n\nfor i in range(N):\n\n    uf.root(i)\n\n\n\nc = N - uf.count\n\nif c==1:\n\n    print((0))\n\n    exit()\n\nex = c-2\n\nif c+ex > N:\n\n    print('Impossible')\n\n    exit()\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(lambda: [])\n\nfor i,a in enumerate(A):\n\n    r = uf.root(i)\n\n    d[r].append(a)\n\n\n\nans = 0\n\nhq = []\n\nfor k in list(d.keys()):\n\n    s = sorted(d[k])\n\n    ans += s[0]\n\n    for v in s[1:]:\n\n        hq.append(v)\n\n\n\nimport heapq\n\nheapq.heapify(hq)\n\nfor _ in range(ex):\n\n    v = heapq.heappop(hq)\n\n    ans += v\n\nprint(ans) \nB. N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nXY = [tuple(map(int,input().split())) for i in range(M)]\n\n\n\nif M==N-1:\n\n    print((0))\n\n    exit()\n\n\n\nclass UnionFind:\n\n    def __init__(self,N):\n\n        self.parent = [i for i in range(N)]\n\n        self._size = [1] * N\n\n        self.count = 0\n\n    def root(self,a):\n\n        if self.parent[a] == a:\n\n            return a\n\n        else:\n\n            self.parent[a] = self.root(self.parent[a])\n\n            return self.parent[a]\n\n    def is_same(self,a,b):\n\n        return self.root(a) == self.root(b)\n\n    def unite(self,a,b):\n\n        ra = self.root(a)\n\n        rb = self.root(b)\n\n        if ra == rb: return\n\n        if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n\n        self._size[ra] += self._size[rb]\n\n        self.parent[rb] = ra\n\n        self.count += 1\n\n    def size(self,a):\n\n        return self._size[self.root(a)]\n\n\n\nuf = UnionFind(N)\n\nfor x,y in XY:\n\n    if uf.is_same(x,y): continue\n\n    uf.unite(x,y)\n\nfor i in range(N):\n\n    uf.root(i)\n\n\n\nfrom collections import defaultdict\n\ndic = defaultdict(lambda: set())\n\nfor i in range(N):\n\n    dic[uf.root(i)].add(i)\n\n\n\nneed = (len(dic)-1)*2\n\nif need > N:\n\n    print('Impossible')\n\n    exit()\n\n\n\nans = used = 0\n\nimport heapq\n\nhq = []\n\nheapq.heapify(hq)\n\nfor r,vs in list(dic.items()):\n\n    mini = -1\n\n    mina = 10**9+1\n\n    for i in vs:\n\n        if A[i] < mina:\n\n            mina = A[i]\n\n            mini = i\n\n    ans += mina\n\n    used += 1\n\n    for i in vs:\n\n        if i==mini: continue\n\n        heapq.heappush(hq, A[i])\n\n\n\nfor _ in range(need - used):\n\n    ans += heapq.heappop(hq)\n\nprint(ans)", "output": "A", "improve_diff": 1.1150742623, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\nif __name__ == \"__main__\":\n\n    a,b = input().split()\n\n    print((int(a) * round(float(b)*100)//100))\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\nif __name__ == \"__main__\":\n\n    a,b = input().split()\n\n    ai = int(a)\n\n    bf = round(float(b)*100)\n\n    print((ai*bf//100))\n", "output": "B", "improve_diff": 1.0338595967, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def prepare(n):\n\n    global MOD\n\n    modFacts = [0] * (n + 1)\n\n    modFacts[0] = 1\n\n    for i in range(n):\n\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n\n\n    invs = [1] * (n + 1)\n\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n\n    for i in range(n, 1, -1):\n\n        invs[i - 1] = (invs[i] * i) % MOD\n\n\n\n    return modFacts, invs\n\n        \n\n\n\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, input().split()))\n\nmodFacts, invs = prepare(max(N, M))\n\n\n\nans = 0\n\nfor i in range(N + 1):\n\n    cnt = (modFacts[N] * invs[i] * invs[N - i]) % MOD\n\n    cnt *= (modFacts[M] * invs[M - i]) % MOD\n\n    cnt %= MOD\n\n    cnt *= pow(modFacts[M - i] * invs[(M - i) - (N - i)], 2, MOD)\n\n    cnt %= MOD\n\n    ans += pow(-1, i) * cnt\n\n    ans %= MOD\n\n\n\nprint(ans)\n \nB. MOD = 10 ** 9 + 7\n\n\n\n\n\ndef prepare(n):\n\n    global MOD\n\n    modFacts = [0] * (n + 1)\n\n    modFacts[0] = 1\n\n    for i in range(n):\n\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n\n\n    invs = [1] * (n + 1)\n\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n\n    for i in range(n, 1, -1):\n\n        invs[i - 1] = (invs[i] * i) % MOD\n\n\n\n    return modFacts, invs\n\n\n\n\n\ndef comb(n, r):\n\n    global MOD, modFacts, invs\n\n    return (modFacts[n] * invs[n - r] * invs[r]) % MOD\n\n\n\n\n\ndef perm(n, r):\n\n    global MOD, modFacts, invs\n\n    return (modFacts[n] * invs[n - r]) % MOD\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nmodFacts, invs = prepare(M)\n\nans = 0\n\nflag = 1\n\nfor i in range(N + 1):\n\n    a = comb(N, i)\n\n    b = perm(M, i)\n\n    c = pow(perm(M - i, N - i), 2, MOD)\n\n    cnt = (a * b * c) % MOD\n\n    ans = (ans + flag * cnt) % MOD\n\n    flag *= -1\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0682729153, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m,q = list(map(int,input().split()))\n\nabcd = [[*list(map(int,input().split()))] for _ in range(q)]\n\nfrom itertools import *\n\nans = 0\n\nfor A in combinations_with_replacement(list(range(1, m+1)), n): # nHr\n\n    now = sum(d if A[b-1] - A[a-1] == c else 0 for a,b,c,d in abcd)\n\n    ans = max(ans, now)\n\nprint(ans)\n \nB. n,m,q = list(map(int,input().split()))\n\nabcd = [[*list(map(int,input().split()))] for _ in range(q)]\n\n\n\ndef dfs(A=[1]): # A:1 origin\n\n    if n+1 <= len(A):\n\n        return sum(d if A[b]-A[a]==c else 0 for a,b,c,d in abcd)\n\n    A.append(A[-1])\n\n    ret = 0\n\n    while A[-1] <= m:\n\n        ret = max(ret, dfs(A))\n\n        A[-1] += 1\n\n    A.pop()\n\n    return ret\n\n\n\nans = dfs()\n\nprint(ans)\n", "output": "A", "improve_diff": 1.2722219133, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\n\n\nn=int(eval(input()))\n\narr=list(map(int,input().split()))\n\narr=sorted(arr,reverse=True)\n\nans=0\n\nq=[]\n\nheapq.heappush(q,-arr[0])\n\nfor i in range(1,n):\n\n  tmp=heapq.heappop(q)\n\n  tmp*=-1\n\n  ans+=tmp\n\n  heapq.heappush(q,-arr[i])\n\n  heapq.heappush(q,-arr[i])\n\nprint(ans) \nB. n=int(eval(input()))\n\narr=list(map(int,input().split()))\n\narr=sorted(arr,reverse=True)\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=arr[i//2]\n\nprint(ans)", "output": "B", "improve_diff": 1.3436511709, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nimport os\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = int(sys.stdin.readline().rstrip())\n\n\n\n    ret = float('inf')\n\n    for i in range(1, 10000000):\n\n        q, mod = divmod(N, i)\n\n        if mod == 0:\n\n            j = N // i\n\n            ret = min(ret, ((j-1)+(i-1)))\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. import sys\n\nimport os\n\nimport math\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = int(sys.stdin.readline().rstrip())\n\n\n\n    max = int(math.sqrt(N) + 1)\n\n    ret = float('inf')\n\n    for i in range(1, max):\n\n        q, mod = divmod(N, i)\n\n        if mod == 0:\n\n            j = N // i\n\n            ret = min(ret, ((j-1)+(i-1)))\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 40.4580509904, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=[[int(i) for i in input().split()] for i in range(n)]\n\n\n\nimport itertools\n\nimport math\n\npe=itertools.permutations(list(range(n)))\n\npe=list(pe)\n\nans=0\n\n\n\nfor i in pe:\n\n    tmp=0\n\n    for j in range(n-1):\n\n        tmp+=((a[i[j]][0]-a[i[j+1]][0])**2+(a[i[j]][1]-a[i[j+1]][1])**2)**0.5\n\n    ans+=tmp\n\nprint((ans/math.factorial(n))) \nB. n=int(eval(input()))\n\na=[[int(i)for i in input().split()]for i in range(n)]\n\nimport itertools as it\n\nli=list(it.permutations(list(range(n))))\n\ntotal=0\n\nfor i in li:\n\n    tmp=0\n\n    for j in range(n-1):\n\n        x1,x2=a[i[j]][0],a[i[j+1]][0]\n\n        y1,y2=a[i[j]][1],a[i[j+1]][1]\n\n        tmp=(x1-x2)**2+(y1-y2)**2\n\n        total+=tmp**0.5\n\nprint((total/len(li)))", "output": "B", "improve_diff": 1.2822597627, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nsys.setrecursionlimit(4100000)\n\nimport math\n\nimport itertools\n\nINF = float('inf')\n\nfrom heapq import heapify, heappop, heappush\n\n\n\ndef main():\n\n    a,b,c,d = list(map(int, input().split()))\n\n\n\n    print((max(0, min(b,d)-max(a,c))))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nsys.setrecursionlimit(4100000)\n\nimport math\n\nimport itertools\n\nINF = float('inf')\n\nfrom heapq import heapify, heappop, heappush\n\n\n\ndef main():\n\n    a,b,c,d = list(map(int, input().split()))\n\n\n\n    tmp = set(list(range(a,b+1))) & set(list(range(c, d+1)))\n\n    print((max(0, len(tmp)-1)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0685009666, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nr=set()\n\ndef f(s,k):\n\n    if k>=0:\n\n        global r\n\n        r.add(s)\n\n        f(s+A[k-1],k-1)\n\n        f(s,k-1)\n\nf(0,n)\n\neval(input())\n\nfor e in map(int,input().split()):print((['no','yes'][e in r]))\n \nB. n=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nr=[]\n\ndef f(s,k):\n\n    if k>=0:\n\n        global r\n\n        r+=[s]\n\n        f(s+A[k-1],k-1)\n\n        f(s,k-1)\n\nf(0,n)\n\neval(input())\n\nfor e in map(int,input().split()):print((['no','yes'][e in r]))\n", "output": "A", "improve_diff": 1.0614239714, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nprint(((N+1)>>1)) \nB. print(((int(eval(input()))+1)//2))", "output": "B", "improve_diff": 1.0483900298, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\ns = []\n\nfor _ in range(n):\n\n    s.append(int(eval(input())))\n\n\n\ntotal = sum(s)\n\n\n\nif total % 10 != 0:\n\n    print(total)\n\n\n\nelse:\n\n    s.sort()    \n\n    min_s = total\n\n    \n\n    for si in s:\n\n        if si % 10 != 0:\n\n            min_s = si\n\n            break\n\n        \n\n    print((total - min_s)) \nB. from collections import Counter\n\n\n\nn = int(eval(input()))\n\ns = []\n\nfor _ in range(n):\n\n    s.append(int(eval(input())))\n\n    \n\ncnt = Counter([0, s[0]])\n\n\n\nif len(s) > 1:\n\n    for si in s[1:]:\n\n        tmp = Counter([])\n\n        for k,v in list(cnt.items()):\n\n            tmp[k + si] = v\n\n            \n\n        cnt += tmp\n\n\n\nkey_list = sorted(list(cnt.keys()), reverse=True)\n\n\n\nfor k in key_list:\n\n    if k == 0:\n\n        print(k)\n\n        break\n\n    \n\n    elif k%10 == 0:\n\n        continue\n\n    \n\n    print(k)\n\n    break", "output": "A", "improve_diff": 1.4613710375, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nx = 0\n\nh = a[0]\n\nfor i in range(n):\n\n    if a[i] > h:\n\n        h = a[i]\n\n    else:\n\n        x += (h - a[i])\n\nprint(x) \nB. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nx = 0\n\nM = a[0]\n\nif n != 1:\n\n    for i in range(n - 1):\n\n        if M > a[i + 1]:\n\n            x += (M - a[i + 1])\n\n        else:\n\n            M = a[i + 1]\n\nprint(x)", "output": "B", "improve_diff": 1.0275063494, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X,Y,Z=list(map(int,input().split()))\n\nA=X-Z\n\nans=A//(Y+Z)\n\nprint(ans)\n \nB. X,Y,Z=list(map(int,input().split()))\n\nans=0\n\nK=Z\n\nwhile(True):\n\n    if K+Y+Z>X:\n\n        break\n\n    K+=Y+Z\n\n    ans+=1\n\nprint(ans)", "output": "A", "improve_diff": 1.0976102949, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #DFS\n\nfrom collections import deque\n\n\n\nN, M = list(map(int, input().split()))\n\nG = [[] for _ in range(N)]\n\nfor i in range(M):\n\n  a, b = list(map(int, input().split()))\n\n  G[a-1].append(b-1)\n\n  G[b-1].append(a-1)\n\n  \n\nstack = deque([(0, 0)])\n\nvisited = [0] * N\n\ndepth = 0\n\nans = 0\n\nwhile stack:\n\n  now, depth = stack.pop()\n\n  if depth == N-1:\n\n    ans += 1\n\n    continue\n\n  visited[depth] = now\n\n  for nxt in G[now]:\n\n    if nxt not in visited[:depth+1]:\n\n      stack.append((nxt, depth+1))\n\n    \n\nprint(ans) \nB. #\n\n\n\nfrom itertools import permutations\n\n\n\nN, M = list(map(int, input().split()))\n\nG = [[0]*N for _ in range(N)]\n\nfor i in range(M):\n\n  a, b = list(map(int, input().split()))\n\n  G[a-1][b-1] = 1\n\n  G[b-1][a-1] = 1\n\n\n\nperms = permutations(list(range(1, N)))\n\nans = 0\n\n\n\nfor perm in perms:\n\n  now = 0\n\n  for v in perm:\n\n    if G[now][v] == 0:\n\n      break\n\n    now = v\n\n  else:\n\n    ans += 1\n\n    \n\nprint(ans)", "output": "B", "improve_diff": 1.3934084404, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(input())\n\na=[]\n\nfor i,j in enumerate(map(int,input().split())):\n\n    a.append([j,i])\n\na.sort(reverse=True)\n\nnow=0\n\nnx=0\n\nans=[0]*n\n\ncnt=0\n\nidx=10**6\n\nwhile now<n:\n\n    while nx<n and a[now][0]==a[nx][0]:\n\n        idx=min(idx,a[nx][1])\n\n        cnt+=1\n\n        nx+=1\n\n    if nx==n:\n\n        ans[idx]+=cnt*a[now][0]\n\n    else:\n\n        ans[idx]+=(a[now][0]-a[nx][0])*cnt\n\n    now=nx\n\nfor i in range(n):\n\n    print(ans[i]) \nB. from collections import defaultdict\n\nclass BIT():\n\n    def __init__(self,size):\n\n        self.size=size\n\n        self.node=[0]*(size+1)\n\n\n\n    def sum(self,idx):\n\n        ret=0\n\n        while idx>0:\n\n            ret+=self.node[idx]\n\n            idx-=idx&(-idx)\n\n        return ret\n\n\n\n    def add(self,idx,x):\n\n        while idx<=self.size:\n\n            self.node[idx]+=x\n\n            idx+=idx&(-idx)\n\n\n\nn=int(input())\n\na=list(map(int,input().split()))\n\ncheck=[]\n\nd=defaultdict(int)\n\nli=set([])\n\nnow=0\n\nfor i in range(n):\n\n    if now<a[i]:\n\n        now=a[i]\n\n        check.append(i)\n\n    d[a[i]]+=1\n\n    li.add(a[i])\n\nli=sorted(list(li))\n\nb=[0]*(n+5)\n\ni=0\n\nidx=dict()\n\nfor key in li:\n\n    b[i]=d[key]\n\n    idx[key]=i\n\n    i+=1\n\nans=[0]*(n+1)\n\nfor i in range(len(check)-2,-1,-1):\n\n    cnt=0\n\n    for j in range(idx[a[check[i]]]+1,idx[a[check[i+1]]]+1):\n\n        ans[check[i+1]]+=b[j]*(li[j]-a[check[i]])\n\n        cnt+=b[j]\n\n    b[idx[a[check[i]]]]+=cnt\n\nfor i in range(1,n):\n\n    if a[0]<a[i]:\n\n        a[i]=a[0]\n\nans[0]=sum(a)\n\nfor i in range(n):\n\n    print(ans[i])\n", "output": "A", "improve_diff": 1.3908786301, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def c_takahashi_information(C):\n\n    a = [min(C[0]), min(C[1]), min(C[2])]\n\n    tmp = [[C[i][j] - a[i] for j in range(3)] for i in range(3)]\n\n    b = list(map(list, set(map(tuple, tmp))))\n\n    for bb in b:\n\n        f = True\n\n        for i in range(3):\n\n            for j in range(3):\n\n                if a[i] + bb[j] != C[i][j]:\n\n                    f = False\n\n                    break\n\n            if not f:\n\n                break\n\n        if f:\n\n\n\n            return 'Yes'\n\n    return 'No'\n\n  \n\nC = [[int(i) for i in input().split()] for j in range(3)]\n\nprint((c_takahashi_information(C))) \nB. def c_takahashi_information(C):\n\n    b = [C[0][i] - 0 for i in range(3)]\n\n    a = [0] + [C[i][0] - b[0] for i in range(1, 3)]  # a_1=0\n\n    for i in range(3):\n\n        for j in range(3):\n\n            if a[i] + b[j] != C[i][j]:\n\n                return 'No'\n\n    return 'Yes'\n\n\n\nC = [[int(i) for i in input().split()] for j in range(3)]\n\nprint((c_takahashi_information(C)))", "output": "B", "improve_diff": 1.0175560235, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. t, x = list(map(int, input().split()))\n\nprint((t / x)) \nB. from decimal import Decimal\n\nt, x = input().split()\n\nprint((Decimal(t)/Decimal(x)))", "output": "A", "improve_diff": 1.6205231607, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b = list(map(int, input().split()))\n\nfor i in range(1,1009):\n\n    if int(i*0.08) == a and int(i*0.1) == b:\n\n        print((int(i)))\n\n        exit()\n\nprint(\"-1\") \nB. a, b = list(map(int, input().split()))\n\nb = b/0.1\n\nb_list = [i+b for i in range(10)]\n\nfor i in b_list:\n\n    if int(i*0.08) == a:\n\n        print((int(i)))\n\n        exit()\n\nprint(\"-1\")", "output": "A", "improve_diff": 1.0805818393, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N = int(eval(input()))\n\n    A = list(int(eval(input())) for _ in range(N))\n\n    cnt = 0\n\n    for i in range(N):\n\n        if i == N-1:\n\n            cnt += A[i] // 2\n\n            break\n\n        cnt += A[i] // 2\n\n        mod = A[i] % 2\n\n        if A[i+1] >= mod:\n\n            cnt += mod\n\n            A[i+1] -= mod\n\n\n\n    print(cnt)\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. from collections import defaultdict\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    A = [int(eval(input())) for _ in range(N)] + [0]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        ans += A[i] // 2\n\n        if A[i] % 2 == 1:\n\n            if A[i+1] >= 1:\n\n                ans += 1\n\n                A[i+1] -= 1\n\n\n\n    print(ans)\n\n\n\n\n\n\n\n    \n\n    \n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "A", "improve_diff": 1.4192258453, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,*s=list(map(str,open(0).read().split()))\n\nif \"Y\" in s:\n\n  print(\"Four\")\n\nelse:\n\n  print(\"Three\") \nB. n=eval(input())\n\narare=list(map(str,input().split()))\n\nif \"Y\" in arare:\n\n  print(\"Four\")\n\nelse:\n\n  print(\"Three\")", "output": "B", "improve_diff": 1.0191301447, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\nv=sum(a)\n\nif k<a[0]:\n\n    a[0]=k\n\nfor i in range(n-1):\n\n    if k<a[i]+a[i+1]:\n\n        a[i+1]=k-a[i]\n\nprint((v-sum(a))) \nB. N, X = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nans = 0\n\n \n\nif A[0] > X:\n\n    ans += A[0] - X\n\n    A[0] = X\n\n    \n\nfor i in range(N-1):\n\n    if A[i] + A[i+1] > X:\n\n        ans -= X - (A[i] + A[i + 1])\n\n        A[i+1] += X - (A[i] + A[i+1])\n\n \n\nprint(ans)", "output": "B", "improve_diff": 1.0111025776, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()));\n\nans=0;\n\np=[0]*22222;\n\nfor w,s,v in sorted([list(map(int,input().split()))for _ in[0]*n],key=lambda a:a[0]+a[1]):\n\n for j in range(s,-1,-1):\n\n  p[j+w]=max(p[j+w],p[j]+v);\n\n  ans=max(ans,p[j+w]);\n\nprint(ans)\n \nB. p=[0]*6**6\n\nfor w,s,v in sorted([list(map(int,input().split()))for _ in[0]*int(eval(input()))],key=lambda a:a[0]+a[1]):\n\n for j in range(s,-1,-1):p[j+w]=max(p[j+w],p[j]+v)\n\nprint((max(p)))", "output": "B", "improve_diff": 1.0827546018, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [[] for _ in range(N)]\n\nfor i in range(N-1):\n\n    a,b = list(map(int,input().split()))\n\n    A[a-1].append(b-1)\n\n    A[b-1].append(a-1)\n\n\n\nB = [False]*N\n\nvisited = [True]*N\n\n\n\nFp,Sp = 0,0\n\nFi,Si = [0],[N-1]\n\n\n\nwhile B != visited:\n\n    # Fennec\n\n    nextXi = []\n\n    for i in Fi:\n\n        if not B[i]:\n\n            B[i] = True\n\n            Fp += 1\n\n            nextXi.extend(A[i])\n\n    Fi = nextXi\n\n    # Snuke\n\n    nextXi = []\n\n    for i in Si:\n\n        if not B[i]:\n\n            B[i] = True\n\n            Sp += 1\n\n            nextXi.extend(A[i])\n\n    Si = nextXi\n\n\n\nprint((\"Fennec\" if Fp>Sp else \"Snuke\")) \nB. N = int(eval(input()))\n\nG = [[] for _ in range(N)]\n\nvisited = [0]*N\n\nvisited[0],visited[N-1] = 1,1\n\nvisited_all = [1]*N\n\nfor i in range(N-1):\n\n    a,b = list(map(int,input().split()))\n\n    G[a-1].append(b-1)\n\n    G[b-1].append(a-1)\n\nnextA,nextB = G[0],G[N-1]\n\nscoreA,scoreB = 1,1\n\nwhile visited != visited_all:\n\n    l = []\n\n    for a in nextA:\n\n        if visited[a] == 0:\n\n            visited[a] = 1\n\n            scoreA += 1\n\n            for x in G[a]:\n\n                l.append(x)\n\n    nextA = l\n\n    l = []\n\n    for b in nextB:\n\n        if visited[b] == 0:\n\n            visited[b] = 1\n\n            scoreB += 1\n\n            for x in G[b]:\n\n                l.append(x)\n\n    nextB = l\n\nprint((\"Fennec\" if scoreA > scoreB else \"Snuke\"))\n", "output": "A", "improve_diff": 1.0848068772, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\nx=int(eval(input()))\n\nwhile 1:\n\n    flag=0\n\n    for i in range(2,int(x**(1/2))):\n\n        if x%i==0:\n\n            flag=1\n\n            break\n\n    if flag==0:\n\n        break\n\n    x+=1\n\nprint(x) \nB. import bisect, copy, heapq, math, sys\n\nfrom collections import *\n\nfrom functools import lru_cache\n\nfrom itertools import accumulate, combinations, permutations, product\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\ndef ruiseki(lst):\n\n    return [0]+list(accumulate(lst))\n\ndef celi(a,b):\n\n    return -(-a//b)\n\nsys.setrecursionlimit(5000000)\n\nmod=pow(10,9)+7\n\nal=[chr(ord('a') + i) for i in range(26)]\n\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\n\n\nx=int(eval(input()))\n\ndef is_prime(n):\n\n    if n == 1: return False\n\n    for k in range(2, int(math.sqrt(n)) + 1):\n\n        if n % k == 0:\n\n            return False\n\n    return True\n\n\n\nans=x\n\nwhile not is_prime(ans):\n\n    ans+=1\n\nprint(ans)", "output": "A", "improve_diff": 1.7772087722, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\np = tuple(map(int, input().split()))\n\na = list(p)\n\nb = list(p)\n\n\n\nc = 0\n\nfor i in range(N):\n\n    if i+1 == a[i] and i == N-1:\n\n        c += 1\n\n    elif i+1 == a[i]:\n\n        a[i], a[i+1] = a[i+1], a[i]\n\n        c += 1\n\ncc = 0        \n\nfor i in range(N)[::-1]:\n\n    if i+1 == b[i] and i == 0:\n\n        cc += 1\n\n    elif i+1 == b[i]:\n\n        b[i], b[i-1] = b[i-1], b[i]\n\n        cc += 1\n\n        \n\nprint((min(c,cc))) \nB. N = int(eval(input()))\n\np = tuple(map(int, input().split()))\n\na = list(p)\n\nb = list(p)\n\n\n\nc = 0\n\nfor i in range(N):\n\n    if i+1 == a[i] and i == N-1:\n\n        c += 1\n\n    elif i+1 == a[i]:\n\n        a[i], a[i+1] = a[i+1], a[i]\n\n        c += 1\n\ncc = 0        \n\nfor i in range(N)[::-1]:\n\n    if i+1 == b[i] and i == 0:\n\n        cc += 1\n\n    if i+1 == b[i]:\n\n        b[i], b[i-1] = b[i-1], b[i]\n\n        cc += 1\n\n        \n\nprint((min(c,cc)))", "output": "B", "improve_diff": 1.0271773453, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # https://atcoder.jp/contests/abc052/tasks/arc067_b\n\n# \uff1f\n\n\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\n\n\nN, A, B = read_ints()\n\nX = read_ints()\n\n\n\n# numpy\uff1f\n\nX_diff = [x-y for x,y in zip(X[1:],X[:-1])]\n\nans = 0\n\nfor d in X_diff:\n\n    ans += min(B, d * A)\n\nprint(ans)\n \nB. # https://atcoder.jp/contests/abc052/tasks/arc067_b\n\n# \uff1f\n\n\n\nimport sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\nimport numpy as np\n\nN, A, B = read_ints()\n\nX = read_ints()\n\n\n\n# numpy\uff1f\n\nX_diff = np.diff(X)\n\nans = 0\n\nfor d in X_diff:\n\n    ans += min(B, d * A)\n\nprint(ans)\n", "output": "A", "improve_diff": 8.8335104859, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,a,b = list(map(int,input().split()))\n\nans = 0\n\n\n\nfor i in range(n+1):\n\n    keta_wa = 0\n\n    x = i\n\n    while x != 0:\n\n        keta_wa += int(x % 10)\n\n        x /= 10\n\n        #print(keta_wa,x)\n\n    \n\n    if a <= keta_wa <= b:\n\n        ans += i \n\n\n\nprint(ans) \nB. n,a,b = list(map(int,input().split()))\n\nans = 0\n\n\n\nfor i in range(n+1):\n\n    keta_wa = 0\n\n    x = i\n\n    while x != 0:\n\n        keta_wa += int(x % 10)\n\n        x = int(x /10)\n\n        #print(keta_wa,x)\n\n    \n\n    if a <= keta_wa <= b:\n\n        ans += i \n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.1792401791, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nprint((len(set(eval(input()) for _ in range(n))))) \nB. n = int(eval(input()))\n\nD = set(int(eval(input())) for _ in range(n))\n\nprint((len(D)))", "output": "B", "improve_diff": 1.0257515491, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\n\n\nN,K = list(map(int, input().split()))\n\nh = np.array(list(map(int, input().split())))\n\ndp = np.full(N,10**10)\n\ndp[0] = 0\n\nfor i in range(1,N):\n\n    start = max(0,i-K)\n\n    dp[i] = np.min(dp[start:i]+np.abs(h[i]-h[start:i]))\n\nprint((int(dp[-1])))\n \nB. N,K = list(map(int, input().split()))\n\nh = list(map(int, input().split()))\n\n\n\nINF = float('inf')\n\ndp = [INF] * (N)\n\ndp[0] = 0\n\n\n\nfor i in range(1,N):\n\n    cost = INF\n\n    for j in range(max(0,i-K),i):\n\n        # print(h[j],':',h[i])\n\n        dp[i] = min(dp[i], dp[j]+abs(h[j]-h[i]))\n\n    # print(dp)\n\nprint((dp[-1]))\n", "output": "B", "improve_diff": 9.0862522014, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m = list(map(int,input().split()))\n\nalis = sorted(list(map(int,input().split())))\n\nBC = []\n\nclis = []\n\n\n\nfor x in range(m):\n\n    b,c = list(map(int,input().split()))\n\n    BC.append((b,c))\n\nBC = sorted(BC,reverse=True,key=lambda x:x[1])\n\nbk_flg = 1\n\nfor b,c in BC:\n\n    for x in range(b):\n\n        if len(clis) > n:\n\n            bk_flg = 0\n\n            break\n\n        clis.append(c)\n\n    if bk_flg == 0:break;\n\n\n\nfor i in range(min(len(clis),n)):\n\n    if alis[i] < clis[i]:\n\n        alis[i] = clis[i]\n\nprint((sum(alis)))\n \nB. n,m = list(map(int,input().split()))\n\nalis = list(map(int,input().split()))\n\nlis = [list(map(int,input().split())) for x in range(m)]\n\nfor x in alis:\n\n    lis.append([1,x])\n\nlis.sort(reverse=True,key=lambda x:x[1])\n\nans = 0\n\nfor x in lis:\n\n    (number,point) = x\n\n    if number >= n:\n\n        number = n\n\n        ans += number * point\n\n        #print(n)\n\n        #print(ans,'+=',number,'*',point)\n\n        break\n\n    ans += number * point\n\n    n -= number\n\n    #print(n)\n\n    #print(ans,'+=',number,'*',point)\n\nprint(ans)\n\n#print(lis)\n", "output": "A", "improve_diff": 1.046117174, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=list(map(int,input().split()))\n\ndp=[[float(\"inf\")]*(n+1) for _ in range(n)]\n\nz=0\n\nfor l in range(n):\n\n    dp[l][l]=0\n\nfor k in range(1,n+1):\n\n    for i in range(n):\n\n        j=i+k\n\n        if 0<=i<=n-2 and 1<=j<=n:\n\n            if (n-(i+j))%2==0: #\n\n                dp[i][j]=max(dp[i+1][j]+a[i],dp[i][j-1]+a[j-1])\n\n            else:\n\n                dp[i][j]=min(dp[i+1][j]-a[i],dp[i][j-1]-a[j-1])\n\n        elif 0<=i<=n-2 and 0<=j<=n:\n\n            dp[i][j]=dp[i+1][j]+a[i]\n\n        elif 0<=i<=n-1 and 1<=j<=n:\n\n            dp[i][j]=dp[i][j-1]+a[j-1]\n\n        else:\n\n            z=1\n\n\n\nprint((dp[0][n])) \nB. n=int(eval(input()))\n\na=list(map(int,input().split()))\n\ndp=[[float(\"inf\")]*(n+1) for _ in range(n)]\n\nz=0\n\nfor l in range(n):\n\n    dp[l][l]=0\n\nfor k in range(1,n+1):\n\n    for i in range(n-k+1):\n\n        j=i+k\n\n        if 0<=i<=n-2 and 1<=j<=n:\n\n            if (n-(i+j))%2==0: #\n\n                dp[i][j]=max(dp[i+1][j]+a[i],dp[i][j-1]+a[j-1])\n\n            else:\n\n                dp[i][j]=min(dp[i+1][j]-a[i],dp[i][j-1]-a[j-1])\n\n        else:\n\n            dp[i][j]=dp[i][j-1]+a[j-1]\n\nprint((dp[0][n]))", "output": "B", "improve_diff": 1.0469687796, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x,y = list(map(int,input().split()))\n\nn = sorted(list(map(int,input().split())))\n\nprint((sum(n[:y]))) \nB. n,k = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\na.sort()\n\nprint((sum(a[:k])))", "output": "B", "improve_diff": 1.0542247508, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def io_tmp():\n\n    global input\n\n    import io, sys\n\n    f = io.StringIO(open(0).read())\n\n    input = f.readline\n\n\n\nio_tmp()\n\n\n\n\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\n\n\nN, M, L = list(map(int, input().split()))\n\ngraph = [[0] * N for _ in range(N)]\n\nfor _ in range(M):\n\n    s, t, w = list(map(int, input().split()))\n\n    graph[s-1][t-1] = graph[t-1][s-1] = w\n\ndist = floyd_warshall(graph, directed=False)\n\ngraph = [[0] * N for _ in range(N)]\n\nfor i in range(N):\n\n    for j in range(i+1, N):\n\n        if dist[i][j] <= L:\n\n            graph[i][j] = graph[i][j] = 1\n\ndist = floyd_warshall(graph, directed=False)\n\n\n\nQ = int(eval(input()))\n\nfor _ in range(Q):\n\n    s, t = list(map(int, input().split()))\n\n    ans = dist[s-1][t-1]\n\n    if ans == float(\"inf\"):\n\n        print((-1))\n\n    else:\n\n        print((int(ans - 1)))\n \nB. def io_tmp():\n\n    global input\n\n    import io\n\n    f = io.StringIO(open(0).read())\n\n    input = f.readline\n\n\n\nio_tmp()\n\n\n\n\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\n\n\n\nN, M, L = map(int, input().split())\n\ngraph = [[0] * N for _ in range(N)]\n\nfor _ in range(M):\n\n    s, t, w = map(int, input().split())\n\n    graph[s-1][t-1] = graph[t-1][s-1] = w\n\ndist = floyd_warshall(graph, directed=False)\n\ngraph = [[0] * N for _ in range(N)]\n\nfor i in range(N):\n\n    for j in range(i+1, N):\n\n        if dist[i][j] <= L:\n\n            graph[i][j] = graph[i][j] = 1\n\ndist = floyd_warshall(graph, directed=False)\n\n\n\nQ = int(input())\n\nans = []\n\nfor _ in range(Q):\n\n    s, t = map(int, input().split())\n\n    d = dist[s-1][t-1]\n\n    if d == float(\"inf\"):\n\n        ans.append(-1)\n\n    else:\n\n        ans.append(int(d - 1))\n\nprint(*ans, sep='\\n')\n", "output": "A", "improve_diff": 1.0503386649, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. *a,=list(map(int,open(0)));print((min(~-i%10for i in a)-sum(-i//10*10for i in a)-9)) \nB. a=eval('int(input()),'*5);print((min(~-i%10for i in a)-sum(-i//10*10for i in a)-9))", "output": "A", "improve_diff": 1.0221391734, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**6)\n\n##############################\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [0] * M\n\ndp = [-1] * (N+1)\n\n\n\nfor i in range(M):\n\n    a = int(eval(input()))\n\n    dp[a] = 0\n\n\n\ndp[0] = 1\n\nif dp[1] != 0:\n\n    dp[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n    if dp[i] != 0:\n\n        dp[i] = dp[i-1] + dp[i-2]\n\n\n\nprint((dp[N] % 1000000007)) \nB. \n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10**6)\n\n##############################\n\n\n\nN, M = list(map(int, input().split()))\n\nA = [0] * M\n\ndp = [-1] * (N+1)\n\n\n\nfor i in range(M):\n\n    a = int(eval(input()))\n\n    dp[a] = 0\n\n\n\ndp[0] = 1\n\nif dp[1] != 0:\n\n    dp[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n    if dp[i] != 0:\n\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n\n\n\nprint((dp[N]))\n", "output": "A", "improve_diff": 1.0179125717, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import bisect;n,a,l=int(eval(input())),[-int(eval(input()))],1\n\nfor i in range(n-1):\n\n  b=-int(eval(input()))\n\n  if a[-1]>b:a[bisect.bisect_right(a,b)]=b\n\n  else:a.append(b);l+=1\n\nprint(l) \nB. import bisect\n\nn=int(eval(input()))\n\nx=[int(eval(input()))for _ in range(n)]\n\na=[-x[0]]\n\nl=1\n\nfor i in range(1,n):\n\n  b=-x[i]\n\n  if a[-1]>b:\n\n    if a[0]>b:a[0]=b;continue\n\n    a[bisect.bisect_right(a,b)]=b\n\n  else:a.append(b);l+=1\n\nprint(l)", "output": "A", "improve_diff": 1.0110620691, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # coding = SJIS\n\n\n\nk, s = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor x in range(0, k + 1):\n\n    for y in range(0, k + 1):\n\n        z = s - x - y\n\n        if 0 <= z and z <= k:\n\n            ans += 1\n\n\n\nprint(ans) \nB. # coding = SJIS\n\nk, s = list(map(int, input().split()))\n\nif s < k:\n\n    ans = (s + 1) * (s + 2) / 2\n\nelif s <= 2 * k:\n\n    t = 2 * k - s\n\n    ans = ((k + 1) * (k + 2) / 2) - ((2 * k - s) * ((2 * k - s) + 1) / 2) + (t * (2 * k - ((2 * k - s) - 1)) / 2)\n\nelif s <= 3 * k:\n\n    ans = (3 * k - s + 1) * ((3 * k - s + 1) + 1) / 2\n\nprint((int(ans)))", "output": "B", "improve_diff": 1.0238485208, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #BFS\n\n#s= n= e=\n\ndef glaph_bfs(s,n,e):\n\n  Q=[s]\n\n  visited={s}\n\n  while Q:\n\n    P=[]\n\n    for i in Q:\n\n      for j,_ in e[i]:\n\n        if j in visited:continue\n\n        visited.add(j)\n\n        P.append(j)\n\n    Q=P\n\n  return visited\n\n  \n\n\n\n#\n\n#n= e=[[a,b,c],[]...](a~bc)\n\ndef find_negative_loop(n,e):\n\n\td=n*[10**20];d[0]=0\n\n\tfor h in range(n):\n\n\t\tfor i,j,k in e:\n\n\t\t\tif d[j]>d[i]+k:\n\n\t\t\t\td[j]=d[i]+k\n\n\t\t\t\tif h==n-1:return True\n\n\treturn False\n\n\n\n#(d[i]=si)\n\n#()\n\n#s= n= e=[[a,b,c],[]...](a~bc)\n\ndef bellman_ford(s,n,e):\n\n  inf=10**20;d=[inf]*n;d[s]=0\n\n  while 1:\n\n    f=True\n\n    for i,j,k in e:\n\n      if d[i]!=inf and d[j]>d[i]+k:d[j]=d[i]+k;f=False\n\n    if f:break\n\n  return d\n\n\n\nn,m,p=list(map(int,input().split()))\n\nedge=[[]for _ in range(n)]\n\nedger=[[]for _ in range(n)]\n\nfor _ in range(m):\n\n  a,b,c=list(map(int,input().split()))\n\n  c-=p\n\n  a-=1\n\n  b-=1\n\n  edge[a].append((b,c))\n\n  edger[b].append((a,c))\n\nvisited=glaph_bfs(0,n,edge)\n\nvisitedr=glaph_bfs(n-1,n,edger)\n\nfor i in range(n):\n\n  if not(i in visited and i in visitedr):edge[i]=[]\n\ne=[]\n\nfor i in range(n):\n\n  for j in range(len(edge[i])):e.append((i,edge[i][j][0],-edge[i][j][1]))\n\nif find_negative_loop(n,e):print((-1));exit()\n\nprint((max(-bellman_ford(0,n,e)[n-1],0))) \nB. import sys\n\ninput=sys.stdin.readline\n\nsys.setrecursionlimit(10000000)\n\n\n\ndef find_negative_loop(n,e):\n\n  d=n*[10**20];d[0]=0\n\n  for h in range(n):\n\n    for i,j,k in e:\n\n      if d[j]>d[i]+k:\n\n        d[j]=d[i]+k\n\n        if h==n-1:return -1\n\n  return max(-d[n-1],0)\n\n\n\nfrom collections import deque\n\ndef find_loop(n,e,flag):\n\n  x=[0]*n\n\n  d=deque()\n\n  t=[]\n\n  c=0\n\n  for i in range(n):\n\n    for j in e[i]:x[j]+=1\n\n  for i in range(n):\n\n    if x[i]==0:\n\n      d.append(i)\n\n      t.append(i)\n\n      c+=1\n\n  while d:\n\n    i=d.popleft()\n\n    for j in e[i]:\n\n      x[j]-=1\n\n      if x[j]==0:\n\n        d.append(j)\n\n        t.append(j)\n\n        c+=1\n\n  if flag==0:return c==n\n\n  else:return t\n\n\n\ndef glaph_bfs(s,n,e):\n\n  ans=[0]*n\n\n  Q=[s]\n\n  visited={s}\n\n  while Q:\n\n    P=[]\n\n    for i in Q:\n\n      ans[i]=1\n\n      for j in e[i]:\n\n        if j in visited:continue\n\n        visited.add(j)\n\n        P.append(j)\n\n    Q=P\n\n  return ans\n\n\n\nn,m,p=list(map(int,input().split()))\n\nef=[[]for _ in range(n)]\n\nee=[[]for _ in range(n)]\n\ne=[]\n\nfor _ in range(m):\n\n  a,b,c=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  c-=p\n\n  ef[a].append(b)\n\n  ee[b].append(a)\n\n  e.append((a,b,c))\n\neff=glaph_bfs(0,n,ef)\n\neef=glaph_bfs(n-1,n,ee)\n\nee=[]\n\nfor a,b,c in e:\n\n  if eff[a]==1 and eef[a]==1 and eff[b]==1 and eef[b]==1:\n\n    ee.append((a,b,-c))\n\nprint((find_negative_loop(n,ee)))", "output": "A", "improve_diff": 1.4678146445, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\n\n\nn,m = list(map(int,readline().split()))\n\na = list(map(int,readline().split()))\n\n\n\nb = [0]*(n+1)\n\na.sort()\n\nfor i in range(n):\n\n  b[i+1] = b[i]+a[i]\n\n\n\ndef is_ok(arg):\n\n    c = 0\n\n    f = False\n\n    for i in a:\n\n      if c >= m:\n\n        break\n\n      c += (n-bisect_left(a,arg-i))\n\n    if c >= m:\n\n      f = True\n\n    return f\n\n\n\ndef bisect_ok(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) // 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nx = bisect_ok(2*a[-1]+1,1)\n\nans = 0\n\ncnt = 0\n\nfor i in a:\n\n  ind = n-bisect_left(a,x-i)\n\n  cnt += ind\n\n  ans += i*ind+(b[-1]-b[n-ind])\n\nif cnt > m:\n\n  ans -= x*(cnt-m)\n\nprint(ans) \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\nmm = 10**10\n\nk = mm.bit_length()\n\nK = 1<<k\n\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\n\nst = lambda n: bin(n)[2:] + \"0\"\n\nli = lambda s: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(200001)]]\n\n\n\nn,m = list(map(int, input().split()))\n\na = [int(i) for i in input().split()]\n\nb = [0]*100001\n\n\n\nfor i in a:\n\n    b[i] += 1\n\n    \n\nc = li(st(nu(b)*nu(b)))\n\nans = 0\n\nfor i in range(200001)[::-1]:\n\n    if c[i] > 0:\n\n      p = min(m,c[i])\n\n      m -= p\n\n      ans += i*p\n\n      if m == 0:\n\n        break\n\nprint(ans)", "output": "A", "improve_diff": 8.971225321, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from decimal import *\n\n\n\ngetcontext().prec = 20      # 2820\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nA = Decimal(a).sqrt()\n\nB = Decimal(b).sqrt()\n\nC = Decimal(c).sqrt()\n\nif A+B < C:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n \nB. a, b, c = list(map(int, input().split()))\n\nif c - a - b >= 0 and 4*(a*b) < (c - a - b)**2:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n", "output": "B", "improve_diff": 1.6277526948, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while True:\n\n    num = list(map(int,input().split()))\n\n    if(num[0] == 0 and num[1] == 0): break\n\n    c = 0\n\n    for i in range(1,num[0]+1):\n\n        for j in range(i+1,num[0]+1):\n\n            if j <= i:\n\n                continue\n\n            k = num[1]-(i+j)\n\n            if k > j and k <= num[0]:\n\n                c+= 1\n\n    print(c)\n \nB. while True:\n\n    num = list(map(int,input().split()))\n\n    if(num[0] == 0 and num[1] == 0): break\n\n    c = 0\n\n    for i in range(1,num[0] - 1):\n\n        for j in range(i+1,num[0]):\n\n            for k in range(j+1,num[0]+1):\n\n                if(i+j+k == num[1]): c += 1\n\n    \n\n    print(c)\n", "output": "B", "improve_diff": 1.0157643963, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [tuple(map(int, input().split())) for _ in range(N)]\n\nans = []\n\nimport numpy as np\n\nfor i in range(len(A)-1):\n\n    for k in range(i+1,len(A)):\n\n        ans.append(np.sqrt(((A[i][0]-A[k][0])**2)+(A[i][1]-A[k][1])**2))\n\nprint((sum(ans)*2/N)) \nB. N = int(eval(input()))\n\nA = [tuple(map(int, input().split())) for _ in range(N)]\n\nans = []\n\nfor i in range(len(A)-1):\n\n    for k in range(i+1,len(A)):\n\n        ans.append((((A[i][0]-A[k][0])**2)+(A[i][1]-A[k][1])**2)**0.5)\n\nprint((sum(ans)*2/N))", "output": "B", "improve_diff": 9.7662799799, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput=sys.stdin.readline\n\n\n\nclass list2D:\n\n    def __init__(self, H, W, num):\n\n        self.__H = H\n\n        self.__W = W\n\n        self.__dat = [num] * (H * W)\n\n\n\n    def __getitem__(self, a):\n\n        return self.__dat[a[0]*self.__W+a[1]]\n\n\n\n    def __setitem__(self, a, b):\n\n        self.__dat[a[0]*self.__W+a[1]] = b\n\n\n\n    def debug(self):\n\n        print(self.__dat)\n\n\n\nclass list3D:\n\n    def __init__(self, H, W, D, num):\n\n        self.__H = H\n\n        self.__W = W\n\n        self.__D = D\n\n        self.__X = W * D\n\n        self.__dat = [num] * (H * W * D)\n\n\n\n    def __getitem__(self, a):\n\n        return self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]]\n\n\n\n    def __setitem__(self, a, b):\n\n        self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]] = b\n\n\n\n    def debug(self):\n\n        print(self.__dat)\n\n\n\ndef main():\n\n    r,c,k=map(int,input().split())\n\n    v = list2D(r, c, 0)\n\n\n\n    for _ in range(k):\n\n        ri,ci,a=map(int,input().split())\n\n        v[ri-1, ci-1] = a\n\n\n\n    dp = list3D(r, c, 4, 0)\n\n    #print(dp)\n\n    if v[0, 0]>0: dp[0, 0, 1] = v[0, 0]\n\n\n\n    for i in range(r):\n\n        for j in range(c):\n\n            val = v[i, j]\n\n            if i>0:\n\n                x = max(dp[i-1, j, 0], dp[i-1, j, 1], dp[i-1, j, 2], dp[i-1, j, 3])\n\n                dp[i, j, 1]=x+val\n\n                dp[i, j, 0]=x\n\n\n\n            if j>0:\n\n                X = dp[i, j-1, 0]\n\n                Y = dp[i, j-1, 1]\n\n                V = dp[i, j-1, 2]\n\n                Z = dp[i, j-1, 3]\n\n                dp[i, j, 0]=max(dp[i, j, 0],X)\n\n                dp[i, j, 1]=max(dp[i, j, 1],X+val,Y)\n\n                dp[i, j, 2]=max(Y+val,V)\n\n                dp[i, j, 3]=max(V+val,Z)\n\n\n\n    #print(dp)\n\n    ans=0\n\n    for i in range(4): ans=max(dp[r-1, c-1, i],ans)\n\n    return print(ans)\n\nif __name__==\"__main__\":\n\n    main()\n \nB. import sys\n\ninput=sys.stdin.readline\n\n\n\nclass list2D:\n\n    def __init__(self, H, W, num):\n\n        self.__H = H\n\n        self.__W = W\n\n        self.__dat = [num] * (H * W)\n\n\n\n    def __getitem__(self, a):\n\n        return self.__dat[a[0]*self.__W+a[1]]\n\n\n\n    def __setitem__(self, a, b):\n\n        self.__dat[a[0]*self.__W+a[1]] = b\n\n\n\n    def debug(self):\n\n        print(self.__dat)\n\n\n\nclass list3D:\n\n    def __init__(self, H, W, D, num):\n\n        self.__H = H\n\n        self.__W = W\n\n        self.__D = D\n\n        self.__X = W * D\n\n        self.__dat = [num] * (H * W * D)\n\n\n\n    def __getitem__(self, a):\n\n        return self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]]\n\n\n\n    def __setitem__(self, a, b):\n\n        self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]] = b\n\n\n\n    def debug(self):\n\n        print(self.__dat)\n\n\n\ndef main():\n\n    r,c,k=map(int,input().split())\n\n    v = list2D(r, c, 0)\n\n\n\n    for _ in range(k):\n\n        ri,ci,a=map(int,input().split())\n\n        v[ri-1, ci-1] = a\n\n\n\n    dp = list3D(r, c, 4, 0)\n\n    #print(dp)\n\n    if v[0, 0]>0: dp[0, 0, 1]=v[0, 0]\n\n\n\n    for i in range(r):\n\n        for j in range(c):\n\n            val = v[i, j]\n\n            if i>0:\n\n                x = max(dp[i-1, j, 0], dp[i-1, j, 1], dp[i-1, j, 2], dp[i-1, j, 3])\n\n                dp[i, j, 1]=max(dp[i, j, 1],x+val)\n\n                dp[i, j, 0]=max(dp[i, j, 0],x)\n\n\n\n            if j>0:\n\n                X = dp[i, j-1, 0]\n\n                Y = dp[i, j-1, 1]\n\n                V = dp[i, j-1, 2]\n\n                Z = dp[i, j-1, 3]\n\n                dp[i, j, 0]=max(dp[i, j, 0],X)\n\n                dp[i, j, 1]=max(dp[i, j, 1],X+val,Y)\n\n                dp[i, j, 2]=max(dp[i, j, 2],Y+val,V)\n\n                dp[i, j, 3]=max(dp[i, j, 3],V+val,Z)\n\n\n\n    #print(dp)\n\n    ans=0\n\n    for i in range(4): ans=max(dp[r-1, c-1, i],ans)\n\n    return print(ans)\n\nif __name__==\"__main__\":\n\n    main()\n", "output": "A", "improve_diff": 1.023307636, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A,B=list(map(int,input().split()))\n\ncount=0\n\nfor i in range(A,B+1):\n\n    if str(i) == ''.join(reversed(str(i))):\n\n\n\n        count+=1\n\n\n\n        \n\nprint(count)\n \nB. A,B=list(map(int,input().split()))\n\ncount=0\n\nfor i in range(A,B+1):\n\n    if list(str(i)) == list(reversed(str(i))):\n\n\n\n        count+=1\n\n\n\n        \n\nprint(count)\n", "output": "A", "improve_diff": 1.1010629919, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n \n\ncnt=0\n\n \n\nfor i in a:\n\n\tif (sum(a)/(4*m))<=i:\n\n\t\tcnt+=1\n\n\t\tif cnt==m:\n\n\t\t\tprint(\"Yes\")\n\n            \n\nif cnt<m:\n\n\tprint(\"No\") \nB. from fractions import Fraction\n\nn,m=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\ncnt=0\n\n\n\nfor i in a:\n\n\tif (sum(a))*(Fraction(1,4*m))<=i:\n\n\t\tcnt+=1\n\n\t\tif cnt==m:\n\n\t\t\tprint(\"Yes\")\n\n            \n\nif cnt<m:\n\n\tprint(\"No\")", "output": "A", "improve_diff": 2.1470860952, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from sys import stdin\n\nimport sys\n\nimport numpy as np\n\nimport collections\n\nfrom functools import cmp_to_key\n\nimport heapq\n\n\n\n##  input functions for me\n\ndef rsa(sep = ''):\n\n    if sep == '' :\n\n        return input().split() \n\n    else: return input().split(sep)\n\ndef rip(sep = ''):\n\n    if sep == '' :\n\n        return list(map(int, input().split())) \n\n    else: return list(map(int, input().split(sep)))\n\ndef ria(sep = ''): \n\n    return list(rip(sep))\n\ndef ri(): return int(eval(input()))\n\ndef rd(): return float(eval(input()))\n\ndef rs(): return eval(input())\n\n##\n\n\n\ndef inv(v, mod):\n\n    return pow(v, mod-2, mod)\n\ndef main():\n\n    r1, c1, r2, c2 = rip()\n\n\n\n    MM = int(2e6+10)\n\n    fact = [0] * MM\n\n    finv = [0] * MM\n\n    fact[0] = 1\n\n    finv[0] = 1\n\n    mod = int(1e9) + 7\n\n    for i in range(1,MM): fact[i] = (fact[i-1] * i % mod)\n\n    finv[MM-1] = inv(fact[MM-1], mod)\n\n    for i in reversed(list(range(1,MM-1))):\n\n        finv[i] = finv[i + 1] * (i + 1) % mod\n\n    def sum_naive(r, c):\n\n        #[0, r) * [0, c)\n\n        ret = 0\n\n        for i in range(r):\n\n            ret += fact[i + 1 + c - 1] * finv[i + 1] * finv[c - 1] % mod\n\n        return ret\n\n    def sum(r, c):\n\n        #[0, r) * [0, c)\n\n        ret = fact[r + c] * finv[r] * finv[c] % mod\n\n        ret += -1 + mod\n\n        ret %= mod\n\n        return ret\n\n\n\n    ans = 0\n\n    ans += sum(r2 + 1, c2 + 1)\n\n    ans -= sum(r2 + 1, c1)\n\n    ans -= sum(r1, c2 + 1)\n\n    ans += sum(r1, c1)\n\n    ans %= mod\n\n    print(ans)\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. from sys import stdin\n\nimport sys\n\nimport numpy as np\n\nimport collections\n\nfrom functools import cmp_to_key\n\nimport heapq\n\n\n\n##  input functions for me\n\ndef rsa(sep = ''):\n\n    if sep == '' :\n\n        return input().split() \n\n    else: return input().split(sep)\n\ndef rip(sep = ''):\n\n    if sep == '' :\n\n        return list(map(int, input().split())) \n\n    else: return list(map(int, input().split(sep)))\n\ndef ria(sep = ''): \n\n    return list(rip(sep))\n\ndef ri(): return int(eval(input()))\n\ndef rd(): return float(eval(input()))\n\ndef rs(): return eval(input())\n\n##\n\n\n\ndef inv(v, mod):\n\n    return pow(v, mod-2, mod)\n\ndef main():\n\n    r1, c1, r2, c2 = rip()\n\n\n\n    MM = int(2e6+10)\n\n    fact = [0] * MM\n\n    finv = [0] * MM\n\n    fact[0] = 1\n\n    finv[0] = 1\n\n    mod = int(1e9) + 7\n\n    for i in range(1,MM): fact[i] = (fact[i-1] * i % mod)\n\n    '''\n\n    finv[MM-1] = inv(fact[MM-1], mod)\n\n    for i in reversed(range(1,MM-1)):\n\n        finv[i] = finv[i + 1] * (i + 1) % mod\n\n    def sum_naive(r, c):\n\n        #[0, r) * [0, c)\n\n        ret = 0\n\n        for i in range(r):\n\n            ret += fact[i + 1 + c - 1] * finv[i + 1] * finv[c - 1] % mod\n\n        return ret\n\n    def sum(r, c):\n\n        #[0, r) * [0, c)\n\n        ret = fact[r + c] * finv[r] * finv[c] % mod\n\n        ret += -1 + mod\n\n        ret %= mod\n\n        return ret\n\n    '''\n\n    def sum(r, c):\n\n        #[0, r) * [0, c)\n\n        ret = fact[r + c] * inv(fact[r], mod) * inv(fact[c], mod) % mod\n\n        ret += -1 + mod\n\n        ret %= mod\n\n        return ret\n\n    ans = 0\n\n    ans += sum(r2 + 1, c2 + 1)\n\n    ans -= sum(r2 + 1, c1)\n\n    ans -= sum(r1, c2 + 1)\n\n    ans += sum(r1, c1)\n\n    ans %= mod\n\n    print(ans)\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n", "output": "B", "improve_diff": 1.8074932235, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import lru_cache\n\nN = int(eval(input()))\n\nK = int(eval(input()))\n\n\n\n@lru_cache(None)\n\n\n\ndef F(N,K):\n\n  assert N>=0\n\n  if N<10:\n\n    if K==0:\n\n      return 1\n\n    if K==1:\n\n      return N\n\n    return 0\n\n  q,r = divmod(N,10)\n\n  ret = 0\n\n  if K>=1:\n\n    ret += F(q,K-1)*r\n\n    ret += F(q-1,K-1)*(9-r)\n\n  ret += F(q,K)\n\n  return ret\n\n\n\nprint((F(N,K))) \nB. from operator import mul\n\nfrom functools import reduce\n\n\n\ndef cmb(n,r):\n\n    r = min(n-r,r)\n\n    if r == 0: return 1\n\n    over = reduce(mul, list(range(n, n - r, -1)))\n\n    under = reduce(mul, list(range(1,r + 1)))\n\n    return over // under\n\nN = int(eval(input()))\n\nK = int(eval(input()))\n\nL = len(str(N))\n\nS = str(N)\n\nif K>L:\n\n  print((0))\n\n  import sys\n\n  sys.exit()\n\nif K==1:\n\n  s = ['0']*L\n\n  cnt = 0\n\n  for i in range(L):\n\n    for j in range(1,10):\n\n      s[i] = str(j)\n\n      x = ''.join(s)\n\n      x = int(x)\n\n      if x<=N:\n\n        cnt += 1\n\n      s[i] = '0'\n\nelif K==2:\n\n  s = ['0']*L\n\n  cnt = 0\n\n  for i in range(L-1):\n\n    for j in range(i+1,L):\n\n      for a in range(1,10):\n\n        for b in range(1,10):\n\n          s[i] = str(a)\n\n          s[j] = str(b)\n\n          x = ''.join(s)\n\n          x = int(x)\n\n          if x<=N:\n\n            cnt += 1\n\n          s[i] = '0'\n\n          s[j] = '0'\n\nelse:\n\n  s = ['0']*L\n\n  cnt = 0\n\n  cnt += cmb(L-1,3)*(9**3) if L>3 else 0\n\n  g = int(S[0])\n\n  s[0] = S[0]\n\n  for i in range(1,L-1):\n\n    for j in range(i+1,L):\n\n      for a in range(1,10):\n\n        for b in range(1,10):\n\n          s[j] = str(a)\n\n          s[i] = str(b)\n\n          x = ''.join(s)\n\n          x = int(x)\n\n#          print(x)\n\n          if x<=N:\n\n            cnt += g\n\n          else:\n\n            cnt += g-1\n\n          s[i] = '0'\n\n          s[j] = '0'\n\nprint(cnt)", "output": "A", "improve_diff": 7.1968857688, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    possible = 0\n\n    for i in range(1, N + 1):\n\n        this_poss = 1\n\n        if i < K:\n\n            t = i\n\n            while t < K:\n\n                this_poss *= 0.5\n\n                t *= 2\n\n        possible += this_poss / N\n\n    print(possible)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. import sys\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    P = 0\n\n    for i in range(1, N + 1):\n\n        coins = 0\n\n        k = i\n\n        while k < K:\n\n            coins += 1\n\n            k *= 2\n\n        P += pow(0.5, coins) / N\n\n    print(P)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "output": "A", "improve_diff": 1.1192407155, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A,B=list(map(int, input().split()))\n\nprint(((A+B)//2 if (A+B)&1==0 else 'IMPOSSIBLE')) \nB. A, B = list(map(int, input().split()))\n\nif A > B: A, B = B, A\n\nif (B - A) & 1:\n\n    print('IMPOSSIBLE')\n\n    exit()\n\nprint((A + (B - A) // 2))\n", "output": "A", "improve_diff": 1.0134381639, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\ndp = [[0 for i in range(n)] for i in range(2)]\n\na1 = list(map(int, input().split()))\n\na2 = list(map(int, input().split()))\n\n\n\ndp[0][0] = a1[0]\n\nfor i in range(1, n):\n\n    dp[0][i] = dp[0][i - 1] + a1[i]\n\ndp[1][0] = dp[0][0] + a2[0]\n\n\n\nfor i in range(1, n):\n\n    dp[1][i] = max(dp[0][i] + a2[i], dp[1][i - 1] + a2[i])\n\n\n\nprint((dp[1][-1]))\n \nB. n = int(eval(input()))\n\na1 = list(map(int, input().split()))\n\na2 = list(map(int, input().split()))\n\n\n\nfor i in range(1, n):\n\n    a1[i] += a1[i - 1]\n\n\n\nfor i in range(n - 2, -1, -1):\n\n    a2[i] += a2[i + 1]\n\n\n\nres = 0\n\nfor i in range(n):\n\n    tmp = a1[i] + a2[i]\n\n    res = max(tmp, res)\n\n\n\nprint(res)\n", "output": "A", "improve_diff": 1.0369378434, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nn = int(eval(input()))\n\nprint((math.floor(n**0.5)**2)) \nB. n = int(eval(input()))\n\n\n\nfor i in range(n, 0, -1):\n\n  if str(i ** 0.5)[-1] == \"0\":\n\n    print(i)\n\n    exit()", "output": "B", "improve_diff": 1.14945306, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nn = int(eval(input()))\n\nlis = list(map(int, input().split()))\n\n\n\na = Counter(lis[::2])\n\nb = Counter(lis[1::2])\n\n\n\naa = sorted(list(a.items()), key=lambda x:x[1], reverse=True)\n\nbb = sorted(list(b.items()), key=lambda x:x[1], reverse=True)\n\n\n\nif aa[0][0] == bb[0][0]:\n\n    if len(aa) > 1 and len(bb) > 1:\n\n        res = n - max(aa[0][1]+bb[1][1], aa[1][1]+bb[0][1])\n\n    elif len(aa) == 1 and len(bb) > 1:\n\n        res = n - aa[0][1] - bb[1][1]\n\n    elif len(aa) > 1 and len(bb) == 1:\n\n        res = n - aa[1][1] - bb[0][1]\n\n    else:\n\n        res = n - aa[0][1]\n\nelse:\n\n    res = n - aa[0][1] - bb[0][1]\n\n\n\nprint(res)\n \nB. from collections import Counter\n\nn = int(eval(input()))\n\nlis = list(map(int, input().split()))\n\n\n\na = Counter(lis[::2])\n\nb = Counter(lis[1::2])\n\n\n\naa = sorted(list(a.items()), key=lambda x:x[1], reverse=True)\n\nbb = sorted(list(b.items()), key=lambda x:x[1], reverse=True)\n\n\n\naa.append((0, 0))\n\nbb.append((0, 0))\n\n\n\nif aa[0][0] == bb[0][0]:\n\n    res = n - max(aa[0][1]+bb[1][1], aa[1][1]+bb[0][1])\n\nelse:\n\n    res = n - aa[0][1] - bb[0][1]\n\nprint(res)\n", "output": "B", "improve_diff": 1.0573685191, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k = list(map(int, input().split()))\n\n\n\nif (n-1)%(k-1)==0:\n\n    print(((n-1)//(k-1)))\n\nelse:\n\n    print(((n-1)//(k-1)+1))\n \nB. import math\n\n\n\nn,k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\nans = math.ceil((n-1)/(k-1))\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.2514758028, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # Reference: https://note.nkmk.me/python-union-find/\n\nclass UnionFind:\n\n    # if x is root: self.parents[x] = -(the number of the group nodes)\n\n    # else: self.parents[x] = the parent of x\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    # return the parent of x\n\n    def find(self, x):\n\n        history = []\n\n        while self.parents[x] >= 0:\n\n            history.append(x)\n\n            x = self.parents[x]\n\n        for node in history:\n\n            self.parents[node] = x\n\n        return x\n\n\n\n    # merge the group of x and the group of y\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    # return the size of the group of x\n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n\n\nfrom sys import stdin\n\ninput = stdin.buffer.readline\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    l = [0] * n\n\n    for i in range(n):\n\n        x, y = list(map(int, input().split()))\n\n        l[x-1] = (y-1, i)\n\n\n\n    uf = UnionFind(n)\n\n    roots = []\n\n\n\n    for y, i in l:\n\n        if len(roots) == 0 or roots[-1][0] > y:\n\n            roots.append((y, i))\n\n        else:\n\n            new_y = roots[-1][0]\n\n            while len(roots) > 0 and roots[-1][0] < y:\n\n                old_y, old_i = roots.pop()\n\n                uf.union(i, old_i)\n\n            roots.append((new_y, i))\n\n\n\n    # O(uf.size(i)) = 1\n\n    for i in range(n):\n\n        print((uf.size(i)))\n\n\n\nmain()\n \nB. # Reference: https://note.nkmk.me/python-union-find/\n\nclass UnionFind:\n\n    # if x is root: self.parents[x] = -(the number of the group nodes)\n\n    # else: self.parents[x] = the parent of x\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    # return the parent of x\n\n    def find(self, x):\n\n        history = []\n\n        while self.parents[x] >= 0:\n\n            history.append(x)\n\n            x = self.parents[x]\n\n        for node in history:\n\n            self.parents[node] = x\n\n        return x\n\n\n\n    # merge the group of x and the group of y\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n\n\n    # return the size of the group of x\n\n    def size(self, x):\n\n        return -self.parents[self.find(x)]\n\n\n\n    # return whether x and y in a same group\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    # return [all nodes which is in the group of x]\n\n    # O(n)\n\n    def members(self, x):\n\n        root = self.find(x)\n\n        return [i for i in range(self.n) if self.find(i) == root]\n\n\n\n    # return [all roots]\n\n    # O(n)\n\n    def roots(self):\n\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\n\n    # return {root: members of the group}\n\n    # O(n * n)\n\n    def all_group_members(self):\n\n        return {r: self.members(r) for r in self.roots()}\n\n\n\nfrom bisect import bisect\n\nfrom sys import stdin\n\ninput = stdin.buffer.readline\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    l = [0] * n\n\n    for i in range(n):\n\n        x, y = list(map(int, input().split()))\n\n        l[x-1] = (y - 1, i)\n\n\n\n    # i\n\n    uf = UnionFind(n)\n\n    roots = []\n\n\n\n    for y, i in l:\n\n        if len(roots) == 0 or -roots[-1][0] > y:\n\n            roots.append((-y, i))\n\n        else:\n\n            ind = bisect(roots, (-y, i))\n\n            new_y = roots[-1][0]\n\n            for old_y, old_i in roots[ind:]:\n\n                uf.union(i, old_i)\n\n            roots = roots[:ind]\n\n            roots.append((new_y, i))\n\n\n\n    for i in range(n):\n\n        print((uf.size(i)))\n\n\n\nmain()", "output": "A", "improve_diff": 1.2723930361, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import permutations\n\nfrom math import sqrt\n\n\n\nn=int(eval(input()))\n\npermlist = list(permutations(list(range(n))))\n\n#print('permlist: {}'.format(permlist))\n\n\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    xi,yi = list(map(int,input().split()))\n\n    x.append(xi)\n\n    y.append(yi)\n\n\n\nlengths = 0.0\n\nfor p in permlist:\n\n    length = 0.0\n\n    for _ in range(len(p)-1):\n\n        i = p[_]\n\n        j = p[_+1]\n\n        #print('i: {} j:{}'.format(i,j))\n\n        length += sqrt( (x[i]-x[j])**2 + (y[i]-y[j])**2 )\n\n    #print('length: {}'.format(length))\n\n    lengths += length\n\n\n\nprint((lengths/len(permlist)))\n \nB. from itertools import permutations\n\nfrom math import sqrt\n\n\n\ndef readinput():\n\n    n=int(eval(input()))\n\n    xyList=[]\n\n    for _ in range(n):\n\n        x,y=list(map(int,input().split()))\n\n        xyList.append((x,y))\n\n    return n,xyList\n\n\n\ndef main(n,xyList):\n\n    sum=0.0\n\n    factn=0\n\n    for tup in permutations(list(range(n))):\n\n        #print(tup)\n\n        factn+=1\n\n        x0=xyList[tup[0]][0]\n\n        y0=xyList[tup[0]][1]\n\n        for i in tup:\n\n            x=xyList[i][0]\n\n            y=xyList[i][1]\n\n            sum+=sqrt((x-x0)**2+(y-y0)**2)\n\n            x0=x\n\n            y0=y\n\n    ans=sum/factn\n\n    return ans\n\n\n\nif __name__=='__main__':\n\n    n,xyList=readinput()\n\n    #print(xyList)\n\n    ans=main(n,xyList)\n\n    print(ans)\n\n\n", "output": "A", "improve_diff": 1.0380230217, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b = input().split()\n\na = int(a)\n\nb = int(b.replace(\".\", \"\"))\n\nprint((a*b//100)) \nB. import decimal\n\na, b = (decimal.Decimal(x) for x in input().split())\n\nprint((int(a*b)))", "output": "A", "improve_diff": 1.5818514982, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def mk_table(n):\n\n    res = [1] * (n + 1)\n\n    res[:2] = 0, 0\n\n\n\n    for i in range(2, n):\n\n        if i ** 2 > n:\n\n            break\n\n\n\n        if res[i] == 1:\n\n            for j in range(i*2, n + 1, i):\n\n                res[j] = 0\n\n\n\n    return res\n\n\n\n\n\ntbl = mk_table(999999)\n\ntry:\n\n    while 1:\n\n        print((len([x for x in tbl[:int(eval(input()))+1] if x == 1])))\n\nexcept Exception:\n\n    pass \nB. def mk_table(n):\n\n    res = [1] * (n + 1)\n\n    res[:2] = [0, 0]\n\n\n\n    for i in range(2, n):\n\n        if i ** 2 > n:\n\n            break\n\n\n\n        if res[i] == 1:\n\n            j = 2\n\n            while i * j <= n:\n\n                res[i * j] = 0\n\n                j += 1\n\n\n\n    return res\n\n\n\n\n\ntbl = mk_table(999999)\n\ntry:\n\n    while 1:\n\n        print((len([x for x in tbl[:int(eval(input()))+1] if x == 1])))\n\nexcept Exception:\n\n    pass", "output": "A", "improve_diff": 2.4239461536, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n# \n\nsys.setrecursionlimit(10**5+10)\n\n\n\n# input\n\ninput = sys.stdin.readline\n\n\n\n# \n\nvacation = int(eval(input()))\n\nlst_happiness = [list(map(int, input().split())) for i in range(vacation)]\n\n\n\n# DP\n\n# 0\n\ndp = [[0 for i in range(3)] for j in range(vacation+1)]\n\n\n\n# dp\n\ndef chmax(a, b):\n\n    if a > b:\n\n        return a\n\n    else:\n\n        return b\n\n\n\n# \n\ndef rec(i):\n\n    # DP\n\n    for j in range(3):\n\n        if dp[i][j] > 0:\n\n            break\n\n        \n\n        # \n\n        if i == 0:\n\n            dp[i][j] = 0\n\n            break\n\n        \n\n        # i-1 \n\n        res = 0\n\n        for k in range(3):\n\n            if j == k:\n\n                continue\n\n            res = chmax(res, rec(i-1)[k] + lst_happiness[i-1][k])\n\n            # \n\n            dp[i][j] = res\n\n    \n\n    return dp[i]\n\n\n\nans = rec(vacation)\n\nans = max(ans)\n\nprint(ans) \nB. import sys\n\nimport numpy as np\n\n\n\n# input\n\ninput = sys.stdin.readline\n\n\n\n# \n\nvacation = int(eval(input()))\n\nlst_happiness = [list(map(int, input().split())) for i in range(vacation)]\n\n\n\n# lst_happinessndarray\n\narr_happiness_a = np.array([lst_happiness[i][0] for i in range(vacation)])\n\narr_happiness_b = np.array([lst_happiness[i][1] for i in range(vacation)])\n\narr_happiness_c = np.array([lst_happiness[i][2] for i in range(vacation)])\n\n\n\n# DPndarray\n\ndp_a = np.zeros(vacation, dtype=int)\n\ndp_b = np.zeros(vacation, dtype=int)\n\ndp_c = np.zeros(vacation, dtype=int)\n\n\n\n# dp\n\ndp_a[0] = arr_happiness_a[0]\n\ndp_b[0] = arr_happiness_b[0]\n\ndp_c[0] = arr_happiness_c[0]\n\n\n\nfor i in range(1, vacation):\n\n    dp_a[i] += max(dp_b[i-1], dp_c[i-1]) + arr_happiness_a[i]\n\n    dp_b[i] += max(dp_a[i-1], dp_c[i-1]) + arr_happiness_b[i]\n\n    dp_c[i] += max(dp_a[i-1], dp_b[i-1]) + arr_happiness_c[i]\n\n\n\nans = max(dp_a[vacation-1], dp_b[vacation-1], dp_c[vacation-1])\n\nprint(ans)", "output": "A", "improve_diff": 9.1694045399, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\nn, k = list(map(int,input().split()))\n\nh = [int(i) for i in input().split()]\n\n\"\"\"\n\nif k >= n:\n\n    ans = 0\n\nelse:\n\n    h.sort()\n\n    tmp = 0\n\n    for i in range(n-k, n):\n\n        tmp += h[i]\n\n    ans = (sum(h) - tmp)\n\nprint(ans)\n\n\"\"\"\n\n\n\nif k >= n:\n\n    ans = 0\n\nelse:\n\n    h.sort()\n\n    ans = 0\n\n    for i in range(n - k):\n\n        ans += h[i]\n\nprint(ans)\n \nB. # -*- coding: utf-8 -*-\n\nn, k = list(map(int,input().split()))\n\nh = [int(i) for i in input().split()]\n\n\n\nif k >= n:\n\n    ans = 0\n\nelse:\n\n    h.sort()\n\n    tmp = 0\n\n    for i in range(n-k, n):\n\n        tmp += h[i]\n\n    ans = (sum(h) - tmp)\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0302632649, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nR, G, B, N = rl()\n\nanswer = 0\n\nfor r in range(N//R + 1):\n\n    sum = r * R\n\n    for g in range((N-sum)//G + 1):\n\n        sum2 = sum + g * G\n\n        if (N-sum2)%B == 0:\n\n            answer += 1\n\n\n\nprint(answer)\n\n#45\n \nB. import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nR, G, B, N = rl()\n\nUP = 3000\n\nA = np.zeros(UP+1, dtype=np.int32)\n\n\n\nfor r in range(UP+1):\n\n    if r * R > UP:\n\n        break\n\n    A[r*R::G] += 1\n\n\n\nanswer = A[N::-B].sum()\n\nprint(answer)\n\n#08\n", "output": "A", "improve_diff": 3.4559896167, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n\n\nK = int(eval(input()))\n\nans = 0\n\nfor a in range(1, K+1):\n\n    for b in range(1, K + 1):\n\n        ab_gcd = math.gcd(a, b)\n\n        for c in range(1, K + 1):\n\n            ans += math.gcd(ab_gcd, c)\n\nprint(ans)\n \nB. k = int(eval(input()))\n\n\n\nsum = 0\n\n\n\ndef gcd(a, b):\n\n    if b == 0:\n\n        return a\n\n    \n\n    return gcd(b, a % b)\n\n\n\n\n\nfor a in range(1, k + 1):\n\n    for b in range(1, k + 1):\n\n        ab_gcd = gcd(a, b)\n\n        for c in range(1, k + 1):\n\n            abc_gcd = gcd(c, ab_gcd)\n\n            sum += abc_gcd\n\n        \n\nprint(sum)\n", "output": "B", "improve_diff": 1.2527920722, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\na=set(int(eval(input())) for i in range(n))\n\nprint((len(a))) \nB. N=int(eval(input()))\n\nA=[]\n\nfor i in range(N):\n\n   A.append(eval(input())) \n\nA=list(set(A))\n\nprint((len(A)))", "output": "B", "improve_diff": 1.0239456563, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nh,n = list(map(int,input().split()))\n\n\n\n\n\na = [0 for _ in range(n)]\n\nb = [0 for _ in range(n)]\n\nfor i in range(n):\n\n    a[i], b[i] = list(map(int,input().split()))\n\n\n\ndp = []\n\nfor i in range(h + max(a)):\n\n    dp.append(pow(2, 31) - 1)\n\ndp[0] = 0\n\n\n\nfor i in range(1, len(dp)):\n\n    '''\n\n    tmp = dp[i]\n\n    for j in range(n):\n\n        tmp = min(tmp, dp[max(0, i-a[j])] + b[j])\n\n    dp[i] = tmp\n\n    '''\n\n    dp[i] = min(dp[i - A] + B for A, B in zip(a, b))\n\n\n\nprint((min(dp[h:]))) \nB. import sys\n\ninf = sys.maxsize\n\n\n\nh,n = list(map(int,input().split()))\n\na = [0 for _ in range(n)]\n\nb = [0 for _ in range(n)]\n\nfor i in range(n):\n\n    a[i], b[i] = list(map(int,input().split()))\n\n\n\ndp = [inf for _ in range(h + max([a[i] for i in range(n)]) + 10)] #dp[i]\n\ndp[0] = 0\n\n\n\nfor i in range(1, len(dp)):\n\n    for j in range(n):\n\n        dp[i] = min(dp[i], dp[max(0, i-a[j])] + b[j])\n\n\n\n#print(dp)\n\nprint((min(dp[h:])))", "output": "A", "improve_diff": 1.2791684319, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nimport sys\n\ndef sieve(n):\n\n    if n < 2:\n\n        is_prime = [False for _ in range(n+1)]\n\n        return is_prime\n\n \n\n    is_prime = [True for _ in range(n+1)]\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n \n\n    for i in range(2, int(n**0.5)+1):\n\n        if is_prime[i]:\n\n            for j in range(i*2, n+1, i):\n\n                is_prime[j] = False\n\n \n\n    return is_prime\n\n\n\ndef main():\n\n\tN=10**5\n\n\tprime=sieve(N)\n\n\ta=[0 for i in range(N+1)]\n\n\tfor i in range(3,N+1):\n\n\t\tif prime[i] and prime[(i+1)//2]: a[i]=a[i-1]+1\n\n\t\telse: a[i]=a[i-1]\n\n\n\n\tQ=int(eval(input()))\n\n\tfor i in range(Q):\n\n\t\tl,r=list(map(int,input().split()))\n\n\t\tprint((a[r]-a[l-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. import math\n\nimport sys\n\ndef sieve(n):\n\n    if n < 2:\n\n        is_prime = [False for _ in range(n+1)]\n\n        return is_prime\n\n \n\n    is_prime = [True for _ in range(n+1)]\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n \n\n    for i in range(2, int(n**0.5)+1):\n\n        if is_prime[i]:\n\n            for j in range(i*2, n+1, i):\n\n                is_prime[j] = False\n\n \n\n    return is_prime\n\n\n\ninput = sys.stdin.readline\n\nN=10**5\n\nprime=sieve(N)\n\na=[0 for i in range(N+1)]\n\nfor i in range(3,N+1):\n\n\tif prime[i] and prime[(i+1)//2]: a[i]=a[i-1]+1\n\n\telse: a[i]=a[i-1]\n\n\n\nfor i in range(int(eval(input()))):\n\n\tl,r=list(map(int,input().split()))\n\n\tprint((a[r]-a[l-1]))", "output": "A", "improve_diff": 1.2926750347, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\nN,W = LI()\n\nwv = [LI() for _ in range(N)]\n\ndp = [[0]*(W+1) for _ in range(N+1)] #1_indexed\n\nfor i in range(1,N+1):\n\n    w,v = wv[i-1]\n\n    for j in range(W+1):\n\n        if j-w>=0:\n\n            dp[i][j] = max(dp[i][j],dp[i-1][j-w]+v)\n\n        dp[i][j] = max(dp[i][j],dp[i-1][j])\n\nprint((dp[-1][-1]))\n \nB. import collections,itertools,sys\n\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\nN,W = LI()\n\nwv = [LI() for _ in range(N)]\n\ndp = [[0]*(W+1) for _ in range(N+1)] #1_indexed\n\nfor i,j in itertools.product(list(range(1,N+1)),list(range(W+1))):\n\n    w,v = wv[i-1]\n\n    if j-w>=0:\n\n        dp[i][j] = max(dp[i][j],dp[i-1][j-w]+v)\n\n    dp[i][j] = max(dp[i][j],dp[i-1][j])\n\nprint((dp[-1][-1]))\n", "output": "A", "improve_diff": 1.48051649, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from collections import Counter\n\n    import sys\n\n\n\n    eval(input())\n\n    a = list(map(int, sys.stdin.readline().split()))\n\n\n\n    d = Counter(a)\n\n\n\n    base = sum(v * (v - 1) // 2 for v in list(d.values()))\n\n    e = [str(base - (d[v] - 1)) for v in a]\n\n    print(('\\n'.join(e)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n\n\n    from collections import Counter\n\n    import sys\n\n\n\n    n = int(eval(input()))\n\n    a = list(map(int, sys.stdin.readline().split()))\n\n\n\n    d = Counter(a)\n\n\n\n    base = sum(v * (v - 1) // 2 for v in list(d.values()))\n\n    e = {k: base - (v >= 2) * (v - 1) for k, v in list(d.items())}\n\n    for i in a:\n\n        print((e[i]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0303643075, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\nN, M = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\nprime = defaultdict(int)\n\n\n\nfor i in range(2, M + 1):\n\n    if i * i > M:\n\n        break\n\n        \n\n    while M % i == 0:\n\n        prime[i] += 1\n\n        M //= i\n\n        \n\nif M != 1:\n\n    prime[M] = 1\n\n    \n\ndef comb(n, k):\n\n    ret = 1\n\n    for i in range(1, k + 1):\n\n        ret = ret * (n - i + 1) % MOD\n\n        ret = ret * pow(i, MOD - 2, MOD) % MOD\n\n        \n\n    return ret\n\n\n\nans = 1\n\nfor v in list(prime.values()):\n\n    ans = ans * comb(N + v - 1, N - 1) % MOD\n\n    \n\nprint(ans)\n \nB. \n\nfrom collections import defaultdict\n\n\n\n\n\ndef prime_factor(n):\n\n    # O(sqrt(N))\n\n    d = defaultdict(int)\n\n    for i in range(2, n + 1):\n\n        if i * i > n:\n\n            break\n\n\n\n        while n % i == 0:\n\n            d[i] += 1\n\n            n //= i\n\n\n\n    if n != 1:\n\n        d[n] += 1\n\n\n\n    return d\n\n\n\n\n\nMAX = 2 * 10 ** 5 + 10\n\nMOD = 10 ** 9 + 7\n\n\n\n# Factorial\n\nfac = [0] * (MAX + 1)\n\nfac[0] = 1\n\nfac[1] = 1\n\n\n\n# Inverse\n\ninv = [0] * (MAX + 1)\n\ninv[1] = 1\n\n\n\n# Inverse factorial\n\nfinv = [0] * (MAX + 1)\n\nfinv[0] = 1\n\nfinv[1] = 1\n\n\n\nfor i in range(2, MAX + 1):\n\n    fac[i] = fac[i - 1] * i % MOD\n\n    inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\n    finv[i] = finv[i - 1] * inv[i] % MOD\n\n\n\n\n\ndef comb(n, k):\n\n    if n < k or k < 0:\n\n        return 0\n\n    return (fac[n] * finv[k] * finv[n - k]) % MOD\n\n\n\n\n\ndef comb_rep(n, k):\n\n    return comb(n + k - 1, n - 1)\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nprimes = prime_factor(M)\n\nres = 1\n\nfor k in list(primes.values()):\n\n    res *= comb_rep(N, k)\n\n    res %= MOD\n\n\n\nprint(res)\n", "output": "A", "improve_diff": 1.6163158205, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, x = list(map(int,input().split()))\n\nli = list(input().split())\n\nli = [abs(int(a)-x) for a in li]\n\n\n\ndef gcd(a,b):\n\n    while a%b!=0:\n\n        a,b = b,a%b\n\n    return b\n\n    \n\nif n == 1:\n\n    print((abs(li[0])))\n\n    \n\nelif n == 2:\n\n    print((gcd(li[0],li[1])))\n\n    \n\nelif n >= 3:\n\n\n\n    c = gcd(li[0],li[1])\n\n    #print(c)\n\n    for i in range(2,len(li)-1):\n\n        c = gcd(c,li[i])\n\n    print(c) \nB. n, x = list(map(int,input().split()))\n\nli = list(input().split())\n\nli = [abs(int(a)-x) for a in li]\n\n\n\ndef gcd(a,b):\n\n    while a%b!=0:\n\n        a,b = b,a%b\n\n    return b\n\n    \n\nfrom functools import reduce\n\n\n\na = reduce(gcd,li)\n\nprint(a)", "output": "A", "improve_diff": 1.4582183742, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\n\nA = [0]*M\n\nB = [0]*M\n\nC = [0]*M\n\nfor i in range(M):\n\n    A[i], B[i] = list(map(int, input().split()))\n\n    for c in [int(i) for i in input().split()]:\n\n        C[i] |= 1 << (c - 1)\n\n\n\ndp = [[float(\"inf\")] * 2 ** N for _ in range(2)]\n\ndp[0][0] = 0\n\nfor i, c in enumerate(C):\n\n    for bit in range(2 ** N):\n\n        if c & bit == bit:\n\n            dp[1][bit] = min(dp[1][bit], dp[0][bit], A[i])\n\n        else:\n\n            dp[1][bit] = min(dp[1][bit], dp[0][bit])\n\n        dp[1][c | bit] = min(dp[0][c | bit], dp[0][bit] + A[i], dp[1][c | bit])\n\n    dp[0], dp[1] = dp[1], dp[0]\n\nprint((dp[0][-1] if dp[0][-1] < float(\"inf\") else - 1)) \nB. import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\n\nA = [0]*M\n\nB = [0]*M\n\nC = [0]*M\n\nfor i in range(M):\n\n    A[i], B[i] = list(map(int, input().split()))\n\n    for c in [int(i) for i in input().split()]:\n\n        C[i] |= 1 << (c - 1)\n\n\n\ndp = [[float(\"inf\")] * 2 ** N for _ in range(2)]\n\ndp[0][0] = 0\n\nfor i, c in enumerate(C):\n\n    for bit in range(2 ** N):\n\n        dp[1][bit] = min(dp[1][bit], dp[0][bit])\n\n        dp[1][c | bit] = min(dp[0][bit] + A[i], dp[1][c | bit])\n\n    dp[0], dp[1] = dp[1], dp[0]\n\nprint((dp[0][-1] if dp[0][-1] < float(\"inf\") else - 1))", "output": "B", "improve_diff": 1.1013500607, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n =int(eval(input()))\n\na =int(eval(input()))\n\nprint(('Yes' if n %500<=a else 'No')) \nB. n = int(eval(input()))\n\na = int(eval(input()))\n\n\n\nq = n % 500\n\n\n\nif a >= q:\n\n  print('Yes')\n\nelse:\n\n  print('No')", "output": "B", "improve_diff": 1.0236712764, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nN,Q=list(map(int,input().split()))\n\nans=[0]*N\n\nki=[[] for _ in range(N)]\n\nfor i in range(N-1):\n\n a,b=list(map(int,input().split()))\n\n ki[a-1].append(b-1)\n\n ki[b-1].append(a-1)\n\nfor i in range(Q):\n\n p,q=list(map(int,input().split()))\n\n ans[p-1]+=q\n\n# dfs\n\nstack = [0]\n\nvisited = [\"False\"] * N\n\nwhile stack:\n\n ne = stack.pop()\n\n if visited[ne] == \"False\":\n\n  visited[ne] = \"True\"\n\n  for j in ki[ne]:\n\n   if visited[j] == \"False\":\n\n    ans[j]+=ans[ne]\n\n    stack.append(j)\n\nL=[str(a) for a in ans]\n\nL=' '.join(L)\n\nprint(L) \nB. N,Q=list(map(int,input().split()))\n\nans=[0]*N\n\nki=[[] for _ in range(N)]\n\nfor i in range(N-1):\n\n a,b=list(map(int,input().split()))\n\n ki[a-1].append(b-1)\n\n ki[b-1].append(a-1)\n\nfor i in range(Q):\n\n p,q=list(map(int,input().split()))\n\n ans[p-1]+=q\n\n# dfs\n\nstack = [0]\n\nvisited = [\"False\"] * N\n\nwhile stack:\n\n ne = stack.pop()\n\n if visited[ne] == \"False\":\n\n  visited[ne] = \"True\"\n\n  for j in ki[ne]:\n\n   if visited[j] == \"False\":\n\n    ans[j]+=ans[ne]\n\n    stack.append(j)\n\nL=[str(a) for a in ans]\n\nL=' '.join(L)\n\nprint(L)", "output": "B", "improve_diff": 1.0438878439, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn,m=list(map(int,input().split()))\n\nx=list(map(int,input().split()))\n\n\n\narr=np.sort(np.array(x))\n\ndif=np.diff(arr)\n\n\n\nlis=dif.tolist()\n\nlis=sorted(lis)\n\n\n\nfor i in range(n-1):\n\n    if len(lis)>0:\n\n        lis.pop()\n\n\n\nprint((sum(lis))) \nB. import numpy as np\n\nn,m=list(map(int,input().split()))\n\nx=list(map(int,input().split()))\n\n\n\narr=np.array(sorted(x))\n\ndif=np.diff(arr)\n\n\n\nlis=dif.tolist()\n\nlis=sorted(lis)\n\n\n\nfor i in range(n-1):\n\n    if len(lis)>0:\n\n        lis.pop()\n\n\n\nprint((sum(lis)))", "output": "B", "improve_diff": 1.0325241843, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict, Counter\n\nfrom itertools import product, groupby, count, permutations, combinations\n\nfrom math import pi, sqrt\n\nfrom collections import deque\n\nfrom bisect import bisect, bisect_left, bisect_right\n\nfrom string import ascii_lowercase\n\nfrom functools import lru_cache\n\nimport sys\n\nsys.setrecursionlimit(10000)\n\nINF = float(\"inf\")\n\nYES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"\n\ndy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]\n\n\n\n\n\ndef inside(y, x, H, W):\n\n    return 0 <= y < H and 0 <= x < W\n\n\n\n\n\ndef ceil(a, b):\n\n    return (a + b - 1) // b\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    i = 1\n\n    while i * i <= N:\n\n        i += 1\n\n    print(((i - 1) * (i - 1)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. from collections import defaultdict, Counter\n\nfrom itertools import product, groupby, count, permutations, combinations\n\nfrom math import pi, sqrt\n\nfrom collections import deque\n\nfrom bisect import bisect, bisect_left, bisect_right\n\nINF = float(\"inf\")\n\n \n\n \n\ndef main():\n\n    N = int(eval(input()))\n\n    ans = 0\n\n    for i in range(10**9):\n\n        if i * i <= N:\n\n            ans = max(ans, i * i)\n\n        else:\n\n            break\n\n    print(ans)\n\n \n\n \n\nif __name__ == '__main__':\n\n    main()", "output": "B", "improve_diff": 1.2736053586, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b,x = list(map(int,input().split()))\n\ncnt2 = b//x\n\ncnt1 = (a-1)//x\n\nprint((cnt2-cnt1)) \nB. a,b,x = list(map(int,input().split()))\n\nprint((b//x-(a-1)//x))", "output": "A", "improve_diff": 1.0206399663, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, k, q, *a = list(map(int, open(0).read().split()))\n\nout = [k-q for _ in range(n)]\n\nfor i in range(q):\n\n    out[a[i]-1] += 1\n\nfor i in out:\n\n    msg = \"Yes\" if i > 0 else \"No\"\n\n    print(msg) \nB. n, k, q = list(map(int, input().split()))\n\nout = [k-q for _ in range(n)]\n\nfor _ in range(q):\n\n    a = int(eval(input()))-1\n\n    out[a] += 1\n\nfor i in range(n):\n\n    msg = \"Yes\" if out[i] > 0 else \"No\"\n\n    print(msg)", "output": "B", "improve_diff": 1.0487481431, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import Counter\n\n\n\ndef make_prime_checker(n):\n\n    # n  O(nloglogn)\n\n    is_prime = [False, True, False, False, False, True] * (n//6+1)\n\n    del is_prime[n+1:]\n\n    is_prime[1:4] = False, True, True\n\n    for i in range(5, int(n**0.5)+1):\n\n        if is_prime[i]:\n\n            is_prime[i*i::i] = [False] * (n//i-i+1)\n\n    return is_prime\n\n\n\ndef main():\n\n    Primes = [p for p, is_p in enumerate(make_prime_checker(2200)) if is_p]\n\n    def decomp(n):\n\n        res1 = res2 = 1\n\n        for p in Primes:\n\n            cnt = 0\n\n            while n % p == 0:\n\n                n //= p\n\n                cnt += 1\n\n            cnt %= 3\n\n            if cnt == 1:\n\n                res1 *= p\n\n            elif cnt == 2:\n\n                res2 *= p\n\n        if int(n**0.5)**2 == n:\n\n            res2 *= int(n**0.5)\n\n        else:\n\n            res1 *= n\n\n        return res1 * res2 * res2, res1 * res1 * res2\n\n\n\n    N, *S = list(map(int, sys.stdin.buffer.read().split()))\n\n    T = []\n\n    inv_dict = {}\n\n    for s in S:\n\n        t, t_inv = decomp(s)\n\n        T.append(t)\n\n        inv_dict[t] = t_inv\n\n\n\n    counter_T = Counter(T)\n\n    ans = 0\n\n    for t, t_cnt in list(counter_T.items()):\n\n        if t == 1:\n\n            ans += 1\n\n            continue\n\n        t_inv = inv_dict[t]\n\n        t_inv_cnt = counter_T[t_inv]\n\n        if t_cnt > t_inv_cnt or (t_cnt == t_inv_cnt and t > t_inv):\n\n            ans += t_cnt\n\n    print(ans)\n\n\n\nmain()\n \nB. import sys\n\nfrom subprocess import Popen, PIPE\n\nfrom itertools import groupby\n\nfrom collections import Counter\n\n\n\ndef main():\n\n    sys.stdin.readline()\n\n    S = sys.stdin.read().split()\n\n    T = []\n\n    inv_dict = {}\n\n    Factors = Popen([\"factor\"] + S, stdout=PIPE).communicate()[0].split(b\"\\n\")\n\n    for factors in Factors[:-1]:\n\n        factors = list(map(int, factors.split()[1:]))\n\n        t = 1\n\n        t_inv = 1\n\n        for f, group in groupby(factors):\n\n            n = len(list(group)) % 3\n\n            if n == 1:\n\n                t *= f\n\n            elif n == 2:\n\n                t_inv *= f\n\n        t, t_inv = t * t_inv * t_inv, t * t * t_inv\n\n        T.append(t)\n\n        inv_dict[t] = t_inv\n\n\n\n    counter_T = Counter(T)\n\n    ans = 0\n\n    for t, t_cnt in list(counter_T.items()):\n\n        if t == 1:\n\n            ans += 1\n\n            continue\n\n        t_inv = inv_dict[t]\n\n        t_inv_cnt = counter_T[t_inv]\n\n        if t_cnt > t_inv_cnt or (t_cnt == t_inv_cnt and t > t_inv):\n\n            ans += t_cnt\n\n    print(ans)\n\n\n\nmain()\n", "output": "A", "improve_diff": 1.8838327968, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n\n\nN, A, B = list(map(int, input().split()))\n\nH = [int(eval(input())) for i in range(N)]\n\n\n\nadd_damage = A-B\n\nleft = 1\n\nright = 10**9\n\nans = float('inf')\n\n\n\nfor i in range(int(math.log(10**9, 2)+1)):\n\n    T = (left+right) // 2\n\n    h = H.copy()\n\n    h = list([max(0, x-T*B) for x in h])\n\n    h = list([math.ceil(x / add_damage) for x in h])\n\n    need = sum(h)\n\n    \n\n    if need <= T:\n\n        right = T\n\n        ans = min(ans, T)\n\n    else:\n\n        left = T\n\n\n\nprint((int(ans))) \nB. import math\n\n\n\nN, A, B = list(map(int, input().split()))\n\nH = [int(eval(input())) for i in range(N)]\n\n\n\nadd_damage = A-B\n\nleft = 1\n\nright = 10**9\n\nans = float('inf')\n\n\n\nfor i in range(int(math.log(10**9, 2)+1)):\n\n    T = (left+right) // 2\n\n    h = H.copy()\n\n    h = list([math.ceil(max(0, x-T*B) / add_damage) for x in h])\n\n    need = sum(h)\n\n    \n\n    if need <= T:\n\n        right = T\n\n        ans = min(ans, T)\n\n    else:\n\n        left = T\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.0246310709, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n\n\nN,D =[int(x) for x in input().split()]\n\n\n\nX = []\n\nY = []\n\n\n\nfor i in range(N):\n\n    x,y = [int(x) for x in input().split()]\n\n    X.append(x)\n\n    Y.append(y)\n\n\n\nans = 0\n\n\n\nfor i in range(N):\n\n    r = math.sqrt(X[i] ** 2 + Y[i] ** 2)\n\n    if r <= D:\n\n        ans += 1\n\n\n\nprint(ans) \nB. N,D =[int(x) for x in input().split()]\n\n\n\nans = 0\n\n\n\nfor i in range(N):\n\n    x,y = [int(x) for x in input().split()]\n\n    if x * x + y * y <= D * D:\n\n        ans += 1\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.3086909981, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import gcd\n\n\n\n\n\ndef main():\n\n    eval(input())  # N\n\n    array = [int(x) for x in input().split()]\n\n    MAX_A = 10 ** 6 + 2\n\n    histgram = [0] * MAX_A\n\n    for x in array:\n\n        histgram[int(x)] += 1\n\n    pairwise = True\n\n    for divider in range(2, MAX_A):\n\n        count = 0\n\n        for counted in histgram[divider::divider]:\n\n            count += counted\n\n        if count > 1:\n\n            pairwise = False\n\n    if pairwise:\n\n        return 'pairwise coprime'\n\n    gcd_now = 0\n\n    for x in array:\n\n        gcd_now = gcd(x, gcd_now)\n\n    if gcd_now == 1:\n\n        return 'setwise coprime'\n\n    else:\n\n        return 'not coprime'\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n \nB. from math import gcd\n\n\n\n\n\ndef main():\n\n    eval(input())  # N\n\n    array = [int(x) for x in input().split()]\n\n    MAX_A = 10 ** 6 + 1\n\n    histogram = [0] * MAX_A\n\n    for x in array:\n\n        histogram[int(x)] += 1\n\n    for divider in range(2, MAX_A):\n\n        count = 0\n\n        for counted in histogram[divider::divider]:\n\n            count += counted\n\n        if count > 1:\n\n            break\n\n    else:\n\n        return 'pairwise coprime'\n\n    gcd_now = 0\n\n    for x in array:\n\n        gcd_now = gcd(x, gcd_now)\n\n    if gcd_now == 1:\n\n        return 'setwise coprime'\n\n    else:\n\n        return 'not coprime'\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n", "output": "B", "improve_diff": 1.7898299236, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nk,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na=[[a[i],i] for i in range(n)]\n\n\n\nif n==1: print((a[0][0]-1));sys.exit()\n\n\n\npre=-1\n\nans=0\n\nfor _ in range(k):\n\n    a.sort(reverse=True)\n\n    if a[0][1]!=pre:\n\n        a[0][0]-=1\n\n        pre=a[0][1]\n\n    elif a[1][0]>0:\n\n        a[1][0]-=1\n\n        pre=a[1][1]\n\n    else:\n\n        ans=a[0][0]\n\n        break\n\nprint(ans) \nB. import sys\n\n\n\nk,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\nif n==1: print((a[0]-1));sys.exit()\n\n\n\na.sort(reverse=True)\n\nans=max(0,a[0]-1-sum(a[1:]))\n\nprint(ans)", "output": "B", "improve_diff": 1.050867966, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ns=int(eval(input()))\n\ndp=[0]*1000001\n\ndp[s]=1\n\ncnt=1\n\nfor i in range(1000001):\n\n  if s%2==1:\n\n    s=3*s+1\n\n  else:\n\n    s//=2\n\n  cnt+=1\n\n  if dp[s]==1:\n\n    print(cnt)\n\n    sys.exit()\n\n  else:\n\n    dp[s]=1 \nB. a = [0]*1000000\n\na[0] = int(eval(input()))\n\n\n\nfor i in range(1,1000000):\n\n  if a[i-1]%2 == 0:\n\n    if a[i-1]/2 in a:\n\n      print((i+1))\n\n      break\n\n    a[i] = a[i-1]/2\n\n  else:\n\n    if 3*a[i-1]+1 in a:\n\n      print((i+1))\n\n      break\n\n    a[i] = 3*a[i-1]+1\n", "output": "A", "improve_diff": 27.2268830801, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque\n\nfrom heapq import heapify, heappop, heappush\n\nfrom itertools import combinations, permutations\n\nfrom bisect import bisect, bisect_left\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    strN = str(N)\n\n    maxDig = len(strN)\n\n    count = 0\n\n    for i in range(1, N + 1):\n\n        a = str(i)\n\n        low = int(a[-1])\n\n        if low == 0: continue\n\n        high = int(a[0])\n\n        if low == high: count += 1 #\n\n        digb = 2\n\n        while digb < maxDig:\n\n            count += 10 ** (digb - 2)\n\n            digb += 1\n\n        if N >= 10:\n\n            if low > int(strN[0]): continue\n\n            elif low < int(strN[0]): count += 10 ** (digb - 2)\n\n            elif N >= 10:\n\n                DP = [[0, 0] for _ in range(maxDig)]\n\n                DP[0][0] = 1\n\n                for j in range(1, maxDig - 1):\n\n                    DP[j][0] = 1\n\n                    DP[j][1] = DP[j-1][1] * 10 + DP[j-1][0] * (int(strN[j]))\n\n\n\n                count += DP[maxDig - 2][1] \n\n                #print(i, DP)\n\n                if int(strN[maxDig - 1]) >= high: count += 1\n\n\n\n    print(count)\n\n        \n\n        \n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. import sys\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    D = dict()\n\n    for i in range(1, N + 1):\n\n        front = i % 10\n\n        back = i\n\n        while back >= 10: back //= 10\n\n        if front > 0:\n\n            if (front, back) in D: D[(front, back)] += 1\n\n            else: D[(front, back)] = 1\n\n    Ans = 0\n\n    for i in range(1, N + 1):\n\n        back = i % 10\n\n        if back > 0:\n\n            front = i\n\n            while front >= 10: front //= 10\n\n            if (front, back) in D: Ans += D[(front, back)]\n\n    print(Ans)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()", "output": "B", "improve_diff": 1.3776028708, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\"\"\"\n\ndp[i][j] -> ij\n\n\n\n\"\"\"\n\nHP = [list(map(int,input().split())) for _ in range(N)]\n\nHP.sort(key=lambda x:x[0]+x[1])\n\ndp = [float(\"INF\")]*(N+1)\n\ndp[0] = 0\n\nfor i in range(1,N+1):\n\n    for j in range(N,0,-1):\n\n        if dp[j-1] <= HP[i-1][0]:\n\n            dp[j] = min(dp[j],dp[j-1]+HP[i-1][1])\n\nfor j in range(N,-1,-1):\n\n    if dp[j] != float(\"INF\"):\n\n        print(j)\n\n        break\n \nB. \"\"\"\n\nA\uff1aHa , Pa\n\nB\uff1aHb , Pb\n\n\n\nA\uff1fB\uff1f\n\nABSS <= min(Hb,Ha)\n\n\n\nS+Pa > Hb S+Pb <= HaB\n\nS+Pb > Ha S+Pa <= HbA\n\n\n\nPa-Hb > Pb-Ha BA\n\nPa+Ha > Pb+HbBA\n\nP+H\n\n\"\"\"\n\n\n\n\n\nN = int(eval(input()))\n\nHP = [list(map(int,input().split())) for _ in range(N)]\n\nHP.sort(key = lambda x:x[0]+x[1])\n\n#dp[i][j] -> j\n\ndp = [float(\"INF\")]*(N+1)\n\ndp[0] = 0\n\nfor h,p in HP:\n\n    for j in range(N,0,-1):\n\n        if dp[j-1] <= h:\n\n            dp[j] = min(dp[j],dp[j-1]+p)\n\n\n\nfor j in range(N,-1,-1):\n\n    if dp[j] != float(\"INF\"):\n\n        print(j)\n\n        break", "output": "A", "improve_diff": 1.0207863696, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. q=int(eval(input()))\n\nlr=[tuple(map(int,input().split())) for _ in range(q)]\n\n\n\nn=10**5\n\nansl=[]\n\nsieve=[1]*(n+1)\n\nsieve[0],sieve[1]=0,0\n\nfor i in range(2,n):\n\n  if sieve[i]:\n\n    for j in range(2*i,n+1,i):\n\n      sieve[j]=0\n\nans=[0]*(n+1)\n\nfor i in range(3,n):\n\n  if sieve[i]==1 and sieve[(i+1)//2]==1:\n\n    ans[i]=ans[i-1]+1\n\n  else:\n\n    ans[i]=ans[i-1]\n\n\n\nfor e in lr:\n\n  print((ans[e[1]]-ans[e[0]-1]))\n \nB. from math import gcd\n\nfrom collections import deque\n\nfrom bisect import bisect_left,bisect_right\n\n\n\nq=int(eval(input()))\n\nlr=[tuple(map(int,input().split())) for _ in range(q)]\n\n\n\nrmax=max(e[1] for e in lr)\n\nanslst=[]\n\ncandlst=deque([2])\n\npprod=2\n\nfor i in range(3,rmax+1,2):\n\n  tmp=2*candlst[0]-1\n\n  if gcd(pprod,i)==1: \n\n    candlst.append(i)\n\n    pprod*=i\n\n    if tmp==i:\n\n      anslst.append(tmp)\n\n  if tmp==i:\n\n    candlst.popleft()\n\n\n\nfor e in lr:\n\n  print((bisect_right(anslst,e[1])-bisect_left(anslst,e[0])))", "output": "B", "improve_diff": 2.4826155413, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, x, t = list(map(int, input().split()))\n\nm = n//x\n\nif n%x==0:\n\n  print((m*t))\n\nelse:\n\n  print((m*t+t)) \nB. n, x, t = list(map(int, input().split()))\n\nif n%x==0:\n\n  print((n//x*t))\n\nelse:\n\n  print((n//x*t + t))", "output": "A", "improve_diff": 1.0327719387, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from heapq import heappop, heappush, heapify\n\nK = int(eval(input()))\n\nM = K\n\n\n\nque = list(range(1, 10))\n\nV = set()\n\nheapify(que)\n\n\n\nwhile M + 100 >= 0:\n\n    top = heappop(que)\n\n    if top in V:\n\n        continue\n\n    V.add(top)\n\n    M -= 1\n\n\n\n    top = str(top)\n\n    L = int(top[0])\n\n    R = int(top[-1])\n\n\n\n    for i in (L - 1, L, L + 1):\n\n        if 1 <= i <= 9:\n\n            heappush(que, int(str(i) + top))\n\n    for i in (R - 1, R, R + 1):\n\n        if 0 <= i <= 9:\n\n            heappush(que, int(top + str(i)))\n\n\n\nV = [int(d) for d in V]\n\nV.sort()\n\nprint((V[K - 1]))\n \nB. from collections import deque\n\nK = int(eval(input()))\n\n\n\nque = deque(list(map(str, list(range(1, 10)))))\n\nwhile K > 1:\n\n    n = que.popleft()\n\n    K -= 1\n\n    R = int(n[-1])\n\n    for r in (R - 1, R, R + 1):\n\n        if 0 <= r <= 9:\n\n            que.append(n + str(r))\n\n\n\nprint((que[0]))\n", "output": "B", "improve_diff": 2.8119940514, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn, m, q = list(map(int, input().split()))\n\ncnt = [[0]*(n+1)for _ in range(n+1)]\n\nfor _ in range(m):\n\n    L, R = list(map(int, input().split()))\n\n    cnt[L][R] += 1\n\n\n\nS = np.cumsum(cnt, axis=0).cumsum(axis=1)\n\n\n\nfor _ in range(q):\n\n    L, R = list(map(int, input().split()))\n\n    ans = S[R][R]-S[R][L-1]-S[L-1][R]+S[L-1][L-1]\n\n    print(ans)\n \nB. import numpy as np\n\nn, m, q = list(map(int, input().split()))\n\ncnt = [[0]*(n+1)for _ in range(n+1)]\n\nfor _ in range(m):\n\n    L, R = list(map(int, input().split()))\n\n    cnt[L][R] += 1\n\n\n\nS = np.cumsum(cnt, axis=0).cumsum(axis=1).tolist()\n\n\n\nfor _ in range(q):\n\n    L, R = list(map(int, input().split()))\n\n    ans = S[R][R]-S[R][L-1]-S[L-1][R]+S[L-1][L-1]\n\n    print(ans)", "output": "B", "improve_diff": 1.0547193283, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nimport itertools\n\n\n\nn=int(eval(input()))\n\nd=[list(map(int,input().split())) for _ in range(n)]\n\n\n\nans=cnt=0\n\nfor i in itertools.permutations([_ for _ in range(n)]):\n\n  for j in range(n-1):\n\n    x1,x2=d[i[j]][0],d[i[j+1]][0]\n\n    y1,y2=d[i[j]][1],d[i[j+1]][1]\n\n    ans+=math.sqrt((x1-x2)**2+(y1-y2)**2)\n\n  cnt+=1\n\n  #print(j,ans,cnt)\n\nprint((ans/cnt)) \nB. n=int(eval(input()))\n\nd=[list(map(int,input().split())) for _ in range(n)]\n\n\n\nans=cnt=0\n\nfor i in range(n):\n\n  for j in range(i+1,n):\n\n    ans+=((d[i][0]-d[j][0])**2+(d[i][1]-d[j][1])**2)**0.5\n\nprint((2*ans/n))", "output": "B", "improve_diff": 1.2606008266, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. mod = 1000000007\n\neps = 10**-9\n\n\n\n\n\ndef main():\n\n    import sys\n\n    from collections import deque\n\n    input = sys.stdin.buffer.readline\n\n\n\n    N = int(eval(input()))\n\n    adj = [[] for _ in range(N+1)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        adj[a].append((b, c))\n\n        adj[b].append((a, c))\n\n    Q, root = list(map(int, input().split()))\n\n\n\n    que = deque()\n\n    que.append(root)\n\n    seen = [-1] * (N+1)\n\n    seen[root] = 0\n\n    par = [0] * (N+1)\n\n    child = [[] for _ in range(N+1)]\n\n    seq = []\n\n    while que:\n\n        v = que.popleft()\n\n        seq.append(v)\n\n        for u, c in adj[v]:\n\n            if seen[u] == -1:\n\n                seen[u] = seen[v] + c\n\n                par[u] = v\n\n                child[v].append(u)\n\n                que.append(u)\n\n    seq.reverse()\n\n\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        print((seen[x] + seen[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nfrom collections import deque\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    Edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        Edge[a-1].append((b-1, c))\n\n        Edge[b-1].append((a-1, c))\n\n    Q, K = list(map(int, input().split()))\n\n    q = deque()\n\n    Dist = [-1] * N\n\n    q.append((K-1, K-1, 0))\n\n    while q:\n\n        nowN, preN, nD = q.popleft()\n\n        if Dist[nowN] == -1:\n\n            Dist[nowN] = nD\n\n            for e, add in Edge[nowN]:\n\n                if e != preN: q.append((e, nowN, nD + add))\n\n    Ans = [None] * Q\n\n    for i in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        Ans[i] = str(Dist[x-1] + Dist[y-1])\n\n    print((\"\\n\".join(Ans)))\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "output": "A", "improve_diff": 1.0175924917, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import reduce\n\n\n\nn, _, c = list(map(int, input().split()))\n\nbs = tuple(map(int, input().split()))\n\n\n\ncount = 0\n\nfor i in range(n):\n\n    if reduce(\n\n        lambda x, y: x + y[0] * y[1],\n\n        list(zip(bs, list(map(int, input().split())))),\n\n        0,\n\n    ) + c > 0:\n\n        count += 1\n\n\n\nprint(count)\n \nB. n, _, c = list(map(int, input().split()))\n\nbs = tuple(map(int, input().split()))\n\n\n\ncount = 0\n\nfor _ in range(n):\n\n    if sum(x * bs[i] for i, x in enumerate(map(int, input().split()))) + c > 0:\n\n        count += 1\n\n\n\nprint(count)\n", "output": "B", "improve_diff": 1.5689911987, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b,c=list(map(int,input().split()));print(('YNEOS'[b-a!=c-b::2])) \nB. a,b,c=list(map(int,input().split()));print((['NO','YES'][b-a==c-b]))", "output": "A", "improve_diff": 1.060556479, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M=list(map(int,input().split()))\n\nKS=[list(map(int,input().split())) for _ in range(M)]\n\np=list(map(int,input().split()))\n\nans=0\n\nfor i in range(1<<N):\n\n  judge=1\n\n  for j in range(M):\n\n    cnt=0\n\n    for k in KS[j][1:]:\n\n      if i>>(k-1)&1:\n\n        cnt+=1\n\n    if (cnt%2)!=p[j]:\n\n      judge=0\n\n  if judge==1:\n\n    ans+=1\n\nprint(ans) \nB. N,M=list(map(int,input().split()))\n\nS=[list(map(int,input().split())) for _ in range(M)]\n\nP=list(map(int,input().split()))\n\n\n\nans=0\n\nfor i in range(1<<N):\n\n  sw=[False]*M\n\n  for j in range(M):\n\n    cnt=0\n\n    for k in range(1,len(S[j])):\n\n      if (i>>(S[j][k]-1))&1:\n\n        cnt+=1\n\n      else:\n\n        flag=0\n\n    if cnt%2==P[j]:\n\n      sw[j]=True\n\n  if all(sw):\n\n    ans+=1\n\nprint(ans)", "output": "A", "improve_diff": 1.0156291984, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. while True:\n\n    n, x = list(map(int, input().split()))\n\n    if n == x == 0:\n\n        break\n\n    cnt = 0\n\n    upper_max_value = min(x - 3, n)\n\n    lower_max_value = max(int(x / 3), 3)\n\n    for i in range(upper_max_value, lower_max_value - 1, -1):\n\n        for j in range(i - 1, 1, -1):\n\n            for k in range(j - 1, 0, -1):\n\n                if (i + j + k) == x:\n\n                    cnt += 1\n\n    print(cnt) \nB. while True:\n\n    n, x = list(map(int, input().split()))\n\n    if n == x == 0:\n\n        break\n\n    max_a = min(x - 3, n)\n\n    min_a = max(x // 3 + 1, 3)\n\n    cnt = 0\n\n    for i in range(min_a, max_a + 1):\n\n        max_b = min(i - 1, x - i - 1)\n\n        min_b = (x - i) // 2 + 1\n\n        cnt += (max_b - min_b + 1)\n\n    print(cnt)", "output": "A", "improve_diff": 1.0664704892, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na.sort()\n\na.append(a[-1] + 1)\n\n\n\nb = [a[0]]\n\nc = [1]\n\nans = 0\n\nfor i in range(1, n+1):\n\n    if a[i] == b[-1]:\n\n        c[-1] += 1\n\n    else:\n\n        cand = c[-1]\n\n        if len(b) >= 2 and b[-2] == b[-1] - 1:\n\n            cand += c[-2]\n\n        if len(b) >= 3 and b[-3] == b[-1] - 2:\n\n            cand += c[-3]\n\n        ans = max(ans, cand)\n\n        b.append(a[i])\n\n        c.append(1)\n\n\n\nprint(ans)\n \nB. from collections import defaultdict\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nd = defaultdict(int)\n\nfor i in range(n):\n\n    d[a[i]] += 1\n\n\n\nans = 0\n\nfor x in d:\n\n    cand = d[x]\n\n    if x - 1 in d:\n\n        cand += d[x - 1]\n\n    if x + 1 in d:\n\n        cand += d[x + 1]\n\n    \n\n    ans = max(ans, cand)\n\n\n\nprint(ans)\n", "output": "A", "improve_diff": 1.5136218597, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import chain, accumulate\n\n\n\n\n\ndef prime_set(N):\n\n    \"\"\"\n\n    Nset\n\n    \"\"\"\n\n    if N < 4:\n\n        return ({}, {}, {2}, {2, 3})[N]\n\n    Nsq = int(N ** 0.5 + 0.5) + 1\n\n    primes = {2, 3} | set(chain(range(5, N + 1, 6), range(7, N + 1, 6)))\n\n    for i in range(5, Nsq, 2):\n\n        if i in primes:\n\n            primes -= set(range(i * i, N + 1, i * 2))\n\n    return primes\n\n\n\n\n\nU = 10 ** 5 + 10\n\nprimes = prime_set(U)\n\nmemo = [0] * U\n\nfor i in range(1, U, 2):\n\n    if i in primes and (i + 1) // 2 in primes:\n\n        memo[i] = 1\n\nmemo = list(accumulate(memo))\n\n\n\nQ = int(input())\n\nans = []\n\nfor _ in range(Q):\n\n    l, r = map(int, input().split())\n\n    ans.append(memo[r] - memo[l - 1])\n\nprint(*ans, sep=\"\\n\")\n \nB. def get_isPrime(n):         #1~n10\n\n    isprime=[1]*(n+1)\n\n    isprime[0]=0\n\n    isprime[1]=0\n\n    for i in range(2, int(n**0.5)+1):\n\n        if not isprime[i]:\n\n            continue\n\n        for j in range(i*2, n+1, i):\n\n            isprime[j]=0\n\n    return isprime\n\n\n\nmax_n=100000\n\nisprime=get_isPrime(max_n)\n\n\n\nruiseki=[]\n\nfor i in range(max_n+1):\n\n    if i==0 or i==1 or i==2:\n\n        ruiseki.append(0)\n\n    else:\n\n        if i%2==0:\n\n            ruiseki.append(ruiseki[i-1])\n\n        else:\n\n            if isprime[i] and isprime[int((i+1)/2)]:\n\n                ruiseki.append(ruiseki[i-1]+1)\n\n            else:\n\n                ruiseki.append(ruiseki[i-1])\n\n\n\nq=int(eval(input()))\n\nfor _ in range(q):\n\n    left, right=list(map(int,input().split()))\n\n    print((ruiseki[right]-ruiseki[left-1]))", "output": "A", "improve_diff": 1.3135135779, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC073D - joisino's travel\n\nfrom itertools import permutations\n\nfrom scipy.sparse.csgraph import dijkstra\n\n\n\n\n\ndef main():\n\n    N, M, R, *RABC = list(map(int, open(0).read().split()))\n\n    visit, ABC = RABC[:R], RABC[R:]\n\n    G = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n\n    for v, u, c in zip(*[iter(ABC)] * 3):\n\n        G[v][u] = G[u][v] = c\n\n    dist = [None] * (N + 1)\n\n    for i in range(1, N + 1):\n\n        dist[i] = dijkstra(G, directed=0, indices=i)\n\n    ans = float(\"inf\")\n\n    for perm in permutations(visit):\n\n        cur = sum(dist[v][u] for v, u in zip(perm, perm[1:]))\n\n        ans = min(ans, cur)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. # ABC073D - joisino's travel\n\nfrom heapq import heapify, heappop, heappush\n\nfrom itertools import permutations\n\n\n\n\n\ndef dijkstra(G: \"Array[Array[int]]\", size: int, start: int) -> list:\n\n    dist = [float(\"inf\")] * size\n\n    queue = [(start, 0)]\n\n    heapify(queue)\n\n    while queue:\n\n        v, cost = heappop(queue)\n\n        if cost > dist[v]:\n\n            continue\n\n        dist[v] = cost\n\n        for u, next_cost in G[v]:\n\n            if cost + next_cost < dist[u]:\n\n                heappush(queue, (u, cost + next_cost))\n\n    return dist\n\n\n\n\n\ndef main():\n\n    global G, N\n\n    N, M, R, *RABC = list(map(int, open(0).read().split()))\n\n    visit, ABC = RABC[:R], RABC[R:]\n\n    G = [[] for _ in range(N + 1)]\n\n    for v, u, c in zip(*[iter(ABC)] * 3):\n\n        G[v].append((u, c)), G[u].append((v, c))\n\n    dist = {v: dijkstra(G, N + 1, v) for v in visit}\n\n    ans = float(\"inf\")\n\n    for perm in permutations(visit):\n\n        cur = sum(dist[v][u] for v, u in zip(perm, perm[1:]))\n\n        ans = min(ans, cur)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 11.1464807675, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K = list(map(int, input().split()))\n\nD = list(map(int, input().split()))\n\n\n\nfor i in range(N, 10 * N + 1):\n\n  A = list(map(int, str(i)))\n\n  flag = 1\n\n  for a in A:\n\n    if a in D:\n\n      flag = 0\n\n      break\n\n  if flag:\n\n    print(i)\n\n    exit() \nB. N,K=list(map(int,input().split()))\n\nD=list(map(int,input().split()))\n\nC=[]\n\n\n\nfor i in range(0,10):\n\n  if i not in D:\n\n    C.append(i)\n\n#print(C)\n\n\n\nfor i in range(N,10**10):\n\n  cnt=0\n\n  for j in list(map(int,list(str(i)))):\n\n    if j in C:\n\n      cnt+=1\n\n  if len(str(i))==cnt:\n\n    print(i)\n\n    exit()", "output": "A", "improve_diff": 1.0269440279, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import factorial as f\n\nn, m = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nif abs(n - m) == 1:\n\n    res = f(n) * f(m)\n\n    print((res % mod))\n\nelif n == m:\n\n    res = f(n) * f(m) * 2\n\n    print((res % mod))\n\nelse:\n\n    print((0))\n \nB. n, m = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef permitation(x):\n\n    res = 1\n\n    for i in range(1, x + 1):\n\n        res = res * i % mod\n\n    return res\n\n\n\n\n\npn = permitation(n)\n\npm = permitation(m)\n\n\n\nif n == m:\n\n    res = pn * pm * 2 % mod\n\n    print(res)\n\nelif n == m - 1 or n == m + 1:\n\n    res = pn * pm % mod\n\n    print(res)\n\nelse:\n\n    print((0))\n", "output": "B", "improve_diff": 1.2634365303, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k = list(map(int,input().split()))\n\nm = n\n\nl = n\n\nres = 0\n\ncnt = 0\n\ntmp = m\n\nwhile m < k:\n\n    m *= 2\n\n    cnt += 1\n\nres += (1/n)*(0.5)**cnt\n\nfor i in range(1,n):\n\n    cnt = 0\n\n    l = n\n\n    l -= i\n\n    cnt = 0\n\n    while l < k:\n\n        l *= 2\n\n        cnt += 1\n\n    res += (1/n)*(0.5)**cnt\n\nprint(res) \nB. N,K = list(map(int,input().split()))\n\nres = 0\n\nfor i in range(1,N+1):\n\n    prob = 1/N\n\n    while i < K:\n\n        i *= 2\n\n        prob *= 0.5\n\n    res += prob\n\nprint(res)\n\n\n", "output": "B", "improve_diff": 1.236799893, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from itertools import product\n\nfrom collections import Counter as ct\n\n\n\nn, a, b, c = list(map(int, input().split()))\n\nl = [int(eval(input())) for _ in range(n)]\n\n\n\nans = 10 ** 10\n\nfor bit in product([0, 1, 2, 3], repeat=n):\n\n    if len(set(bit) - {0}) != 3:\n\n        continue\n\n    tmpa = 0\n\n    tmpb = 0\n\n    tmpc = 0\n\n    for i, j in enumerate(bit):\n\n        if j == 1:\n\n            tmpa += l[i]\n\n        elif j == 2:\n\n            tmpb += l[i]\n\n        elif j == 3:\n\n            tmpc += l[i]\n\n    mp = abs(a - tmpa) + abs(b - tmpb) + abs(c - tmpc)\n\n    tmp = ct(bit)\n\n    for i in range(1, 4):\n\n        mp += max(0, tmp[i] - 1) * 10\n\n    ans = min(ans, mp)\n\nprint(ans) \nB. from itertools import product\n\n\n\nn, a, b, c = list(map(int, input().split()))\n\nl = [int(eval(input())) for _ in range(n)]\n\n\n\nans = 10 ** 10\n\nfor bit in product([0, 1, 2, 3], repeat=n):\n\n    tmp = [0] * 4\n\n    mp = 0\n\n    for i, j in enumerate(bit):\n\n        if j != 3 and tmp[j] != 0:\n\n            mp += 10\n\n        tmp[j] += l[i]\n\n    if any([i == 0 for i in tmp[:3]]):\n\n        continue\n\n    mp += abs(a - tmp[0]) + abs(b - tmp[1]) + abs(c - tmp[2])\n\n    ans = min(ans, mp)\n\nprint(ans)\n", "output": "B", "improve_diff": 1.1823871387, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a,b = list(map(int,input().split()))\n\n\n\nprint((a * b)) \nB. a, b = list(map(int, input().split()))\n\n\n\nanswer = a * b\n\n\n\nprint(answer)\n", "output": "A", "improve_diff": 1.0432615895, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. W, a, b = list(map(int, input().split()))\n\na, b = (a, b) if a<b else (b, a)\n\nprint((0 if a<=b<=a+W or b<=a<=b+W else min(abs(b-(a+W)), abs(a-(b+W))))) \nB. W,a,b=list(map(int,input().split()))\n\ns={i for i in range(a,a+W+1)}&{i for i in range(b,b+W+1)}\n\nif s:\n\n  print((0))\n\nelse:\n\n  print((min(abs(b-a-W),abs(b+W-a))))", "output": "A", "improve_diff": 1.022488344, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n-2):\n\n    for j in range(i + 1, n-1):\n\n        for k in range(j + 1, n):\n\n            if len({l[i], l[j], l[k]}) != 3:\n\n                continue\n\n            if l[i] + l[j] > l[k] and l[i] + l[k] > l[j] and l[j] + l[k] > l[i]:\n\n                ans += 1\n\nprint(ans)\n \nB. from itertools import combinations\n\n\n\nn = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nl.sort()\n\nans = 0\n\n\n\nfor li, lj, lk in combinations(l, 3):\n\n    if li < lj < lk < li + lj:\n\n        ans += 1\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0135026682, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, K = list(map(int, input().split()))\n\nP, C = [list(map(int, input().split())) for _ in range(2)]\n\nc = [1] * N\n\nm = [[0] * (N+1) for i in range(N)]\n\nfor i in range(N):\n\n    m[i][1] = (C[P[i]-1])\n\nans = max(C)\n\nfor i in range(N):\n\n    j = i\n\n    while P[j]-1 != i:\n\n        j = P[j]-1\n\n        c[i] += 1\n\n        m[i][c[i]] = m[i][c[i]-1] + C[P[j]-1]\n\n    if m[i][c[i]] > 0:\n\n        ans = max(ans, m[i][c[i]] * (K//c[i]-1) + max(m[i] + [m[i][c[i]] + m[i][j+1] for j in range(K%c[i])]))\n\n    else:\n\n        ans = max(ans, max(m[i][1:min(c[i],K)+1]))\n\nprint(ans)\n \nB. N, K = list(map(int, input().split()))\n\nP, C = [list(map(int, input().split())) for _ in range(2)]\n\nans = max(C)\n\nfor i in range(N):\n\n    m = [0] * (N+1)\n\n    k = i\n\n    for j in range(N):\n\n        m[j+1] = m[j] + C[k]\n\n        k = P[k]-1\n\n        if k == i:\n\n            break\n\n    if m[j+1] > 0:\n\n        ans = max(ans, m[j+1] * (K//(j+1)-1) + max(m + [m[j+1] + m[k+1] for k in range(K%(j+1))]))\n\n    else:\n\n        ans = max(ans, max(m[1:min(j+1,K)+1]))\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0134755748, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom io import StringIO\n\nimport unittest\n\n\n\nsys.setrecursionlimit(10**6)\n\ndef search(n, step, rec, seq, k):\n\n\tif rec[n] != -1:\n\n\t\tc = step - rec[n]\n\n\t\tsim = (k - rec[n]) % c\n\n\t\tv = n\n\n\t\tfor i in range(sim):\n\n\t\t\tv = seq[v-1]\n\n\t\tprint(v)\n\n\t\treturn\n\n\trec[n] = step\n\n\tif step == k:\n\n\t\tprint(n)\n\n\t\treturn\n\n\tsearch(seq[n-1], step + 1, rec, seq, k)\n\ndef resolve():\n\n\tn, k = list(map(int, input().split()))\n\n\tseq = list(map(int, input().split()))\n\n\trec = [-1]*(n+1)\n\n\tsearch(1, 0, rec, seq, k)\n\n\n\nresolve() \nB. def resolve():\n\n\tn, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\trec = [True]*(n+2)\n\n\tnow = 0\n\n\tstp = [1]\n\n\n\n\twhile rec[now]:\n\n\t\trec[now] = False\n\n\t\tnow = a[now] - 1\n\n\t\tstp.append(now+1)\n\n\tbefore_loop = stp.index(now+1)\n\n\tloop = stp[before_loop:-1]\n\n\tif k <= (before_loop + 1):\n\n\t\tprint((stp[k]))\n\n\telse:\n\n\t\tr = (k - before_loop) % len(loop)\n\n\t\tprint((loop[r]))\n\nresolve()", "output": "B", "improve_diff": 3.2453126429, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\ncnt = [[0] * 10 for i in range(10)]\n\nfor n in range(1, N + 1):\n\n    cnt[int(str(n)[0])][int(str(n)[-1])] += 1\n\n\n\nans = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        ans += cnt[i][j] * cnt[j][i]\n\n\n\nprint(ans) \nB. N = int(eval(input()))\n\nN_ = str(N)\n\nf_N, l_N = int(N_[0]), int(N_[-1])\n\ndigit = len(N_)\n\nif digit > 2:\n\n    inter_N = int(N_[1:digit-1])\n\ncnt = 0\n\nfor num in range(1, N+1):\n\n    num = str(num)\n\n    f, l = int(num[-1]), int(num[0])\n\n    if f == 0:\n\n        continue\n\n    for i in range(1, digit+1):\n\n        if i == 1:\n\n            if f == l:\n\n                cnt += 1\n\n            else:\n\n                continue\n\n        else:\n\n            if i != digit:\n\n                cnt += 10**(i-2)\n\n            elif digit == 2 and i == digit:\n\n                if f*10+l <= N:\n\n                    cnt += 1\n\n                else:\n\n                    continue\n\n            else:\n\n                if f > f_N:\n\n                    continue\n\n                elif f == f_N:\n\n                    if l > l_N:\n\n                        cnt += inter_N\n\n                    elif l <= l_N:\n\n                        cnt += (inter_N+1)\n\n                else:\n\n                    cnt += 10**(i-2)\n\nprint(cnt)", "output": "A", "improve_diff": 1.9798386114, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\nn = int(eval(input()))\n\nv = list(map(int, input().split()))\n\ncnt_o = Counter(v[::2]).most_common(2)\n\ncnt_e = Counter(v[1::2]).most_common(2)\n\ncnt_o.append((0, 0))\n\ncnt_e.append((0, 0))\n\n\n\nif cnt_o[0][0] != cnt_e[0][0]:\n\n    print((n - cnt_o[0][1] - cnt_e[0][1]))\n\nelse:\n\n    del1 = cnt_o[0][1] - cnt_o[1][1]\n\n    del2 = cnt_e[0][1] - cnt_e[1][1]\n\n    print((n - cnt_o[0][1] - cnt_e[0][1] + min(del1, del2))) \nB. n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\n\n\napp = {}\n\nfor i, j in zip(v[::2], v[1::2]):\n\n    if i not in app:\n\n        app[i] = [1, 0]\n\n    else:\n\n        app[i][0] += 1\n\n    if j not in app:\n\n        app[j] = [0, 1]\n\n    else:\n\n        app[j][1] += 1\n\n\n\nmax_o = [0, 0]\n\nsecmax_o = [0, 0]\n\nmax_e = [0, 0]\n\nsecmax_e = [0, 0]\n\nfor i in app:\n\n    if app[i][0] > max_o[1]:\n\n        secmax_o = max_o[:]\n\n        max_o = [i, app[i][0]]\n\n    elif app[i][0] > secmax_o[1]:\n\n        secmax_o = [i, app[i][0]]\n\n    if app[i][1] > max_e[1]:\n\n        secmax_e = max_e[:]\n\n        max_e = [i, app[i][1]]\n\n    elif app[i][1] > secmax_e[1]:\n\n        secmax_e = [i, app[i][1]]\n\n\n\nif max_o[0] != max_e[0]:\n\n    print((n - max_o[1] - max_e[1]))\n\nelse:\n\n    del0 = max_o[1] - secmax_o[1]\n\n    del1 = max_e[1] - secmax_e[1]\n\n    print((n + min(del0, del1) - max_o[1] - max_e[1]))", "output": "B", "improve_diff": 1.5459500054, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom heapq import heappush, heappop, heapreplace\n\n\n\ndef solve():\n\n    file_input = sys.stdin\n\n    N, R, L = list(map(int, file_input.readline().split()))\n\n    \n\n    pq = [[0, i, 0] for i in range(1, N + 1)]\n\n    m = dict(list(zip(list(range(1, N + 1)), pq)))\n\n    \n\n    pre_t = 0\n\n    for line in file_input:\n\n        d, t, x = list(map(int, line.split()))\n\n        team = pq[0]\n\n        team[2] += t - pre_t\n\n        pre_t = t\n\n        \n\n        if team[1] == d:\n\n            team[0] -= x\n\n            if x < 0:\n\n                heapreplace(pq, team)\n\n        else:\n\n            scored_team = m[d][:]\n\n            scored_team[0] -= x\n\n            heappush(pq, scored_team)\n\n            m[d][2] = -1\n\n            m[d] = scored_team\n\n        \n\n        while pq[0][2] == -1:\n\n            heappop(pq)\n\n    pq[0][2] += L - pre_t\n\n    ans_team = max(pq, key = lambda x: (x[2], -x[1]))\n\n    print((ans_team[1]))\n\n\n\nsolve()\n \nB. import sys\n\nfrom heapq import heappush, heappop, heapreplace\n\n\n\ndef solve():\n\n    file_input = sys.stdin\n\n    N, R, L = list(map(int, file_input.readline().split()))\n\n    \n\n    pq = [[0, i] for i in range(1, N + 1)]\n\n    m = dict(list(zip(list(range(1, N + 1)), pq)))\n\n    time = [0] * (N + 1)\n\n    INVALID = -1\n\n    \n\n    pre_t = 0\n\n    for line in file_input:\n\n        d, t, x = list(map(int, line.split()))\n\n        top_team = pq[0]\n\n        time[top_team[1]] += t - pre_t\n\n        pre_t = t\n\n        \n\n        if top_team[1] == d:\n\n            top_team[0] -= x\n\n            if x < 0:\n\n                heapreplace(pq, top_team)\n\n        else:\n\n            scored_team = m[d][:]\n\n            scored_team[0] -= x\n\n            heappush(pq, scored_team)\n\n            m[d][1] = INVALID\n\n            m[d] = scored_team\n\n        \n\n        while pq[0][1] == INVALID:\n\n            heappop(pq)\n\n    time[pq[0][1]] += L - pre_t\n\n    print((time.index(max(time))))\n\n\n\nsolve()\n", "output": "B", "improve_diff": 1.080167851, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    N, A, B = list(map(int, input().split()))\n\n    H = [int(eval(input())) for _ in range(N)]\n\n    low = 0; high = 10 ** 20\n\n    while high - low > 1:\n\n        mid = (low + high) // 2\n\n        explosion = B * mid\n\n        direct = 0\n\n        for h in H:\n\n            if h - explosion > 0:\n\n                direct += (h - explosion) // (A - B)\n\n                if (h - explosion) % (A - B) > 0: direct += 1\n\n        if direct <= mid: high = mid\n\n        else: low = mid\n\n    print(high)\n\n\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve() \nB. def roof(a, b):\n\n    if a%b == 0:\n\n        return a//b\n\n    else:\n\n        return a//b + 1\n\n\n\nN, A, B = list(map(int, input().split()))\n\nH = [int(eval(input())) for i in range(N)]\n\n\n\nlow, high = 0, 10**9\n\nwhile high - low > 1:\n\n    mid = (low + high)//2\n\n    count = 0\n\n    for i in range(N):\n\n        if H[i] - (B * mid) > 0:\n\n            count += roof(H[i]-(B*mid), A-B)\n\n    if count > mid:\n\n        low = mid\n\n    else:\n\n        high = mid\n\nprint(high)", "output": "A", "improve_diff": 1.0447179171, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\nf = False\n\n\n\nfor i in range(26):\n\n    for j in range(15):\n\n        if 4 * i + 7 * j == n:\n\n            f = True\n\n            break\n\n        else:\n\n            pass\n\n\n\nif f:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\") \nB. n = int(eval(input()))\n\n\n\ncount = 0\n\n\n\nfor i in range(26):\n\n    for j in range(15):\n\n        if 4 * i + 7 * j == n:\n\n            count += 1\n\n            break\n\n        else:\n\n            pass\n\n\n\nif count == 0:\n\n    print(\"No\")\n\nelse:\n\n    print(\"Yes\")", "output": "B", "improve_diff": 1.037520945, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_right\n\nimport sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    *L, = list(map(int, input().split()))\n\n    L.sort()\n\n    ans = 0\n\n    for i in range(2, N):\n\n        for j in range(i):\n\n            k = bisect_right(L, L[i] - L[j], j + 1, i)\n\n            ans += i - k\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. N=int(eval(input()))\n\n*L,=list(map(int, input().split()))\n\nL.sort()\n\n\n\nans=0\n\nfrom bisect import bisect_right\n\nfor i in range(N-1,-1,-1):\n\n    li = L[i]\n\n    for j in range(i-1,-1,-1):\n\n        lj = L[j]\n\n        k = bisect_right(L, li-lj)\n\n        ans += max(0, j-k)\n\nprint(ans)", "output": "B", "improve_diff": 1.0808041274, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nclass Combination:\n\n    \"\"\"\n\n    comb = Combination(1000000)\n\n    print(comb(5, 3))  # 10\n\n    \"\"\"\n\n    def __init__(self, n_max, mod=10**9+7):\n\n        self.mod = mod\n\n        self.modinv = self.make_modinv_list(n_max)\n\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n\n\n    def __call__(self, n, r):\n\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n\n\n    def make_factorial_list(self, n):\n\n        # mod O(n)\n\n        # self.make_modinv_list()\n\n        fac = [1]\n\n        facinv = [1]\n\n        for i in range(1, n+1):\n\n            fac.append(fac[i-1] * i % self.mod)\n\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n\n        return fac, facinv\n\n\n\n    def make_modinv_list(self, n):\n\n        # 0nmod O(n)\n\n        modinv = [0] * (n+1)\n\n        modinv[1] = 1\n\n        for i in range(2, n+1):\n\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n\n        return modinv\n\n\n\ncomb = Combination(100010)\n\nn,k = inpl()\n\na = inpl()\n\na.sort()\n\nmx = 0\n\nfor i in range(n):\n\n    if n-i-1 < k-1: continue\n\n    tmp = comb(n-i-1,k-1)\n\n    # print(tmp)\n\n    mx += tmp*a[-i-1] - tmp*a[i]\n\n    mx %= mod\n\nprint(mx)  \nB. from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nclass Combination:\n\n    \"\"\"\n\n    comb = Combination(1000000)\n\n    print(comb(5, 3))  # 10\n\n    \"\"\"\n\n    def __init__(self, n_max, mod=10**9+7):\n\n        self.mod = mod\n\n        self.modinv = self.make_modinv_list(n_max)\n\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n\n\n    def __call__(self, n, r):\n\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n\n\n    def make_factorial_list(self, n):\n\n        # mod O(n)\n\n        # self.make_modinv_list()\n\n        fac = [1]\n\n        facinv = [1]\n\n        for i in range(1, n+1):\n\n            fac.append(fac[i-1] * i % self.mod)\n\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n\n        return fac, facinv\n\n\n\n    def make_modinv_list(self, n):\n\n        # 0nmod O(n)\n\n        modinv = [0] * (n+1)\n\n        modinv[1] = 1\n\n        for i in range(2, n+1):\n\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n\n        return modinv\n\nn,k = inpl()\n\na = sorted(inpl())\n\nres = 0\n\ncomb = Combination(10**5+10)\n\nfor i in range(n):\n\n    if n-i-1 < k-1: continue\n\n    p = comb(n-i-1,k-1)\n\n    res -= a[i] * p\n\n    res += a[-1-i] * p\n\n    res %= mod\n\nprint(res)", "output": "A", "improve_diff": 1.0353797736, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,m=list(map(int,input().split()))\n\nx=list(map(int,input().split()))\n\nx.sort()\n\ny=[x[i]-x[i-1] for i in range(1,m)]\n\ny.sort()\n\nprint((0 if n>=m else sum(y[:(m-n)]))) \nB. n,m=list(map(int,input().split()))\n\nx=sorted([int(i) for i in input().split()])\n\nxbet=sorted([abs(x[i+1]-x[i]) for i in range(m-1)],reverse=True)\n\ny=sum(xbet)\n\nif n>=m:\n\n    print((0))\n\nelse:\n\n    print((y-sum(xbet[:n-1])))\n", "output": "B", "improve_diff": 1.0123086203, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    import sys\n\n    sys.setrecursionlimit(1000000)\n\n    h, w, d = list(map(int, input().split()))\n\n    p = []\n\n    for i in range(1, h + 1):\n\n        l = list(map(int, input().split()))\n\n        for j, k in enumerate(l, 1):\n\n            p.append((k, (i, j)))\n\n    p.sort(key=lambda x: x[0])\n\n\n\n    q = int(eval(input()))\n\n\n\n    dist = [0] * (w * h + 1)\n\n\n\n    def Q(i, c, x, y):\n\n        if i + d > w * h:\n\n            return\n\n        _, (nx, ny) = p[i + d - 1]\n\n        nc = c + abs(nx - x) + abs(ny - y)\n\n        dist[i + d] = nc\n\n        Q(i + d, nc, nx, ny)\n\n\n\n    for i in range(d):\n\n        n, (x, y) = p[i]\n\n        Q(n, 0, x, y)\n\n\n\n    res = []\n\n    for _ in range(q):\n\n        l, r = list(map(int, input().split()))\n\n        res.append(dist[r] - dist[l])\n\n\n\n    ans = '\\n'.join(map(str, res))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    h, w, d = list(map(int, input().split()))\n\n\n\n    a = [None] * (h * w + 1)\n\n    for i in range(1, h + 1):\n\n        l = list(map(int, input().split()))\n\n        for j, k in enumerate(l, 1):\n\n            a[k] = (i, j)\n\n\n\n    c = [0] * (h * w + 1)\n\n    for i in range(d + 1, h * w + 1):\n\n        xb, yb = a[i-d]\n\n        xn, yn = a[i]\n\n        c[i] = c[i - d] + abs(xn - xb) + abs(yn - yb)\n\n\n\n    q = int(eval(input()))\n\n    res = []\n\n    for _ in range(q):\n\n        l, r = list(map(int, input().split()))\n\n        res.append(c[r] - c[l])\n\n\n\n    ans = '\\n'.join(map(str, res))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.01396561, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def solve(P):\n\n    A, B, C, D = P\n\n    if A<B or D<B:\n\n        return False\n\n    if C >= B-1:\n\n        return True\n\n    g = gcd(B,D)\n\n    return A%g + ((B-A%g-1)//g)*g <= C\n\n\n\nfrom math import gcd\n\n\n\nT = int(eval(input()))\n\nfor _ in range(T):\n\n    P = list(map(int, input().split()))\n\n    print((\"Yes\" if solve(P) else \"No\")) \nB. def solve(P):\n\n    A, B, C, D = P\n\n    if A<B or D<B:\n\n        return False\n\n    if C >= B-1:\n\n        return True\n\n    g = gcd(B,D)\n\n    return B + A%g - g <= C\n\n\n\nfrom math import gcd\n\n\n\nT = int(eval(input()))\n\nfor _ in range(T):\n\n    P = list(map(int, input().split()))\n\n    print((\"Yes\" if solve(P) else \"No\"))", "output": "B", "improve_diff": 1.0194166813, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def cmb(n, k, mod, fac, infac):\n\n  k = min(k,n-k)\n\n  return fac[n] * infac[k] * infac[n-k] % mod\n\n\n\ndef tables(mod, n):\n\n  fac = [1, 1] \n\n  infac = [1, 1] \n\n  inverse = [0, 1] \n\n  for i in range(2, n+1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n\n    infac.append((infac[-1] * inverse[-1]) % mod)\n\n  return fac,infac\n\n\n\nX,Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n  X, Y = Y, X\n\n\n\nmove = X + Y\n\n\n\nif move % 3 != 0:\n\n  print((0))\n\nelse:\n\n  total = move // 3\n\n  n = X - total\n\n  \n\n  if n < 0:\n\n    print((0))\n\n    \n\n  else:\n\n    MOD = 10 ** 9 + 7\n\n    fac, infac = tables(MOD, total)\n\n    ans = cmb(total, n, MOD, fac, infac)\n\n    \n\n    print(ans) \nB. X,Y = list(map(int,input().split()))\n\nM = max(X,Y)\n\nm = min(X,Y)\n\nmod = 10 ** 9 + 7\n\n\n\ncon = (X + Y) // 3\n\ndif = M - m\n\nn = (con - dif) // 2\n\n\n\nif (X + Y) % 3 != 0 or n < 0:\n\n  print((0))\n\n  \n\nelse:\n\n  def comb(n, r):\n\n    n += 1\n\n    over = 1\n\n    under = 1\n\n    for i in range(1,r + 1):\n\n      over = over * (n - i) % mod\n\n      under = under * i % mod\n\n    #powunder ** (mod - 2) % mod\n\n    return over * pow(under,mod - 2,mod) % mod\n\n  \n\n  ans = comb(con,n)\n\n  \n\n  print(ans)", "output": "B", "improve_diff": 4.9452738959, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,T  = list(map(int,input().split()))\n\nd = int(T / N)\n\ndef ans():\n\n    for i in range(d+1,0,-1):    \n\n            if T % i ==0:\n\n                print(i)\n\n                break\n\nif T % N == 0:\n\n    print (d)\n\nelse:\n\n    ans() \nB. import math\n\nN,T  = list(map(int,input().split()))\n\n#d = int(T / N)\n\nm = []\n\n\n\ndef ans():\n\n    ans = 1\n\n    for i in range(1,int(math.sqrt(T))):    \n\n            if T % i ==0:\n\n                m.append(i)\n\n                m.append(T//i)\n\n    for p in m:\n\n        if p <= T // N:\n\n            ans = max(ans,p)\n\n    print (ans)\n\n    \n\nif T % N == 0:\n\n    print((int(T / N)))\n\nelse:\n\n    ans()", "output": "A", "improve_diff": 1.2331950936, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. x, k, d = list(map(int, input().split()))\n\n\n\npm = 1 if x >= 0 else -1\n\na = abs(x)//d\n\nb = a if abs(x-pm*a*d) < abs(x-pm*(a+1)*d) else a+1\n\nc = min(b, k)\n\ne = x-pm*c*d\n\nif k < b or (k-b) % 2 == 0:\n\n    print((abs(e)))\n\nelse:\n\n    print((min(abs(e+d), abs(e-d)))) \nB. x, k, d = list(map(int, input().split()))\n\n\n\nt = min(abs(x)//d, k)\n\nu = abs(x)-d*t\n\nprint((abs(u-d*((k-t)%2))))\n", "output": "B", "improve_diff": 1.0293845257, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\nfor i in range(100):\n\n    if 1000 * i >= N:\n\n        break\n\nprint((1000 * i - N))\n \nB. N = int(eval(input()))\n\n\n\nfor i in range(1, 11):\n\n    if 1000 * i >= N:\n\n        break\n\nprint((1000 * i - N))\n", "output": "A", "improve_diff": 1.006488, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\n\n\na,b = list(map(int, input().split()))\n\n\n\nans = [a + b, a- b, a * b]\n\n\n\nprint((np.amax(ans))) \nB. a,b = list(map(int, input().split()))\n\n\n\nprint((max(max(a+b, a-b), a*b)))", "output": "B", "improve_diff": 9.4829015227, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def solve(N):\n\n    if N < 10:\n\n        return N\n\n    num = int(\"9\" * (len(str(N)) - 1))\n\n    k = int(str(N)[0] + str(num))\n\n    if k <= N:\n\n        return sum(int(c) for c in str(k))\n\n    else:\n\n        k = k - num - 1\n\n        return sum(int(c) for c in str(k))\n\n\n\n\n\nassert (solve(799) == 25)\n\nassert (solve(999) == 27)\n\nassert (solve(200) == 19)\n\nassert (solve(100) == 18)\n\nassert (solve(99) == 18)\n\nassert (solve(89) == 17)\n\nassert (solve(5) == 5)\n\n\n\nif __name__ == \"__main__\":\n\n    N = int(eval(input()))\n\n    print((solve(N)))\n \nB. def solve(N):\n\n    if N < 10:\n\n        return N\n\n    num = 9\n\n    while num < N:\n\n        num *= 10\n\n        num += 9\n\n    num -= 9\n\n    num //= 10\n\n\n\n    k = int(str(N)[0] + str(num))\n\n    if k <= N:\n\n        return sum(int(c) for c in str(k))\n\n    else:\n\n        k = int(str(N)[0] + str(num)) - num - 1\n\n        return sum(int(c) for c in str(k))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    N = int(eval(input()))\n\n    print((solve(N)))\n", "output": "B", "improve_diff": 1.0312544005, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\nx = 0\n\nfor i in range(1,n+1):\n\n    if len(str(i))%2!=0:\n\n        x += 1\n\n\n\nprint(x) \nB. a =int(eval(input()))\n\nb=0\n\nfor i in range(1,a+1):\n\n    s=[]\n\n    s=list(str(i))\n\n    if len(s)%2!=0:\n\n        b+=1\n\nprint(b)", "output": "A", "improve_diff": 1.2648713697, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\ns = [0]*n\n\nfor i in a:\n\n  s[i-1] += 1\n\n  \n\nfor i in s:\n\n  print(i) \nB. from collections import Counter\n\nn = int(eval(input()))\n\na = Counter(list(map(int, input().split())))\n\n\n\nfor i in range(n):\n\n  print((a[i+1]))", "output": "A", "improve_diff": 1.4098223147, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict\n\n\n\ndef main():\n\n    X, Y, A, B, C = list(map(int, input().split()))\n\n    P = list(map(int, input().split()))\n\n    Q = list(map(int, input().split()))\n\n    R = list(map(int, input().split()))\n\n    d_p = defaultdict(int)\n\n    d_q = defaultdict(int)\n\n    d_r = defaultdict(int)\n\n    for p in P:\n\n        d_p[p] += 1\n\n    for q in Q:\n\n        d_q[q] += 1\n\n    for r in R:\n\n        d_r[r] += 1\n\n    D = P + Q + R\n\n    D.sort(reverse=True)\n\n    ans = 0\n\n    x = 0\n\n    y = 0\n\n    c = 0\n\n    for i in range(A + B + C):\n\n        if x + y + c >= X + Y:\n\n            break\n\n\n\n        if x < X and d_p[D[i]]:\n\n            ans += D[i]\n\n            x += 1\n\n            d_p[D[i]] -= 1\n\n        elif y < Y and d_q[D[i]]:\n\n            ans += D[i]\n\n            y += 1\n\n            d_q[D[i]] -= 1\n\n        elif d_r[D[i]]:\n\n            ans += D[i]\n\n            c += 1\n\n            d_r[D[i]] -= 1\n\n\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. import heapq\n\nimport sys\n\nfrom itertools import accumulate\n\nfrom collections import defaultdict\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    X, Y, A, B, C = list(map(int, input().split()))\n\n    P = list(map(int, input().split()))\n\n    Q = list(map(int, input().split()))\n\n    R = list(map(int, input().split()))\n\n    ans = 0\n\n    P_d = defaultdict(int)\n\n    Q_d = defaultdict(int)\n\n    R_d = defaultdict(int)\n\n\n\n    for i in range(len(P)):\n\n        P[i] = -P[i]\n\n        P_d[P[i]] += 1\n\n        \n\n    for i in range(len(Q)):\n\n        Q[i] = -Q[i]\n\n        Q_d[Q[i]] += 1\n\n\n\n    \n\n    for i in range(len(R)):\n\n        R[i] = -R[i]\n\n        R_d[R[i]] += 1\n\n\n\n    H = P + Q + R\n\n    heapq.heapify(H)\n\n    red = 0\n\n    green = 0\n\n    nocl = 0\n\n    ans = 0\n\n    for i in range(A + B + C):\n\n        tmp = heapq.heappop(H)\n\n        if red + green + nocl == X + Y:\n\n            print((-ans))\n\n            exit()\n\n\n\n        if P_d[tmp] >= 1 and red < X:\n\n            P_d[tmp] -= 1\n\n            red += 1\n\n            ans += tmp\n\n        elif Q_d[tmp] >= 1 and green < Y:\n\n            Q_d[tmp] -= 1\n\n            green += 1\n\n            ans += tmp\n\n        elif R_d[tmp] >= 1:\n\n            R_d[tmp] -= 1\n\n            nocl += 1\n\n            ans += tmp\n\n    \n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "A", "improve_diff": 1.0450458279, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [int(_) for _ in input().split()]\n\n\n\n\n\nclass BIT:\n\n    # index 1~\n\n    def __init__(self, n):\n\n        self.size = n\n\n        self.tree = [0] * (n + 1)\n\n\n\n    def sum(self, i):\n\n        s = 0\n\n        while i > 0:\n\n            s += self.tree[i]\n\n            i -= i & -i\n\n        return s\n\n\n\n    def add(self, i, x):\n\n        while i <= self.size:\n\n            self.tree[i] += x\n\n            i += i & -i\n\n\n\n\n\nM = N * (N + 1) // 2  # (N+1)C2\n\nsorted_A = sorted(A)\n\n\n\ninf = 0\n\nsup = max(A) + 1\n\nwhile sup - inf > 1:\n\n    x = (sup + inf) // 2\n\n\n\n    S = [0] * (N + 1)\n\n    for i in range(N):\n\n        if A[i] >= x:\n\n            S[i + 1] = S[i] + 1\n\n        else:\n\n            S[i + 1] = S[i] - 1\n\n\n\n    min_value = min(S)\n\n    for i in range(N + 1):\n\n        S[i] += abs(min_value) + 1\n\n\n\n    forward = 0\n\n    bit = BIT(max(S))\n\n    for s in S:\n\n        forward += bit.sum(s)\n\n        bit.add(s, 1)\n\n\n\n    if forward >= (M + 1) // 2:\n\n        inf = x\n\n    else:\n\n        sup = x\n\n\n\nfor a in reversed(sorted_A):\n\n    if inf >= a:\n\n        print(a)\n\n        break\n \nB. N = int(eval(input()))\n\nA = [int(_) for _ in input().split()]\n\n\n\nclass BIT:\n\n    # index 1~\n\n    def __init__(self, n):\n\n        self.size = n\n\n        self.tree = [0] * (n + 1)\n\n\n\n    def sum(self, i):\n\n        s = 0\n\n        while i > 0:\n\n            s += self.tree[i]\n\n            i -= i & -i\n\n        return s\n\n\n\n    def add(self, i, x):\n\n        while i <= self.size:\n\n            self.tree[i] += x\n\n            i += i & -i\n\n\n\ndef sub_problem(x):\n\n    S = [0] * (N + 1)\n\n    for i in range(N):\n\n        S[i + 1] = S[i] + 1 if A[i] >= x else S[i] - 1\n\n\n\n    geta = abs(min(S)) + 1\n\n    for i in range(N + 1):\n\n        S[i] += geta\n\n\n\n    forward = 0\n\n    bit = BIT(max(S))\n\n    for s in S:\n\n        forward += bit.sum(s)\n\n        bit.add(s, 1)\n\n\n\n    return forward >= (M + 1) // 2\n\n\n\nM = N * (N + 1) // 2  # (N+1)C2\n\nsorted_A = sorted(A)\n\n\n\ninf = 0\n\nsup = N\n\nwhile sup - inf > 1:\n\n    mid = (sup + inf) // 2\n\n    x = sorted_A[mid]\n\n\n\n    if sub_problem(x):\n\n        inf = mid\n\n    else:\n\n        sup = mid\n\n\n\nprint((sorted_A[inf]))\n", "output": "B", "improve_diff": 1.0469096949, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. primes = [0, 0] + [1] * 999999\n\nfor i in range(2, 1000):\n\n    if primes[i]:\n\n        for j in range(i*i, 1000000, i):\n\n            primes[j] = 0\n\n\n\nwhile True:\n\n    try:\n\n        n = int(eval(input()))\n\n    except:\n\n        break\n\n    ans = 0\n\n    while n > 0:\n\n        ans += primes[n]\n\n        n -= 1\n\n    print(ans)\n\n\n \nB. primes = [0, 0] + [1] * 999999\n\nfor i in range(2, 1000):\n\n    if primes[i]:\n\n        for j in range(i*i, 1000000, i):\n\n            primes[j] = 0\n\n\n\nanswer = [0] * 1000000\n\nfor i in range(2, 1000000):\n\n    answer[i] += primes[i] + answer[i-1]\n\n\n\nwhile True:\n\n    try:\n\n        n = int(eval(input()))\n\n    except:\n\n        break\n\n    print((answer[n]))\n\n\n", "output": "A", "improve_diff": 2.0698499293, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #! /usr/bin/python3\n\n\n\nx = int(eval(input()))\n\nif x:\n\n    print((0))\n\nelse:\n\n    print((1))\n \nB. #! /usr/bin/python3\n\n\n\nx = int(eval(input()))\n\nprint((1-x))\n", "output": "A", "improve_diff": 1.0110650314, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. V, E, r = list(map(int, input().split()))\n\ng = [[] for i in range(V)]\n\nfor i in range(E):\n\n    s, t, d = list(map(int, input().split()))\n\n    g[s].append((t, d))\n\n\n\nINF = 10**18\n\ndist = [INF] * V\n\ndist[r] = 0\n\nupdate = 1\n\nfor _ in range(V):\n\n    update = 0\n\n    for v, e in enumerate(g):\n\n        for t, cost in e:\n\n            if dist[v]!=INF and dist[v] + cost < dist[t]:\n\n                dist[t] = dist[v] + cost\n\n                update = 1\n\n    if not update:\n\n        break\n\nelse:\n\n    print(\"NEGATIVE CYCLE\")\n\n    exit(0)\n\nfor i in range(V):\n\n    print(dist[i] if dist[i]<INF else \"INF\") \nB. from collections import deque\n\nN, M, r = list(map(int, input().split()))\n\nG = [[] for i in range(N)]\n\nfor i in range(M):\n\n    s, t, d = list(map(int, input().split()))\n\n    G[s].append((t, d))\n\n\n\nINF = 10**18\n\ndef SPFA(N, G, s):\n\n    dist = [INF] * N\n\n    cont = [0] * N\n\n    cnts = [0]* N\n\n\n\n    dist[s] = 0\n\n    cont[s] = 1\n\n    cnts[s] += 1\n\n    que = deque([s])\n\n    su = s; num = 1\n\n    while que:\n\n        v = que.popleft()\n\n        cont[v] = 0\n\n        d = dist[v]\n\n        su -= d\n\n        num -= 1\n\n        for w, c in G[v]:\n\n            r = d + c\n\n            if r < dist[w]:\n\n                if not cont[w]:\n\n                    cnts[w] += 1\n\n                    if N <= cnts[w]:\n\n                        return None\n\n                    if que and r < que[0]:\n\n                        que.appendleft(w)\n\n                    else:\n\n                        que.append(w)\n\n                    cont[w] = 1\n\n                    su += r\n\n                    num += 1\n\n                    dist[w] = r\n\n                    while su < dist[que[0]]*num:\n\n                        que.append(que.popleft())\n\n                else:\n\n                    su += r - dist[w]\n\n                    dist[w] = r\n\n    return dist\n\ndist = SPFA(N, G, r)\n\nif dist is None:\n\n    print(\"NEGATIVE CYCLE\")\n\nelse:\n\n    for i in range(N):\n\n        print((dist[i] if dist[i] < INF else \"INF\"))\n", "output": "A", "improve_diff": 1.4866082875, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. W,H,N = list(map(int,input().split()))\n\nX1 = W\n\nX2 = 0\n\nY1 = H\n\nY2 = 0\n\nfor _ in range(N):\n\n    x,y,a = list(map(int,input().split()))\n\n    if a==1:\n\n        X2 = max(X2,x)\n\n    elif a==2:\n\n        X1 = min(X1,x)\n\n    elif a==3:\n\n        Y2 = max(Y2,y)\n\n    elif a==4:\n\n        Y1 = min(Y1,y)\n\nif X2>=X1 and Y2>=Y1:\n\n    ans = 0\n\nelif X2>=X1 and Y2<Y1:\n\n    ans = 0\n\nelif X2<X1 and Y2>=Y1:\n\n    ans = 0\n\nelif X2<X1 and Y2<Y1:\n\n    ans = (X1-X2)*(Y1-Y2)\n\nprint(ans) \nB. W,H,N = list(map(int,input().split()))\n\nxl = 0\n\nxh = W\n\nyl = 0\n\nyh = H\n\nfor _ in range(N):\n\n    x,y,a = list(map(int,input().split()))\n\n    if a==1:\n\n        xl = max(xl,x)\n\n    elif a==2:\n\n        xh = min(xh,x)\n\n    elif a==3:\n\n        yl = max(yl,y)\n\n    elif a==4:\n\n        yh = min(yh,y)\n\ndx = max(0,xh-xl)\n\ndy = max(0,yh-yl)\n\nprint((dx*dy))", "output": "B", "improve_diff": 1.0130613421, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    from collections import Counter\n\n    c = Counter(A)\n\n    ans = 0\n\n    for v in list(c.values()):\n\n        ans += v*(v-1)//2\n\n\n\n    for k in range(N):\n\n        v = c[A[k]]\n\n        diff = -v*(v-1)//2 + (v-1)*(v-2)//2\n\n        print((ans + (diff if v != 1 else 0)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    from collections import Counter\n\n    c = Counter(A)\n\n    ans = 0\n\n    for v in list(c.values()):\n\n        ans += v*(v-1)//2\n\n\n\n    for k in range(N):\n\n        v = c[A[k]]\n\n        diff = -v*(v-1)//2 + (v-1)*(v-2)//2\n\n        print((ans + diff))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0165635743, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import Counter\n\n\n\nsys.setrecursionlimit(10 ** 8)\n\nini = lambda: int(sys.stdin.readline())\n\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\n\nins = lambda: sys.stdin.readline().rstrip()\n\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\n\nN = ini()\n\nA = inl()\n\n\n\n\n\ndef solve():\n\n    cum = [0] * (N + 1)\n\n    for i in range(N - 1, -1, -1):\n\n        cum[i] = cum[i + 1] + A[i]\n\n    count = Counter()\n\n    ans = 0\n\n    for i in range(N):\n\n        count[cum[i]] += 1\n\n        ans += count[cum[i + 1]]\n\n    return ans\n\n\n\n\n\nprint(solve())\n \nB. import sys\n\nfrom collections import Counter\n\n\n\nsys.setrecursionlimit(10 ** 8)\n\nini = lambda: int(sys.stdin.readline())\n\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\n\nins = lambda: sys.stdin.readline().rstrip()\n\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\n\nN = ini()\n\nA = inl()\n\n\n\n\n\ndef solve():\n\n    cum = [0] * (N + 1)\n\n    for i in range(N - 1, -1, -1):\n\n        cum[i] = cum[i + 1] + A[i]\n\n    count = Counter()\n\n    ans = 0\n\n    for i in range(N):\n\n        if A[i] == 0:\n\n            ans += 1\n\n        ans += count[cum[i] - A[i]]\n\n        count[cum[i]] += 1\n\n    return ans\n\n\n\n\n\nprint(solve())\n", "output": "A", "improve_diff": 1.0117779049, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M = list(map(int, input().split()))\n\nP = list(map(int, input().split()))\n\nP = list(enumerate(P, start=1))\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.par = [i for i in range(n+1)]\n\n        self.rank = [0] * (n+1)\n\n        self.size = [1] * (n+1)\n\n\n\n    # \n\n    def find(self, x):\n\n        if self.par[x] == x:\n\n            return x\n\n        else:\n\n            self.par[x] = self.find(self.par[x])\n\n            return self.par[x]\n\n\n\n    # \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.par[x] = y\n\n            self.size[y] += self.size[x]\n\n            self.size[x] = 0\n\n        else:\n\n            self.par[y] = x\n\n            self.size[x] += self.size[y]\n\n            self.size[y] = 0\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    # \n\n    def same_check(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n\n\nuf = UnionFind(N)\n\nfor m in range(M):\n\n    x, y = list(map(int, input().split()))\n\n    uf.union(x, y)\n\n\n\nans = 0\n\nfor now, value in P:\n\n    if uf.same_check(now, value):\n\n        ans += 1\n\nprint(ans) \nB. N, M = list(map(int, input().split()))\n\nP = list(enumerate(map(int, input().split())))\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n\n        self.par = [i for i in range(n)]\n\n        self.rank = [0] * n\n\n        self.size = [1] * n\n\n\n\n    # \n\n    def find(self, x):\n\n        if self.par[x] == x:\n\n            return x\n\n        else:\n\n            self.par[x] = self.find(self.par[x])\n\n            return self.par[x]\n\n\n\n    # \n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.par[x] = y\n\n            self.size[y] += self.size[x]\n\n            self.size[x] = 0\n\n        else:\n\n            self.par[y] = x\n\n            self.size[x] += self.size[y]\n\n            self.size[y] = 0\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    # \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\n    # \n\n    def all_find(self):\n\n        for n in range(len(self.par)):\n\n            self.find(n)\n\n\n\n\n\nUF = UnionFind(N)\n\nfor i in range(M):\n\n    x, y = list(map(int, input().split()))\n\n    x, y = x-1, y-1\n\n    UF.union(x, y)\n\n\n\n\n\nUF.all_find()\n\n\n\nans = 0\n\nfor index, number in P:\n\n    ans += UF.same(index, number - 1)\n\n\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0315910765, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # Acceptance of input\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nn = file_input.readline()\n\n\n\nEP = []\n\nl = -1000000001\n\nu = 1000000001\n\nvs_x = set()\n\n\n\nfor line in file_input:\n\n    x1, y1, x2, y2 = (list(map(int, line.split())))\n\n    if x1 == x2:\n\n        if y1 < y2:\n\n            EP.append((y1, l, x1))\n\n            EP.append((y2, u, x1))\n\n        else:\n\n            EP.append((y1, u, x1))\n\n            EP.append((y2, l, x1))\n\n        vs_x.add(x1)\n\n    else:\n\n        if x1 < x2:\n\n            EP.append((y1, x1, x2))\n\n        else:\n\n            EP.append((y1, x2, x1))\n\n\n\nvs_x = sorted(vs_x)\n\n\n\n# Binary Indexed Tree\n\nclass BinaryIndexedTree:\n\n    def __init__(self, n):\n\n        self.data = [0] * (n + 1)\n\n        self.num = n\n\n\n\n    def switch(self, i, d):\n\n        while  i <= self.num:\n\n            self.data[i] += d\n\n            i += i & -i\n\n\n\n    def _sum(self, i):\n\n        s = 0\n\n        while i:\n\n            s += self.data[i]\n\n            i -= i & -i\n\n        return s\n\n\n\n    def seg_sum(self, a, b):\n\n        return self._sum(b) - self._sum(a - 1)\n\n\n\n# Sweep\n\nimport bisect\n\n\n\nEP.sort()\n\nBIT = BinaryIndexedTree(len(vs_x))\n\ncnt = 0\n\n\n\nfor p in EP:\n\n    e = p[1]\n\n    if e == l:\n\n        vx = bisect.bisect(vs_x, p[2])\n\n        BIT.switch(vx, 1)\n\n    elif e == u:\n\n        vx = bisect.bisect(vs_x, p[2])\n\n        BIT.switch(vx, -1)\n\n    else:\n\n        l_x = bisect.bisect_left(vs_x, e) + 1\n\n        r_x = bisect.bisect(vs_x, p[2])\n\n        cnt += BIT.seg_sum(l_x, r_x)\n\n\n\n# Output\n\nprint(cnt) \nB. # Acceptance of input\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nn = file_input.readline()\n\n\n\nEP = []\n\nl = -1000000001\n\nu = 1000000001\n\nvs_x = set()\n\n\n\nfor line in file_input:\n\n    x1, y1, x2, y2 = (list(map(int, line.split())))\n\n    if x1 == x2:\n\n        if y1 < y2:\n\n            EP.append((y1, l, x1))\n\n            EP.append((y2, u, x1))\n\n        else:\n\n            EP.append((y1, u, x1))\n\n            EP.append((y2, l, x1))\n\n        vs_x.add(x1)\n\n    else:\n\n        if x1 < x2:\n\n            EP.append((y1, x1, x2))\n\n        else:\n\n            EP.append((y1, x2, x1))\n\n\n\n# Binary Indexed Tree\n\nclass BinaryIndexedTree:\n\n    def __init__(self, n):\n\n        self.data = [0] * (n + 1)\n\n        self.num = n\n\n\n\n    def switch(self, i, d):\n\n        while  i <= self.num:\n\n            self.data[i] += d\n\n            i += i & -i\n\n\n\n    def _sum(self, i):\n\n        s = 0\n\n        while i:\n\n            s += self.data[i]\n\n            i -= i & -i\n\n        return s\n\n\n\n    def seg_sum(self, a, b):\n\n        return self._sum(b) - self._sum(a - 1)\n\n\n\n# Sweep\n\nimport bisect\n\n\n\nEP.sort()\n\nBIT = BinaryIndexedTree(len(vs_x))\n\nvs_x = [l] + sorted(vs_x)\n\nd_vs_x = {e: i for i, e in enumerate(vs_x)}\n\ncnt = 0\n\n\n\nfor p in EP:\n\n    e = p[1]\n\n    if e == l:\n\n        BIT.switch(d_vs_x[p[2]], 1)\n\n    elif e == u:\n\n        BIT.switch(d_vs_x[p[2]], -1)\n\n    else:\n\n        l_x = bisect.bisect_left(vs_x, e)\n\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n\n        cnt += BIT.seg_sum(l_x, r_x)\n\n\n\n# Output\n\nprint(cnt)", "output": "A", "improve_diff": 1.0192763543, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque, defaultdict\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef main():\n\n    N, u, v = list(map(int, input().split()))\n\n    u -= 1\n\n    v -= 1\n\n    \n\n    edges = [list(map(int, input().split())) for _ in range(N-1)]\n\n\n\n    to = [[] for _ in range(N)]\n\n    for a, b in edges:\n\n        a -= 1\n\n        b -= 1\n\n        to[a].append(b)\n\n        to[b].append(a)\n\n    \n\n    dist  = {key:defaultdict(int) for key in [u, v]}\n\n\n\n    def bfs(key):\n\n        q = deque()\n\n        q.append(key)\n\n        while(len(q)):\n\n            now = q.popleft()\n\n            for nv in to[now]:\n\n                if nv == key or dist[key][nv]:\n\n                    continue\n\n                else:\n\n                    dist[key][nv] = dist[key][now] + 1\n\n                    q.append(nv)\n\n    \n\n    for key in [u, v]:\n\n        bfs(key)\n\n    \n\n    ans = 0\n\n    for i in range(N):\n\n        diff = dist[v][i] - dist[u][i]\n\n        if diff > 0:\n\n            ans = max(ans, dist[v][i]-1)\n\n\n\n    print(ans)    \n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. import sys\n\nsys.setrecursionlimit(10**9)\n\n\n\n\n\ndef dfs4t(a, par):\n\n    for child in edge[a]:\n\n        if child == par:\n\n            continue\n\n        else:\n\n            cost4t[child] = cost4t[a] + 1\n\n            dfs4t(child, a)\n\n    return\n\n\n\ndef dfs4a(a, par):\n\n    for child in edge[a]:\n\n        if child == par:\n\n            continue\n\n        else:\n\n            cost4a[child] = cost4a[a] + 1\n\n            dfs4a(child, a)\n\n    return\n\n\n\n\n\nN, u, v = list(map(int, input().split()))\n\nedge = [[] for _ in range(N)]\n\ncost4t = [10**5 for i in range(N)]\n\ncost4a = [10**5 for i in range(N)]\n\n\n\nfor _ in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    edge[a].append(b)\n\n    edge[b].append(a)\n\n\n\nu -= 1\n\nv -= 1\n\ncost4t[u] = 0\n\ncost4a[v] = 0\n\ndfs4t(u, 10**5)\n\ndfs4a(v, 10**5)\n\n\n\nans = 0\n\nfor t, a, in zip(cost4t, cost4a):\n\n    if a  >= t:\n\n        ans = max(ans, t + a - (t + 1))\n\nprint(ans)", "output": "B", "improve_diff": 1.4276348489, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def resolve():\n\n    N, W = list(map(int, input().split()))    \n\n    w_v = [list(map(int, input().split())) for _ in range(N)]  # [N][0:weight, 1:value]\n\n\n\n    dp = [[0] * (W+1) for _ in range(N+1)] \n\n\n\n    for i in range(N):\n\n        for j in range(W+1):\n\n            w = w_v[i][0]\n\n            v = w_v[i][1]\n\n            if j < w:\n\n                dp[i+1][j] = dp[i][j]\n\n            else:\n\n                dp[i+1][j] = max(dp[i][j], dp[i][j - w] + v)\n\n \n\n    print((dp[N][W]))\n\n \n\nif __name__ == \"__main__\":\n\n    resolve() \nB. def resolve():\n\n    N, W = list(map(int, input().split()))    \n\n    w_v = [list(map(int, input().split())) for _ in range(N)]  # [N][0:weight, 1:value]\n\n\n\n    dp = [[0] * (W+1) for _ in range(N+1)] \n\n\n\n    for i in range(N-1,-1,-1):\n\n        for j in range(W+1):\n\n            w = w_v[i][0]\n\n            v = w_v[i][1]\n\n            if j < w_v[i][0]:\n\n                dp[i][j] = dp[i+1][j]\n\n            else:\n\n                dp[i][j] = max(dp[i+1][j], dp[i+1][j - w] + v)\n\n \n\n    print((dp[0][W]))\n\n \n\nif __name__ == \"__main__\":\n\n    resolve()", "output": "A", "improve_diff": 1.0258175974, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, M, X = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\ncnt = 0\n\nmin = 0\n\ncnt_2 = 0\n\nlists = list(range(N + 1))\n\nfor i in range(X, N + 1):\n\n    for j in range(len(A)):\n\n        if i == 0 or i == N or i == X:\n\n            continue\n\n        elif i == A[j]:\n\n            cnt += 1\n\nfor m in range(X, -1, -1):\n\n    for n in range(len(A)):\n\n        if m == 0 or m == N or m == X:\n\n            continue\n\n        elif m == A[n]:\n\n            cnt_2 += 1\n\nif cnt > cnt_2:\n\n    min = cnt_2\n\nelif cnt_2 > cnt:\n\n    min = cnt\n\nprint(min)\n \nB. n,m,x = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\ncnt_r = 0\n\ncnt_l = 0\n\nroad = [True]*(n+1)\n\nfor i in a:\n\n    road[i] = False\n\nfor i in range(x,n+1):\n\n    if not road[i]:\n\n        cnt_r += 1\n\nfor i in range(x,-1,-1):\n\n    if not road[i]:\n\n        cnt_l += 1\n\nans = min(cnt_r,cnt_l)\n\nprint(ans)", "output": "B", "improve_diff": 1.0319399709, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nfrom operator import itemgetter\n\n\n\ndef sub(prefers, canceled):\n\n    res = Counter()\n\n    for pref in prefers:\n\n        pt = -1\n\n        while pref[pt] in canceled:\n\n            pt -= 1\n\n        res[pref[pt]] += 1\n\n    return max(list(res.items()), key=itemgetter(1))\n\n\n\ndef solve(m, prefers):\n\n    canceled = set()\n\n    ans = float('inf')\n\n    for _ in [0] * m:\n\n        s, c = sub(prefers, canceled)\n\n        canceled.add(s)\n\n        ans = min(ans, c)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = [list(map(int, input().split()))[::-1] for _ in [0] * N]\n\n    print((solve(M, A))) \nB. from collections import Counter\n\nfrom operator import itemgetter\n\n\n\ndef sub(prefers, canceled):\n\n    res = Counter()\n\n    for pref in prefers:\n\n        p = pref[-1]\n\n        while p in canceled:\n\n            pref.pop()\n\n            p = pref[-1]\n\n        res[p] += 1\n\n    return max(list(res.items()), key=itemgetter(1))\n\n\n\ndef solve(m, prefers):\n\n    canceled = set()\n\n    ans = float('inf')\n\n    for _ in [0] * m:\n\n        s, c = sub(prefers, canceled)\n\n        canceled.add(s)\n\n        ans = min(ans, c)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = [list(map(int, input().split()))[::-1] for _ in [0] * N]\n\n    print((solve(M, A)))", "output": "B", "improve_diff": 1.0272444255, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N=int(eval(input()))\n\nH=list(map(int,input().split()))\n\nif N==1:\n\n  print(\"Yes\")\n\n  exit()\n\nif H[0]<H[1]:\n\n  H[0]-=1\n\nelif H[0]>H[1]:\n\n  print(\"No\")\n\n  exit()\n\nfor i in range(1,N):\n\n  if H[i-1]<H[i]:\n\n    H[i]-=1\n\n  elif H[i-1]>H[i]:\n\n    print(\"No\")\n\n    exit()\n\nprint(\"Yes\") \nB. N=int(eval(input()))\n\nH=list(map(int,input().split()))\n\nif N==1:\n\n  print(\"Yes\")\n\n  exit()\n\nfor i in range(N-1):\n\n  if H[i]-1<=H[i+1]:\n\n    if i!=0:\n\n      if H[i-1]<H[i]:\n\n        H[i]-=1\n\n  elif H[i]==H[i+1]:\n\n    continue\n\n  else:\n\n    print(\"No\")\n\n    exit()\n\nfor i in range(N-1):\n\n  if H[i]>H[i+1]:\n\n    print(\"No\")\n\n    exit()\n\nprint(\"Yes\")", "output": "A", "improve_diff": 1.0296915704, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    N = int(eval(input()))\n\n\n\n    def to_bin(n):\n\n        \"\"\"\n\n        n:10 -> 2\n\n        \"\"\"\n\n        if n == 0:\n\n            return 0\n\n        digits = []\n\n        i = 0\n\n        base = 1\n\n        while n != 0:\n\n            if n % (base*2) == 0:\n\n                digits.append(\"0\")\n\n            else:\n\n                digits.append(\"1\")\n\n                n -= base\n\n            i += 1\n\n            base *= -2\n\n        return \"\".join(digits[::-1])\n\n\n\n    print((to_bin(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    N = int(eval(input()))\n\n\n\n    def to_bin(n):\n\n        \"\"\"\n\n        n:10 -> 2\n\n        \"\"\"\n\n        if n == 0:\n\n            return 0\n\n        digits = []\n\n        i = 0\n\n        base = 1\n\n        while n != 0:\n\n            if n % (base*-2) == 0:\n\n                digits.append(\"0\")\n\n            else:\n\n                digits.append(\"1\")\n\n                n -= base\n\n            i += 1\n\n            base *= -2\n\n        return \"\".join(digits[::-1])\n\n\n\n    print((to_bin(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.0615826848, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nN, K = list(map(int,input().split()))\n\nprint((math.ceil((N-1)/(K-1)))) \nB. import math\n\nN, K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nprint((math.ceil((N-1)/(K-1))))", "output": "B", "improve_diff": 1.0424978039, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # 3.4.3\n\n\n\nimport re\n\nfrom collections import deque\n\nfrom functools import reduce\n\nfrom heapq import *\n\nfrom itertools import permutations\n\nfrom math import pi\n\nfrom operator import itemgetter\n\nfrom operator import mul\n\nfrom operator import xor\n\nfrom os import linesep\n\n\n\n\n\ndef isprime(n: int) -> bool:\n\n    if n <= 1:\n\n        return False\n\n    if n in (2, 3, 5):\n\n        return True\n\n    if n % 2 == 0:\n\n        return False\n\n    if n % 3 == 0:\n\n        return False\n\n    lst = int(n**0.5)\n\n    f = 5\n\n    while f <= lst:\n\n        if n % f == 0:\n\n            return False\n\n        if n % (f + 2) == 0:\n\n            return False\n\n        f += 6\n\n    return True\n\n\n\n\n\ndef strmat(matrix, lnsep: str = linesep, fieldsep: str = ' ') -> str:\n\n    return lnsep.join([fieldsep.join(map(str, row)) for row in matrix])\n\n\n\n\n\ndef strbool(boolval: int) -> str:\n\n    return ['No', 'Yes'][boolval]\n\n\n\n\n\ndef solve() -> None:\n\n    # read here\n\n    n, m, *t = list(map(int, open(0).read().split()))\n\n\n\n    # solve here\n\n    d = [[] for i in range(m+1)]\n\n    for i in range(n):\n\n        a, b = t[2*i], t[2*i+1]\n\n        if a > m:\n\n            continue\n\n        d[a].append(b)\n\n\n\n    ans = 0\n\n    tasks = []\n\n    for t in range(m + 1):\n\n        # from (m days after) to today\n\n        for tasksize in d[t]:\n\n            heappush(tasks, -tasksize)\n\n        if tasks:\n\n            # do task\n\n            ans -= heappop(tasks)\n\n\n\n    # print here\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n \nB. # 3.4.3\n\n\n\nimport re\n\nfrom collections import deque\n\nfrom functools import reduce\n\nfrom heapq import heappop\n\nfrom heapq import heappush\n\nfrom itertools import permutations\n\nfrom math import pi\n\nfrom operator import itemgetter\n\nfrom operator import mul\n\nfrom operator import xor\n\nfrom os import linesep\n\nfrom sys import stdin\n\n\n\n\n\ndef rline() -> str:\n\n    return stdin.readline().strip()\n\n\n\n\n\ndef rlines(hint: int = 1):\n\n    ret = ['' for i in range(hint)]\n\n    for i in range(hint):\n\n        ret[i] = rline()\n\n    return ret\n\n\n\n\n\ndef htokens(hint: int = 1):\n\n    lns = rlines(hint)\n\n    ret = list([ln.split() for ln in lns])\n\n    return ret\n\n\n\n\n\ndef vtokens(hint: int = 1):\n\n    m, _ = htokens()\n\n    wint = len(m)\n\n    ret = [[None] * hint for i in range(wint)]\n\n    for y in range(hint):\n\n        if y != 0:\n\n            m, _ = htokens()\n\n        # convert horizontal to vertical\n\n        x = 0\n\n        for v in m:\n\n            ret[x][y] = v\n\n            x += 1\n\n    # if return value has one and only one element(list),\n\n    if wint == 1:\n\n        # then add an empty list.\n\n        ret.append([])\n\n    return ret\n\n\n\n\n\ndef rint(radix: int = 10) -> int:\n\n    return int(rline(), radix)\n\n\n\n\n\ndef hints(hint: int = 1, radix: int = 10):\n\n    ret = htokens(hint)\n\n    for i in range(len(ret)):\n\n        ret[i] = list([int(v, radix) for v in ret[i]])\n\n    return ret\n\n\n\n\n\ndef vints(hint: int = 1, radix: int = 10):\n\n    ret = vtokens(hint)\n\n    for i in range(len(ret)):\n\n        ret[i] = list([int(v, radix) for v in ret[i]])\n\n    return ret\n\n\n\n\n\ndef mat(hint: int, wint: int):\n\n    return [[None]*wint for i in range(hint)]\n\n\n\n\n\ndef filllist(lst, value: int) -> None:\n\n    # destructive.\n\n    for i in range(len(lst)):\n\n        lst[i] = value\n\n\n\n\n\ndef isprime(n: int) -> bool:\n\n    if n <= 1:\n\n        return False\n\n    if n in (2, 3, 5):\n\n        return True\n\n    if n % 2 == 0:\n\n        return False\n\n    if n % 3 == 0:\n\n        return False\n\n    lst = int(n**0.5)\n\n    f = 5\n\n    while f <= lst:\n\n        if n % f == 0:\n\n            return False\n\n        if n % (f + 2) == 0:\n\n            return False\n\n        f += 6\n\n    return True\n\n\n\n\n\ndef strmat(matrix, lnsep: str = linesep, fieldsep: str = ' ') -> str:\n\n    return lnsep.join([fieldsep.join(map(str, row)) for row in matrix])\n\n\n\n\n\ndef strbool(boolval: int) -> str:\n\n    return ['No', 'Yes'][boolval]\n\n\n\n\n\ndef solve() -> None:\n\n    # read here\n\n    (n, m) = hints()[0]\n\n    ab_s = hints(n)\n\n\n\n    # solve here\n\n\n\n    # delay asc, prize desc\n\n    ab_s.sort(key=itemgetter(1), reverse=True)\n\n    ab_s.sort(key=itemgetter(0), reverse=False)\n\n\n\n    ans = 0\n\n    tasks = []\n\n    ti = 0\n\n    for t in range(m + 1):\n\n        # from (m days after) to today\n\n        while ti < n and ab_s[ti][0] == t:\n\n            a, b = ab_s[ti]\n\n            ti += 1\n\n            heappush(tasks, -b)\n\n        if tasks:\n\n            # do task\n\n            ans -= heappop(tasks)\n\n\n\n    # print here\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n", "output": "A", "improve_diff": 1.0669207134, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\ny, k, d = list(map(int, input().split()))\n\nif y >= 0:\n\n    x = y\n\nelse:\n\n    x = -y\n\ni = math.floor(x / d)\n\nif i >= k:\n\n    p = x - k * d\n\nelif i == x / d:\n\n    if i + k == 2 * int((i + k) / 2):\n\n        p = 0\n\n    else:\n\n        p = d\n\nelse:\n\n    if (2 * i + 1) * d == 2 * x:\n\n        p = x - i * d\n\n    else:\n\n        if i + k == 2 * int((i + k) / 2):\n\n            p = x - i * d\n\n        else:\n\n            p = (i + 1) * d - x\n\nprint((int(p))) \nB. y, k, d = list(map(int, input().split()))\n\nx = abs(y)\n\ni = int(x / d)\n\nif i >= k:\n\n    p = x - k * d\n\nelif i == x / d:\n\n    if (i + k) % 2 == 0:\n\n        p = 0\n\n    else:\n\n        p = d\n\nelse:\n\n    if ((2 * i + 1) * d == 2 * x) or ((i + k) % 2 == 0):\n\n        p = x - i * d\n\n    else:\n\n        p = (i + 1) * d - x\n\nprint((int(p)))", "output": "B", "improve_diff": 1.2756241469, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nif n % 1000 == 0:\n\n    print((0))\n\nelse:\n\n    k = int(((n/1000)+1))*1000\n\n    print((k-n)) \nB. N = int(eval(input()))\n\nif N%1000 == 0:\n\n    print((0))\n\nelse:\n\n    Str = str(N)\n\n    if len(Str) > 3:\n\n        K = (int(Str[0]) + 1) * 1000\n\n        print((K - N))\n\n    else:\n\n        print((1000 - N))\n", "output": "B", "improve_diff": 1.0246582116, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from operator import itemgetter\n\nN, M = list(map(int, input().split()))\n\nab = [[0,0] for i in range(M)]\n\nfor i in range(M):\n\n    ab[i] = list(map(int, input().split()))\n\n\n\nab = sorted(ab, key=itemgetter(0,1))\n\n\n\nre = 1\n\nx, y = ab[0]\n\nfor i in range(1, M):\n\n    a, b = ab[i]\n\n    if b <= x or y <= a: # \n\n        re += 1\n\n        x, y = a, b\n\n    else:\n\n        x = max(x, 1)\n\n        y = min(y, b)\n\nprint(re) \nB. N, M = list(map(int, input().split()))\n\n\n\npair = []\n\nfor i in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    pair.append([b, a])\n\n\n\n# b\n\npair.sort()\n\n\n\nans = 1\n\ny, x = pair[0]\n\n\n\nfor i in range(1, M):\n\n    b, a = pair[i]\n\n    if y <= a:\n\n        y = b\n\n        ans += 1\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.1775597699, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nn,x = list(map(int,input().split()))\n\nxl = list(map(int,input().split()))\n\ndis = []\n\nans = 0\n\nfor i in range(n):\n\n  dis.append(abs(x-xl[i]))\n\nfor i in range(n):\n\n  ans = math.gcd(ans,dis[i])\n\nprint(ans) \nB. N,X = list(map(int,input().split()))\n\nx = list(map(int,input().split()))\n\nans = 0\n\nfrom math import gcd\n\nfor i in range(N):\n\n  ans = gcd(ans,abs(X-x[i]))\n\nprint(ans)", "output": "A", "improve_diff": 1.1242288765, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\nimport bisect\n\nimport heapq\n\nimport math\n\nimport random\n\nimport sys\n\nfrom collections import Counter, defaultdict, deque\n\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\n\nfrom functools import lru_cache, reduce\n\nfrom itertools import combinations, combinations_with_replacement, product, permutations\n\nfrom operator import add, mul, sub\n\n\n\nsys.setrecursionlimit(1000000)\n\ninput = sys.stdin.readline\n\nINF = 2**62-1\n\n\n\ndef read_int():\n\n    return int(input())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(input())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, input().split()))\n\n\n\n\n\ndef read_str():\n\n    return input().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return list(map(str, input().split()))\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\ndef is_lunlun(n):\n\n    s = str(n)\n\n    for i in range(len(s)-1):\n\n        if abs(int(s[i])-int(s[i+1])) > 1:\n\n            return False\n\n    return True\n\n\n\ndef slv(k):\n\n    if k <= 9:\n\n        return k\n\n    lunlun = list(range(1, 10))\n\n    q = deque(lunlun)\n\n\n\n    while True:\n\n        n = q.popleft()\n\n        for i in (-1, 0, 1):\n\n            d = n % 10\n\n            if 0 <= d + i <= 9:\n\n                l = n * 10 + d+i\n\n                q.append(l)\n\n                lunlun.append(l)\n\n                if len(lunlun) == k:\n\n                    return lunlun[-1]\n\n\n\n\n\n\n\n\n\ndef main():\n\n    K = read_int()\n\n    print(slv(K))\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. # -*- coding: utf-8 -*-\n\nimport bisect\n\nimport heapq\n\nimport math\n\nimport random\n\nimport sys\n\nfrom collections import Counter, defaultdict, deque\n\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\n\nfrom functools import lru_cache, reduce\n\nfrom itertools import combinations, combinations_with_replacement, product, permutations\n\nfrom operator import add, mul, sub\n\n\n\nsys.setrecursionlimit(1000000)\n\ninput = sys.stdin.readline\n\nINF = 2**62-1\n\n\n\ndef read_int():\n\n    return int(input())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(input())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, input().split()))\n\n\n\n\n\ndef read_str():\n\n    return input().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return list(map(str, input().split()))\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\ndef is_lunlun(n):\n\n    s = str(n)\n\n    for i in range(len(s)-1):\n\n        if abs(int(s[i])-int(s[i+1])) > 1:\n\n            return False\n\n    return True\n\n\n\ndef slv(k):\n\n    n = 1\n\n    for _ in range(k-1):\n\n        j = 0\n\n        while True:\n\n            l = 10**j\n\n            t = 0\n\n            t += n + l\n\n            t -= (n+l) % l\n\n            m = (t % (10**(j+1))) // l\n\n            # print(t, j, m)\n\n            for i in range(j-1, -1, -1):\n\n                t += (10 ** i) * max(0, m-(j-i))\n\n            # print(t, j)\n\n            if is_lunlun(t):\n\n                n = t\n\n                break\n\n            else:\n\n                j+=1\n\n            # if j > 5:\n\n            #     break\n\n        # print(n)\n\n    return n\n\n\n\n\n\n\n\ndef main():\n\n    K = read_int()\n\n    print(slv(K))\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 3.4874624052, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nnum = [0]*(10**6+1)\n\nfor a in A:\n\n    num[a] += 1\n\n\n\nbai = [False]*(10**6+1)\n\ncnt = 0\n\nA = list(set(A))\n\nA.sort()\n\nfor a in A:\n\n    if bai[a]:\n\n        continue\n\n\n\n    if num[a] == 1:\n\n        cnt += 1\n\n\n\n    for i in range(a, 10**6+1, a):\n\n        bai[i] = True\n\nprint(cnt) \nB. n = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA.sort()\n\n\n\nac = A.count(1)\n\nif ac == 1:\n\n    print((1))\n\n    exit()\n\nif ac >= 2:\n\n    print((0))\n\n    exit()\n\n\n\nnum = [0]*1000005\n\nfor a in A:\n\n    num[a] += 1\n\n\n\nb = [False]*1000005\n\nseen = [False]*1000005\n\ncnt = 0\n\nA = list(set(A))\n\nA.sort()\n\nfor a in A:\n\n    if seen[a]:\n\n        continue\n\n\n\n    seen[a] = True\n\n    if b[a] == False:\n\n        cnt += 1\n\n        if num[a] > 1:\n\n            cnt -= 1\n\n\n\n    for i in range(a, 1000005, a):\n\n        b[i] = True\n\nprint(cnt)\n", "output": "A", "improve_diff": 1.3623570185, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nn = int(eval(input()))\n\nnumeros = [int(x) for x in input().split()]\n\nsaida = sys.maxsize\n\n\n\nfor i in range(min(numeros), max(numeros)+1):\n\n\tvalor = 0\n\n\tfor j in numeros:\n\n\t\tvalor += (j-i)**2\n\n\t\n\n\tsaida = min(valor, saida)\n\n\n\nprint(saida)\n\n\n \nB. from math import ceil\n\n\n\nn = int(eval(input()))\n\nnumeros = [int(x) for x in input().split()]\n\nsaida = 2000000000000000\n\n\n\nfor i in range(min(numeros), max(numeros)+1):\n\n\tvalor = 0\n\n\tfor j in numeros:\n\n\t\tvalor += (j-i)**2\n\n\t\n\n\tsaida = min(valor, saida)\n\n\n\nprint(saida)\n\n\n\n\n", "output": "A", "improve_diff": 1.2914567786, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\n\n\ndef main():\n\n    A, B = list(map(int, input().split()))\n\n\n\n    # \n\n    x_min = max(math.ceil(A / 0.08), math.ceil(B / 0.1))\n\n    # \n\n    x_max = min((math.ceil((A + 1) / 0.08), math.ceil((B + 1) / 0.1)))\n\n\n\n    # \n\n    for x in range(x_min, x_max + 1):\n\n        if (math.floor(x * 0.08) == A) and (math.floor(x * 0.1) == B):\n\n            print(x)\n\n            quit()\n\n\n\n    # -1\n\n    print((-1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. from math import floor\n\n\n\n# \n\nA, B = list(map(int, input().split()))\n\n\n\n# \n\n# for _ in range(1010)\uff10\uff11\uff10\uff10\uff19\n\nfor price in range(1010):\n\n    if (floor(price * 0.08) == A) and (floor(price * 0.1) == B):\n\n        # \n\n        # \uff08\n\n        # \uff09\n\n        print(price)\n\n        quit()\n\n\n\n# \n\n# \n\n#  -1 \n\n# quit()\n\nprint((-1))\n", "output": "B", "improve_diff": 1.1424195725, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\ncur, nxt = [0] * 3, [0] * 3\n\nfor i in range(N):\n\n    abc = [int(c) for c in input().split()]\n\n    for k in range(3):\n\n        for last in range(3):\n\n            if k != last:\n\n                nxt[k] = max(nxt[k], cur[last] + abc[k])\n\n\n\n    cur = nxt\n\n    nxt = [0] * 3\n\n\n\nans = max(cur[k] for k in range(3))\n\nprint(ans)\n \nB. N = int(eval(input()))\n\nabc = []\n\nfor _ in range(N):\n\n    abc.append(tuple(map(int, input().split())))\n\n\n\ndp = [[0] * 3 for _ in range(N+1)]\n\nfor i in range(1, N+1):\n\n    for k in range(3):\n\n        for last in range(3):\n\n            if k != last:\n\n                dp[i][k] = max(dp[i][k], dp[i-1][last] + abc[i-1][last])\n\n\n\nans = max(dp[N][k] for k in range(3))\n\nprint(ans)\n", "output": "B", "improve_diff": 1.0499318603, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. i = 1\n\nwhile 1:\n\n\tx = eval(input())\n\n\tif x == 0:\n\n\t\tbreak\n\n\tprint('Case %d: %d' % (i, x))\n\n\ti+=1 \nB. i = 1\n\nwhile 1:\n\n\tx = input()\n\n\tif x == '0':\n\n\t\tbreak\n\n\tprint('Case %d: %s' % (i, x))\n\n\ti+=1", "output": "B", "improve_diff": 1.02341962, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\nINF = 10**18\n\n\n\nn,m,s,t = list(map(int,input().split()))\n\nedge = [list(map(int,input().split())) for _ in range(m)]\n\n\n\ngraph_s = [[] for _ in range(n)]\n\ngraph_t = [[] for _ in range(n)]\n\n\n\nfor e in edge:\n\n    graph_s[e[0]-1].append([e[1]-1,e[2]])\n\n    graph_s[e[1]-1].append([e[0]-1,e[2]])\n\n    graph_t[e[0]-1].append([e[1]-1,e[3]])\n\n    graph_t[e[1]-1].append([e[0]-1,e[3]])\n\n\n\ndist_s = [INF]*n\n\ndist_t = [INF]*n\n\n\n\ndist_s[s-1] = 0\n\ndist_t[t-1] = 0\n\n\n\nheap_s = [[0,s-1]]\n\nheapq.heapify(heap_s)\n\n\n\nheap_t = [[0,t-1]]\n\nheapq.heapify(heap_t)\n\n\n\nwhile heap_s:\n\n    cost,node = heapq.heappop(heap_s)\n\n    if dist_s[node] < cost:\n\n        continue\n\n    for adj,adjcost in graph_s[node]:\n\n        if dist_s[node] + adjcost < dist_s[adj]:\n\n            dist_s[adj] = dist_s[node] + adjcost\n\n            heapq.heappush(heap_s,[dist_s[adj],adj])\n\n\n\nwhile heap_t:\n\n    cost,node = heapq.heappop(heap_t)\n\n    if dist_t[node] < cost:\n\n        continue\n\n    for adj,adjcost in graph_t[node]:\n\n        if dist_t[node] + adjcost < dist_t[adj]:\n\n            dist_t[adj] = dist_t[node] + adjcost\n\n            heapq.heappush(heap_t,[dist_t[adj],adj])\n\n\n\ndist = INF\n\nans = []\n\n                                              \n\nfor i in range(n):\n\n    dist = min(dist,dist_t[-1-i]+dist_s[-1-i])\n\n    ans.append(10**15-dist)\n\n    \n\nfor i in range(n):\n\n    print((ans[-1-i])) \nB. from heapq import heappop, heappush, heapify\n\n\n\nclass Graph():  #non-directed\n\n    def __init__(self, n, edge, indexed=1):\n\n        self.n = n\n\n        self.edge = edge\n\n        self.indexed = indexed\n\n        self.graph = [[] for _ in range(n)]\n\n        for e in edge:\n\n            self.graph[e[0] - indexed].append((e[1] - indexed, e[2]))\n\n            self.graph[e[1] - indexed].append((e[0] - indexed, e[2]))\n\n\n\n    def dijkstra(self, s, INF=10**18, restore_to=None):\n\n        dist = [INF for _ in range(self.n)]\n\n        dist[s] = 0\n\n        heap = [(0, s)]\n\n        prev = [None for _ in range(self.n)]\n\n        while heap:\n\n            cost, node = heappop(heap)\n\n            if dist[node] < cost:\n\n                continue\n\n            for adj, adjcost in self.graph[node]:\n\n                if dist[node] + adjcost < dist[adj]:\n\n                    dist[adj] = dist[node] + adjcost\n\n                    prev[adj] = node\n\n                    heappush(heap, (dist[adj], adj))\n\n        if restore_to is not None:\n\n            g = restore_to\n\n            if dist[g] == INF:\n\n                return dist, False\n\n            path = [g]\n\n            node = g\n\n            while node != s:\n\n                node = prev[node]\n\n                path.append(node)\n\n            return dist, path[::-1]\n\n        return dist\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN, M, S, T = list(map(int, input().split()))\n\n\n\nE1 = []\n\nE2 = []\n\n\n\nfor _ in range(M):\n\n    u, v, a, b = list(map(int, input().split()))\n\n    E1.append((u, v, a))\n\n    E2.append((u, v, b))\n\n    \n\ng1 = Graph(N, E1)\n\ng2 = Graph(N, E2)\n\ndist_from_s = g1.dijkstra(S - 1)\n\ndist_from_t = g2.dijkstra(T - 1)\n\n\n\nres = list()\n\ntmp = 0\n\n\n\nfor i in range(N)[::-1]:\n\n    tmp = max(tmp, 10**15 - dist_from_t[i] - dist_from_s[i])\n\n    res.append(tmp)\n\n    \n\nprint(('\\n'.join(map(str, res[::-1]))))", "output": "A", "improve_diff": 1.0844978297, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nMAX = 10 ** 6 + 10\n\nmultiples = [0] * MAX\n\n\n\nfor a in list(set(A)):\n\n    for j in range(a * 2, MAX, a):\n\n        multiples[j] = 1\n\n\n\nd = Counter(A)\n\ndup = [k for k, v in list(d.items()) if v > 1]\n\nfor i in dup:\n\n    multiples[i] = 1\n\n\n\nans = 0\n\nfor i in A:\n\n    if multiples[i] == 0:\n\n        ans += 1\n\nprint(ans)\n \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nMAX = 10 ** 6 + 10\n\ncnt = [0] * MAX  # cnt11()\n\n\n\nfor a in A:\n\n    if cnt[a] != 0:\n\n        cnt[a] += 1\n\n        continue\n\n    for j in range(a, MAX, a):\n\n        cnt[j] += 1\n\nans = 0\n\nfor a in A:\n\n    if cnt[a] == 1:\n\n        ans += 1\n\nprint(ans)\n", "output": "A", "improve_diff": 1.0464415596, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X = int(eval(input()))\n\nif X == 7 or X == 5 or X == 3:\n\n    print('YES')\n\nelse:\n\n    print('NO') \nB. X = int(eval(input()))\n\n\n\nif X in (3, 5, 7):\n\n    print('YES')\n\n    \n\nelse:\n\n    print('NO')", "output": "B", "improve_diff": 1.0627060195, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    import itertools\n\n    N,M = list(map(int,input().split()))\n\n    A = list(map(int,input().split()))\n\n    acc = itertools.accumulate(A)\n\n    acc = [e % M for e in acc]\n\n    cnt_dict = {}\n\n    ans = 0\n\n    for e in acc:\n\n        if e == 0:\n\n            ans += 1\n\n        if e in cnt_dict:\n\n            cnt_dict[e] += 1\n\n        else:\n\n            cnt_dict[e] = 0\n\n        ans += cnt_dict[e]\n\n    print(ans)\n\n\n\nmain() \nB. import itertools\n\nN,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nacc = itertools.accumulate(A)\n\nacc = [e % M for e in acc]\n\ncnt_dict = {}\n\nans = 0\n\nfor e in acc:\n\n    if e == 0:\n\n        ans += 1\n\n    if e in cnt_dict:\n\n        cnt_dict[e] += 1\n\n    else:\n\n        cnt_dict[e] = 0\n\n    ans += cnt_dict[e]\n\nprint(ans)", "output": "B", "improve_diff": 1.0036985313, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn, m = list(map(int, input().split()))\n\nans = [0]*n\n\n\n\nfor _ in range(m):\n\n    l, r = list(map(int, input().split()))\n\n    ans[l-1] += 1\n\n    if r < n:\n\n        ans[r] -= 1\n\n\n\nc = list(np.cumsum(ans))\n\nprint((c.count(m))) \nB. n, m = list(map(int, input().split()))\n\nlrl = list(list(map(int, input().split())) for _ in range(m))\n\nlmax = 0\n\nrmin = n\n\n\n\nfor lr in lrl:\n\n    if lr[0] > lmax:\n\n        lmax = lr[0]\n\n    if lr[1] < rmin:\n\n        rmin = lr[1]\n\nif lmax <= rmin:\n\n    print((rmin-lmax+1))\n\nelse:\n\n    print((0))\n\n\n\n\n\n\n", "output": "B", "improve_diff": 9.196347792, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. \n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nA.sort()\n\n\n\nl = 0\n\nsize = 0\n\n\n\nfor i in range(N - 1):\n\n    size += A[i]\n\n\n\n    if A[i + 1] > 2 * size:\n\n        l = i + 1\n\n\n\nans = N - l\n\n\n\nprint(ans) \nB. \n\ndef paku(N, A, mid):\n\n    if mid == 0:\n\n        return False\n\n\n\n    size = sum(A[:mid])\n\n\n\n    for i in range(mid, N):\n\n        if A[i] <= 2*size:\n\n            size += A[i]\n\n        else:\n\n            return False\n\n\n\n    return True\n\n\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nA.sort()\n\n\n\ntop = N\n\nbtm = 0\n\n\n\nwhile top - btm > 1:\n\n    mid = (top + btm) // 2\n\n\n\n    if paku(N, A, mid):\n\n        top = mid\n\n    else:\n\n        btm = mid\n\n\n\nans = N - top + 1\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.016585313, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #https://atcoder.jp/contests/dp/tasks/dp_e\n\n#2019-01-13\n\nimport numpy as np\n\nN, W = list(map(int, input().split()))\n\nw, v = [], []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w += [a]\n\n    v += [b]\n\n\n\nDP = np.ones(N*1000+1, dtype=int) *(W+1)\n\nDP[0] = 0\n\n# i \n\nfor i in range(N):\n\n    DP[v[i]:] = np.minimum(DP[:-v[i]]+ w[i], DP[v[i]:])\n\nans = 0\n\nfor k in range(N*1000+1):\n\n    if DP[k] <= W:\n\n        ans = k\n\n        \n\nprint(ans) \nB. #https://atcoder.jp/contests/dp/tasks/dp_e\n\n#2019-01-13\n\nN, W = list(map(int, input().split()))\n\nw, v = [], []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w += [a]\n\n    v += [b]\n\n\n\nDP = [float(\"inf\")] * (N*1000+1)\n\nDP[0] = 0\n\n# i \n\nfor i in range(N):\n\n    for j in range(N*1000,-1,-1):\n\n        DP[j] = min(DP[j- v[i]] + w[i], DP[j])\n\nans = 0\n\nfor k in range(N*1000+1):\n\n    if DP[k] <= W:\n\n        \n\n        ans = k\n\nprint(ans)", "output": "B", "improve_diff": 6.5681079865, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #S = str(input())\n\nA, B, C, K = list(map(int,input().split()))\n\n\n\nif A <= K:\n\n    a = A\n\nelse:\n\n    a = K\n\n\n\nif B <= K-a:\n\n    b = B\n\nelse:\n\n    b = K-a\n\n\n\nc = K - a - b\n\n\n\nans = a - c\n\nprint(ans) \nB. a, b, c, k = list(map(int, input().split()))\n\n\n\n\n\nxa = min(k,a)\n\nxb = min(k-xa,b)\n\nxc = k- xa - xb\n\n\n\nprint((xa - xc))\n", "output": "B", "improve_diff": 1.0118972467, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. a, b = list(map(int, input().split()))\n\nprint((max([a+b, 2*a-1, 2*b-1])))\n \nB. import heapq\n\na, b = list(map(int, input().split()))\n\nprint((sum(heapq.nlargest(2, [a, a-1, b, b-1]))))\n", "output": "A", "improve_diff": 1.3129923202, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. *x,=list(map(int,input().split()));print((sum(x)+max(x)*9)) \nB. a, b, c = sorted(map(int, input().split()))\n\nprint((c*10+a+b))", "output": "A", "improve_diff": 1.0313808686, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nM = list(map(int, input().split()))\n\n\n\ncombinations = {}\n\n\n\ndef create_combinations(idx, sum):\n\n    combinations[sum] = 1\n\n    if idx >= N:\n\n        return\n\n    create_combinations(idx+1, sum)\n\n    create_combinations(idx+1, sum+A[idx])\n\n    return\n\n\n\ncreate_combinations(0, 0)\n\n\n\nfor target in M:\n\n    if target in list(combinations.keys()):\n\n        print(\"yes\")\n\n    else:\n\n        print(\"no\")\n \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nM = list(map(int, input().split()))\n\n\n\nexhaustive_dict = {}\n\n\n\ndef create_exhastive_list(head, sum):\n\n    for i in range(head, N):\n\n        sum += A[i]\n\n        exhaustive_dict[sum] = 1\n\n        create_exhastive_list(i+1, sum)\n\n        sum -= A[i]\n\n\n\nhead = 0\n\nsum = 0\n\ncreate_exhastive_list(head, sum)\n\n\n\nfor target in M:\n\n    if target in list(exhaustive_dict.keys()):\n\n        print(\"yes\")\n\n    else:\n\n        print(\"no\")\n", "output": "B", "improve_diff": 1.0114422636, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import numpy as np\n\nn = eval(input())\n\nw = list(map(int, input().split()))\n\nw = np.array(w)\n\nprint((np.min(np.abs(2 * np.cumsum(w) -np.sum(w))))) \nB. n = int(eval(input()))\n\nw = list(map(int, input().split()))\n\nans = sum(w)\n\nfor i in range(1,n):\n\n    ans = min(ans,abs(sum(w[:i + 1]) - sum(w[i +1:])))\n\nprint(ans)", "output": "B", "improve_diff": 9.0717495332, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def nap(n,cap):\n\n    val = [0]*(cap+1)\n\n    for _ in range(n):\n\n        w,v = list(map(int,input().split()))\n\n        for k in range(cap,w-1,-1):\n\n            nv=val[k-w]+v\n\n            if val[k]<nv:\n\n                val[k]=nv\n\n    return max(val)\n\n\n\nn,cap=list(map(int,input().split()))\n\nprint((nap(n,cap)))\n \nB. n,m=list(map(int,input().split()))\n\ndp=[[0]*(m+1) for _ in range(n+1)]\n\n\n\nfor i in range(1,n+1):\n\n    w,v=list(map(int,input().split()))\n\n    dp[i][w]=max(dp[i-1][w],v)\n\n    for j in range(m+1):\n\n        if dp[i-1][j]==0:\n\n            continue\n\n        if j+w<=m:\n\n            dp[i][j+w]=max(dp[i][j+w],dp[i-1][j]+v)\n\n\n\n        dp[i][j]=max(dp[i-1][j],dp[i][j])\n\n\n\n\n\nprint((max(dp[n])))\n", "output": "A", "improve_diff": 1.0398977602, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,M = list(map(int, input().split()))\n\np = 1/2 \n\nprint(((1900*M+100*(N-M))*2**M))\n \nB. from math import factorial\n\n\n\ndef combination(n, r):\n\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\n\n\nn, m = list(map(int, input().split()))\n\nt = 100*(n-m) + m*1900 # 1\n\nrs = [0.5**m * ( 1- 0.5**m)**i for i in range(int(1e4))]\n\nans = 0.0\n\n\n\nfor i,r in enumerate(rs):\n\n    ans += ((i+1)*t)*r \n\n    \n\nprint((round(ans)))", "output": "A", "improve_diff": 1.7287596106, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\nN, M, *L = list(map(int, open(0).read().split()))\n\ndic = [[] for i in range(N+1)]\n\nllog = set()\n\nrlog = set()\n\nfor l,r,d in zip(*[iter(L)]*3):\n\n  dic[l].append((r,d))\n\n  llog.add(l)\n\n  rlog.add(r)\n\nlog = llog.difference(rlog)\n\nq = deque(log)\n\ndist = [-1]*(N+1)\n\nfor c in log:\n\n  dist[c] = 0\n\nwhile q:\n\n  v = q.popleft()\n\n  flag = False\n\n  for u,d in dic[v]:\n\n    if dist[u]==-1:\n\n      dist[u] = dist[v]+d\n\n      q.append(u)\n\n    elif dist[u]!=dist[v]+d:\n\n      print('No')\n\n      flag = True\n\n      break\n\n  if flag:\n\n    break\n\nelse:\n\n  U = llog.union(rlog)\n\n  for c in U:\n\n    if dist[c]==-1:\n\n      print('No')\n\n      break\n\n  else:\n\n    print('Yes') \nB. from collections import defaultdict, deque\n\nN, M = list(map(int, input().split()))\n\nused = [True]*N\n\ndic = defaultdict(list)\n\nfor i in range(M):\n\n  l, r, d = list(map(int,input().split()))\n\n  l -= 1\n\n  r -= 1\n\n  used[r] = False\n\n  dic[l] += [(r,d)]\n\n\n\ndist = [-1]*N\n\nq = deque([])\n\nfor i in range(N):\n\n  if used[i]:\n\n    q += [i]\n\n    dist[i] = 0\n\n\n\nans = True\n\nwhile q:\n\n  e = q.popleft()\n\n  flag = False\n\n  for p, d in dic[e]:\n\n    if dist[p]==-1:\n\n      dist[p] = d+dist[e]\n\n      q += [p]\n\n    elif dist[p]!=dist[e]+d:\n\n      ans = False\n\n      flag = True\n\n      break\n\n  if flag:\n\n    break\n\nif ans:\n\n  if -1 not in dist:\n\n    print('Yes')\n\n  else:\n\n    print('No')\n\nelse:\n\n  print('No')", "output": "A", "improve_diff": 1.0146026027, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. h,n = list(map(int,input().split()))\n\nsp = list(map(int,input().split())) \n\nif h > sum(sp):\n\n  print('No')\n\nelse:\n\n  print('Yes')\n \nB. h,n = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\nif sum(a) >= h:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")\n", "output": "A", "improve_diff": 1.0455250298, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # E - Coprime\n\nfrom math import gcd\n\n\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nA = sorted(A)\n\nMAX = 10**6\n\nL = [0]*(MAX+1)\n\n\n\ndef prime(x):\n\n    global L\n\n    p = 2\n\n    while x>1:\n\n        if L[x]==1:\n\n            return False\n\n        if x%p==0:\n\n            while x%p==0:\n\n                x //= p\n\n            tmp = p\n\n            while tmp<=MAX:\n\n                L[tmp] = 1\n\n                tmp += p\n\n        p = p+1 if p*p<x else x   \n\n    return True\n\n        \n\nG = A[0]\n\npairwise = True\n\n_ = prime(A[0])\n\n\n\nfor i in range(1,N):\n\n    a = A[i]\n\n    if pairwise:\n\n        pairwise = prime(a)\n\n    G = gcd(G,a)\n\n\n\nif pairwise:\n\n    print('pairwise coprime')\n\nelif G==1:\n\n    print('setwise coprime')\n\nelse:\n\n    print('not coprime') \nB. # E - Coprime\n\nfrom math import gcd\n\n\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nMAX = 10**6\n\np = [0]*(MAX+1)\n\n\n\nfor i in range(2,MAX+1):\n\n    if p[i]>0:\n\n        continue\n\n    tmp = i\n\n    while tmp<=MAX:\n\n        p[tmp] = i\n\n        tmp += i\n\n\n\npairwise = True\n\ng = -1\n\nq = [-1]*(MAX+1)\n\n\n\nfor i in range(N):\n\n    a = A[i]\n\n    g = a if g<0 else gcd(g,a)\n\n    while pairwise and a>1:\n\n        pairwise = True if q[p[a]] in [-1,i] else False\n\n        q[p[a]] = i\n\n        a //= p[a]\n\n\n\nif pairwise:\n\n    print('pairwise coprime')\n\nelif g==1:\n\n    print('setwise coprime')\n\nelse:\n\n    print('not coprime')", "output": "A", "improve_diff": 5.5466776309, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,K = list(map(int,input().split()))\n\nif K%2==1:\n\n    n = N//K\n\n    ans = n**3\n\nelse:\n\n    n1 = N//K\n\n    n2 = 1+(N-K//2)//K\n\n    ans = n1**3+n2**3\n\nprint(ans) \nB. N,K = list(map(int,input().split()))\n\nL = N//K\n\nif K%2==1:\n\n    print((L**3))\n\nelse:\n\n    M = N//(K//2)\n\n    M -= L\n\n    print((L**3+M**3))", "output": "A", "improve_diff": 1.0455731691, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\n\n\ncnt = 0\n\ndef dfs(s):\n\n    global cnt\n\n    if '3' in s and '5' in s and '7' in s and int(s) <= N:\n\n        cnt += 1\n\n    if len(s) >= 10:\n\n        return cnt\n\n    dfs(s + '3')\n\n    dfs(s + '5')\n\n    dfs(s + '7')\n\n    return cnt\n\n\n\nprint((dfs(''))) \nB. from itertools import product\n\nN = int(eval(input()))\n\nans = 0\n\nfor l in range(1, 11):\n\n    for p in product(\"357\", repeat=l):\n\n        v = \"\".join(p)\n\n        if \"3\" in v and \"5\" in v and \"7\" in v and int(\"\".join(p)) <= N:\n\n            ans += 1\n\nprint(ans)", "output": "A", "improve_diff": 1.6900607879, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())),reverse=True)\n\nB = sorted(list(map(int, input().split())),reverse=True)\n\nC = sorted(list(map(int, input().split())),reverse=True)\n\n\n\nans = []\n\nfor x in range(X):\n\n    if x+1 > K:\n\n        break\n\n    for y in range(Y):\n\n        if (x+1) * (y+1) > K:\n\n            break\n\n        for z in range(Z):\n\n            if (x+1) * (y+1) * (z+1) > K:\n\n                break\n\n\n\n            value = A[x] + B[y] + C[z]\n\n            ans.append(value)\n\n\n\nans.sort(reverse=True)\n\nfor i in range(K):\n\n    print((ans[i]))\n \nB. import heapq\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())),reverse=True)\n\nB = sorted(list(map(int, input().split())),reverse=True)\n\nC = sorted(list(map(int, input().split())),reverse=True)\n\n\n\nused = set()\n\ncandidate = []\n\nheapq.heappush(candidate, (-A[0]-B[0]-C[0], 0, 0, 0))\n\n\n\nfor _ in range(K):\n\n    value, x, y, z = heapq.heappop(candidate)\n\n    print((-value))\n\n\n\n    if x+1 < X and (x+1, y, z) not in used:\n\n        heapq.heappush(candidate, (-A[x+1]-B[y]-C[z], x+1, y, z))\n\n        used.add((x+1, y, z))\n\n\n\n    if y+1 < Y and (x, y+1, z) not in used:\n\n        heapq.heappush(candidate, (-A[x]-B[y+1]-C[z], x, y+1, z))\n\n        used.add((x, y+1, z))\n\n\n\n    if z+1 < Z and (x, y, z+1) not in used:\n\n        heapq.heappush(candidate, (-A[x]-B[y]-C[z+1], x , y, z+1))\n\n        used.add((x, y, z+1))", "output": "A", "improve_diff": 1.3661936194, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n# \n\n# a[i] < a[i+1]\n\n# a[i] > a[i+1]\n\n\n\nmoney = 1000\n\nstock = 0\n\nfor i in range(n):\n\n    if i == n-1 or a[i] > a[i+1]:\n\n        money += stock * a[i]\n\n        stock = 0\n\n    elif money > a[i]:\n\n        stock = money // a[i]\n\n        money = money % a[i]\n\n\n\nprint(money) \nB. n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n# DP\n\n# dp[i]: i\uff08\uff09\n\ndp = [0] * n\n\ndp[0] = 1000\n\n\n\n# dp[1] = 01 or 0\n\n# dp[2] = 0 or 12 or 1\n\n# dp[i+1] + 0~ii+1 or i\n\nfor i in range(n):\n\n    if i == 0:\n\n        dp[i] = 1000\n\n        continue\n\n    \n\n    dp[i] = dp[i-1]\n\n    for j in range(i):\n\n        # ji\n\n        dp[i] = max(dp[i], (dp[j] // a[j]) * a[i] + dp[j] % a[j])\n\n    \n\nprint((dp[n-1]))", "output": "B", "improve_diff": 1.040194353, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nse = set()\n\ndic = dict()\n\n\n\nfor i in range(N):\n\n    if A[i] in se:\n\n        dic[A[i]] += 1\n\n    else:\n\n        se.add(A[i])\n\n        dic.update({A[i]: 1})\n\n\n\nc = 0\n\nfor k in list(dic.keys()):\n\n    c += (dic[k])*(dic[k]-1)//2\n\n\n\nresult = [0]*N\n\nfor i in range(N):\n\n    result[i] = c - (dic[A[i]])*(dic[A[i]]-1)//2 + (dic[A[i]]-1)*(dic[A[i]]-2)//2\n\n\n\nprint((\"\\n\".join(list(map(str, result)))))\n \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nse = set()\n\ndic = dict()\n\n\n\nfor i in range(N):\n\n    if A[i] in se:\n\n        dic[A[i]] += 1\n\n    else:\n\n        se.add(A[i])\n\n        dic.update({A[i]: 1})\n\n\n\nc = 0\n\nfor k in list(dic.keys()):\n\n    c += (dic[k])*(dic[k]-1)//2\n\n\n\nfor i in range(N):\n\n    print((c - dic[A[i]]+1))\n", "output": "B", "improve_diff": 1.0078282848, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [None] * N\n\nB = [None] * N\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    A[i] = a\n\n    B[i] = b\n\n\n\nA.sort()\n\nB.sort()\n\n\n\nif N % 2 == 0:\n\n    b = (B[N // 2] + B[(N - 1) // 2]) / 2\n\n    a = (A[N // 2] + A[(N - 1) // 2]) / 2\n\n    print((int((b - a) * 2 + 1)))\n\nelse:\n\n    print((B[N // 2] - A[N // 2] + 1))\n \nB. from sys import stdin\n\nreadline = stdin.readline\n\n\n\nN = int(readline())\n\nA = [None] * N\n\nB = [None] * N\n\nfor i in range(N):\n\n    a, b = list(map(int, readline().split()))\n\n    A[i] = a\n\n    B[i] = b\n\n\n\nA.sort()\n\nB.sort()\n\n\n\nif N % 2 == 0:\n\n    b = (B[N // 2] + B[(N - 1) // 2]) / 2\n\n    a = (A[N // 2] + A[(N - 1) // 2]) / 2\n\n    print((int((b - a) * 2 + 1)))\n\nelse:\n\n    print((B[N // 2] - A[N // 2] + 1))\n", "output": "A", "improve_diff": 1.087504061, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    from math import gcd\n\n    _ = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n\n\n    class osa_k:\n\n        def __init__(self, sup):\n\n            if sup > 2 * 10**8:\n\n                raise RuntimeError(\"too big\")\n\n            self.MINFact = [-1] * (sup + 1)\n\n            self.MINFact[0] = 0\n\n            self.MINFact[1] = 1\n\n            primes = [True for i in range(sup+1)]\n\n            primes[0] = False\n\n            primes[1] = False\n\n            for i in range(2, sup+1):\n\n                if primes[i]:\n\n                    self.MINFact[i] = i\n\n                    mul = 2\n\n                    while i*mul <= sup:\n\n                        primes[i*mul] = False\n\n                        if self.MINFact[i*mul] == -1:\n\n                            self.MINFact[i*mul] = i\n\n                        mul += 1\n\n\n\n        def prime_factor(self, n, B):\n\n            while n > 1:\n\n                prime = self.MINFact[n]\n\n                while self.MINFact[n] == prime:\n\n                    n //= prime\n\n                B[prime] += 1\n\n\n\n    maxA = max(A)\n\n    p = osa_k(maxA)\n\n    B = [0] * (maxA + 1)\n\n    for a in A:\n\n        p.prime_factor(a, B)\n\n\n\n    g = A[0]\n\n    for a in A:\n\n        g = gcd(g, a)\n\n\n\n    if g != 1:\n\n        print(\"not coprime\")\n\n    elif max(B) <= 1:\n\n        print(\"pairwise coprime\")\n\n    else:\n\n        print(\"setwise coprime\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. def main():\n\n    from math import gcd\n\n    MINFact = [-1] * (10**6 + 10)\n\n    MINFact[0] = 0\n\n    MINFact[1] = 1\n\n\n\n    def Eratosthenes(sup: int) -> set:\n\n        primes = [True for i in range(sup+1)]\n\n        primes[0] = False\n\n        primes[1] = False\n\n        for i in range(2, sup+1):\n\n            if primes[i]:\n\n                MINFact[i] = i\n\n                mul = 2\n\n                while i*mul <= sup:\n\n                    primes[i*mul] = False\n\n                    if MINFact[i*mul] == -1:\n\n                        MINFact[i*mul] = i\n\n                    mul += 1\n\n\n\n    def prime_factor(n):\n\n        while n != 1:\n\n            prime = MINFact[n]\n\n            while MINFact[n] == prime:\n\n                n //= prime\n\n            B[prime] += 1\n\n\n\n    _ = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    g = A[0]\n\n    for a in A:\n\n        g = gcd(g, a)\n\n    Eratosthenes(10**6 + 5)\n\n    B = [0]*(10**6 + 5)\n\n    for a in A:\n\n        prime_factor(a)\n\n    # B\n\n    # 1 gcd != 1 \n\n    if g != 1:\n\n        print(\"not coprime\")\n\n    elif max(B) <= 1:\n\n        print(\"pairwise coprime\")\n\n    else:\n\n        print(\"setwise coprime\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 30.8071937785, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. print((15 - sum([*list(map(int, input().split()))])))\n \nB. X = [*list(map(int, input().split()))]\n\nfor i in range(len(X)):\n\n    if X[i] == 0: print((i+1))\n", "output": "B", "improve_diff": 1.0263338295, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict, deque\n\nimport sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\n\nedges = [list(range(N)) for i in range(N)]\n\nfor i in range(N):\n\n    edges[i].remove(i)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges[a-1].remove(b-1)\n\n    edges[b-1].remove(a-1)\n\nsize = defaultdict(lambda: [0, 0])\n\ncolor = [-1]*N\n\ndef set_color(root):\n\n    \n\n    que = deque([root])\n\n    color[root] = 0\n\n    size[root][0]+=1\n\n    while que:\n\n        v = que.pop()\n\n        for nv in edges[v]:\n\n            if color[nv]<0:\n\n                c = 1- color[v]\n\n                color[nv] = c\n\n                size[root][c]+=1\n\n                que.append(nv)\n\n            elif color[nv] == color[v]:\n\n                print((-1))\n\n                sys.exit()\n\nfor i in range(N):\n\n    if color[i]<0:\n\n        set_color(i)\n\nS = set([0])\n\nfor a, b in list(size.values()):\n\n    S = set(s+b for s in S)|set(s+a for s in S)\n\nans = min(x*(x-1)//2+(N-x)*(N-x-1)//2 for x in S)            \n\nprint(ans)                 \nB. from collections import defaultdict, deque\n\nimport sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\n\nedges = [set(range(N)) for i in range(N)]\n\nfor i in range(N):\n\n    edges[i].remove(i)\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges[a-1].remove(b-1)\n\n    edges[b-1].remove(a-1)\n\nsize = defaultdict(lambda: [0, 0])\n\ncolor = [-1]*N\n\ndef set_color(root):\n\n    \n\n    que = deque([root])\n\n    color[root] = 0\n\n    size[root][0]+=1\n\n    while que:\n\n        v = que.pop()\n\n        for nv in edges[v]:\n\n            if color[nv]<0:\n\n                c = 1- color[v]\n\n                color[nv] = c\n\n                size[root][c]+=1\n\n                que.append(nv)\n\n            elif color[nv] == color[v]:\n\n                print((-1))\n\n                sys.exit()\n\nfor i in range(N):\n\n    if color[i]<0:\n\n        set_color(i)\n\nS = set([0])\n\nfor a, b in list(size.values()):\n\n    S = set(s+b for s in S)|set(s+a for s in S)\n\nans = min(x*(x-1)//2+(N-x)*(N-x-1)//2 for x in S)            \n\nprint(ans)                ", "output": "B", "improve_diff": 1.0065619848, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nh=list(map(int,input().split()))\n\ndp=[10**9]*n\n\n\n\ndp[0]=0\n\ndp[1]=h[1]-h[0]\n\nfor i in range(1,n):\n\n    c1=abs(h[i]-h[i-1])\n\n    c2=abs(h[i]-h[i-2])\n\n    dp[i]=min(dp[i-1]+c1,dp[i-2]+c2)\n\n    \n\nprint((dp[n-1])) \nB. N = int(eval(input()))\n\nH = list(map(int, input().split()))\n\n\n\ndp = [0] * N\n\ndp[1] = abs(H[1] - H[0])\n\n\n\nfor i in range(2, N):\n\n\tdp[i] = min(dp[i - 1] + abs(H[i] - H[i - 1]), dp[i - 2] + abs(H[i] - H[i - 2]))\n\nprint((dp[-1]))", "output": "B", "improve_diff": 1.0898097582, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nS = ''\n\n\n\nfor i in range(n):\n\n    S += input()[0]\n\n    \n\nm = S.count('M')\n\na = S.count('A')\n\nr = S.count('R')\n\nc = S.count('C')\n\nh = S.count('H')\n\n\n\nprint((m*a*r + m*a*c + m*a*h + m*r*c + m*r*h + m*c*h + a*r*c + a*r*h + a*c*h + r*c*h)) \nB. from collections import Counter\n\nn = int(eval(input()))\n\nA = [input()[0] for i in range(n)]\n\n\n\nA = Counter(A)\n\nm = A['M']\n\na = A['A']\n\nr = A['R']\n\nc = A['C']\n\nh = A['H']\n\n\n\nprint((m*a*r + m*a*c + m*a*h + m*r*c + m*r*h + m*c*h + a*r*c + a*r*h + a*c*h + r*c*h))", "output": "A", "improve_diff": 1.4214172936, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,k = list(map(int,input().split()))\n\nn_lst = list(map(int,input().split())) \n\ncnt_lst = [0 for _ in range(n+1)]\n\n\n\nfor x in n_lst:\n\n    cnt_lst[x] += 1\n\ncnt_lst.sort(reverse=True)\n\nprint((sum(cnt_lst[k:])))\n \nB. from collections import Counter\n\n\n\nn,k = list(map(int,input().split()))\n\nn_lst = list(map(int,input().split()))\n\n\n\ncnt_lst = Counter(n_lst).most_common()[k:]\n\nans = 0\n\nfor x in cnt_lst:\n\n    ans += x[1]\n\nprint(ans)\n", "output": "A", "improve_diff": 1.3854425157, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A, B, Q = list(map(int, input().split()))\n\nINF = 10 ** 18\n\nS = [-INF] + [int(eval(input())) for _ in range(A)] + [INF]\n\nT = [-INF] + [int(eval(input())) for _ in range(B)] + [INF]\n\nX = [int(eval(input())) for _ in range(Q)]\n\n\n\n\n\ndef binary_search(q, A):\n\n    l, r = 0, len(A)\n\n    while r - l > 1:\n\n        mid = (l + r) // 2\n\n        if q > A[mid]:\n\n            l = mid\n\n        else:\n\n            r = mid\n\n    return A[l], A[r]\n\n\n\n\n\ndef main():\n\n    for x in X:\n\n        s1, s2 = binary_search(x, S)\n\n        t1, t2 = binary_search(x, T)\n\n        print((min(abs(s-t) + min(abs(s-x), abs(t-x)) for s in [s1, s2] for t in [t1, t2])))\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import sys\n\nimport bisect\n\n\n\nA, B, Q = list(map(int, sys.stdin.readline().split()))\n\nINF = 10 ** 18\n\nS = [-INF] + [int(sys.stdin.readline()) for _ in range(A)] + [INF]\n\nT = [-INF] + [int(sys.stdin.readline()) for _ in range(B)] + [INF]\n\nX = [int(sys.stdin.readline()) for _ in range(Q)]\n\n\n\n\n\n# def binary_search(q, A):\n\n#     l, r = 0, len(A)\n\n#     while r - l > 1:\n\n#         mid = (l + r) // 2\n\n#         if q > A[mid]:\n\n#             l = mid\n\n#         else:\n\n#             r = mid\n\n#     return A[l], A[r]\n\n\n\n\n\ndef main():\n\n    for x in X:\n\n        ids, idt = bisect.bisect_right(S, x), bisect.bisect_right(T, x)\n\n        print((min(abs(s-t) + min(abs(s-x), abs(t-x)) for s in S[ids-1:ids+1] for t in T[idt-1:idt+1])))\n\n    return\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 1.2451799531, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N, Ma, Mb = list(map(int, input().split()))\n\n\n\nINF = 10 ** 8\n\n\n\nlst = [[INF] * 401 for i in range(401)]\n\nlst[0][0] = 0\n\n\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    for i in range(400, a - 1, -1):\n\n        for j in range(400, b - 1, -1):\n\n            if lst[i- a][j - b] == INF:\n\n                pass\n\n            else:\n\n                lst[i][j] = min(lst[i][j], lst[i - a][j - b] + c)\n\n\n\nans = INF\n\nn = 400 // max(Ma, Mb)\n\nfor i in range(1, n + 1):\n\n    ans = min(ans, lst[Ma * i][Mb * i])\n\n\n\nif ans == INF:\n\n    print((-1))\n\nelse:\n\n    print (ans)\n\n\n\n# for i in range(7):\n\n#     print (lst[i][:7]) \nB. #masoy\n\n\n\nimport numpy as np\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nU = N * 10\n\n\n\ndp = np.zeros((U + 1, U + 1), dtype = np.int64)\n\ntemp = np.zeros_like(dp)\n\n\n\nINF = 10 ** 18\n\ndp += INF\n\ndp[0, 0] = 0\n\n\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    temp[:] = dp.copy()\n\n    temp[a:, b:] = np.minimum(temp[a:, b:], dp[:-a, :-b] + c)\n\n    dp = temp #\n\n\n\nanswer = INF\n\nfor t in range(1, 401):\n\n    a = Ma * t\n\n    b = Mb * t\n\n    if max(a, b) >= U: #\n\n        break\n\n    answer = min(answer, dp[a, b])\n\n\n\nif answer == INF:\n\n    answer = -1\n\n\n\nprint (answer)\n", "output": "A", "improve_diff": 5.2841791924, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,Q = list(map(int,input().split()))\n\nBIT = [0]*(N+1)\n\n\n\ndef BIT_query(idx):\n\n    res_sum = 0\n\n    while idx > 0:\n\n        res_sum += BIT[idx]\n\n        idx -= idx&(-idx)\n\n    return res_sum\n\n\n\ndef BIT_update(idx,x):\n\n    while idx <= N:\n\n        BIT[idx] += x\n\n        idx += idx&(-idx)\n\n    return\n\n\n\na = list(map(int,input().split()))\n\nfor i in range(N):\n\n    BIT_update(i+1,a[i])\n\n\n\nfor i in range(Q):\n\n    a,b,c = list(map(int,input().split()))\n\n    if a == 0:\n\n        BIT_update(b+1,c)\n\n    else:\n\n        print((BIT_query(c)-BIT_query(b)))\n \nB. import sys\n\ninput = sys.stdin.buffer.readline\n\nN,Q = list(map(int,input().split()))\n\nBIT = [0]*(N+1)\n\n\n\ndef BIT_query(idx):\n\n    res_sum = 0\n\n    while idx > 0:\n\n        res_sum += BIT[idx]\n\n        idx -= idx&(-idx)\n\n    return res_sum\n\n\n\ndef BIT_update(idx,x):\n\n    while idx <= N:\n\n        BIT[idx] += x\n\n        idx += idx&(-idx)\n\n    return\n\n\n\na = list(map(int,input().split()))\n\nfor i in range(N):\n\n    BIT_update(i+1,a[i])\n\n\n\nfor i in range(Q):\n\n    a,b,c = list(map(int,input().split()))\n\n    if a == 0:\n\n        BIT_update(b+1,c)\n\n    else:\n\n        print((BIT_query(c)-BIT_query(b)))\n", "output": "A", "improve_diff": 1.0140384511, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,K = list(map(int,input().split()))\n\nH = list(map(int,input().split()))\n\n\n\nINF = 10 ** 9 + 1\n\ndp = [INF] * N\n\ndp[0] = 0\n\n\n\nfor i in range(1, N):\n\n  dp[i] = min(pre + abs(h - H[i]) for pre,h in zip(dp[max(0,i - K):i],H[max(0,i - K):i]))\n\n\n\nprint((dp[-1])) \nB. N,K = list(map(int,input().split()))\n\nimport numpy as np\n\nH = np.array(input().split(), dtype = int)\n\n\n\nINF = 10 ** 9 + 1\n\ndp = np.full(N,INF,dtype = int)\n\ndp[0] = 0\n\n\n\nfor i in range(1, N):\n\n  dp[i] = min(dp[max(i - K,0):i] + abs(H[max(i - K,0):i] - H[i]))\n\n\n\nprint((dp[-1]))", "output": "A", "improve_diff": 23.3350870023, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import defaultdict, deque\n\nN, M, *L = list(map(int, open(0).read().split()))\n\ndic = defaultdict(list)\n\npar =  [0]*N\n\ncnt = [0]*(N+1)\n\nfor a,b in zip(*[iter(L)]*2):\n\n  dic[a] += [b]\n\n  cnt[b] += 1\n\n\n\nfor i in range(1,N+1):\n\n  if cnt[i]==0:\n\n    q = deque([i])\n\n    par[i-1] = '0'\n\n    break\n\n  \n\nwhile q:\n\n  m = q.popleft()\n\n  for c in dic[m]:\n\n    cnt[c] -= 1\n\n    if cnt[c]==0:\n\n      par[c-1] = str(m)\n\n      q += [c]\n\n\n\nans = '\\n'.join(par)\n\nprint(ans) \nB. from collections import defaultdict, deque\n\ndef main():\n\n  N, M, *L = list(map(int, open(0).read().split()))\n\n  dic = defaultdict(list)\n\n  par =  [0]*N\n\n  cnt = [0]*(N+1)\n\n  for a,b in zip(*[iter(L)]*2):\n\n    dic[a] += [b]\n\n    cnt[b] += 1\n\n\n\n  for i in range(1,N+1):\n\n    if cnt[i]==0:\n\n      q = deque([i])\n\n      par[i-1] = '0'\n\n      break\n\n  \n\n  while q:\n\n    m = q.popleft()\n\n    for c in dic[m]:\n\n      cnt[c] -= 1\n\n      if cnt[c]==0:\n\n        par[c-1] = str(m)\n\n        q += [c]\n\n\n\n  ans = '\\n'.join(par)\n\n  print(ans)\n\n  \n\nif __name__== '__main__':\n\n  main()", "output": "B", "improve_diff": 1.0273269959, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    n = int(eval(input()))\n\n    dices=[]\n\n    same = 0\n\n    for _ in range(n):\n\n        dices.append(list(map(int, input().split())))\n\n\n\n    for i in range(n-1):\n\n        for j in range(i+1,n):\n\n            same += check_dice(dices[i], dices[j])\n\n        if same >= 1:\n\n            print('No')\n\n            break\n\n\n\n    if same == 0:\n\n        print('Yes')\n\n\n\n\n\ndef check_dice(f, s):\n\n    yes = 0\n\n    for _ in range(4):\n\n        s[0],s[2],s[5],s[3] = s[2],s[5],s[3],s[0]\n\n        for _ in range(4):\n\n            s[1],s[2],s[4],s[3] = s[2],s[4],s[3],s[1]\n\n            if f == s:\n\n                yes = 1\n\n\n\n    for _ in range(4):\n\n        s[0],s[1],s[5],s[4] = s[1],s[5],s[4],s[0]\n\n        for _ in range(4):\n\n            s[1],s[2],s[4],s[3] = s[2],s[4],s[3],s[1]\n\n            if f == s:\n\n                yes = 1\n\n\n\n    return yes\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. class Dice:\n\n\n\n    def __init__(self):\n\n        # \n\n        # , 1, 2, 3, 4, 5, 6\n\n        self.t = 1\n\n        self.s = 2\n\n        self.e = 3\n\n        self.w = 4\n\n        self.n = 5\n\n        self.b = 6\n\n        self.rotway = {\"S\": 0, \"N\": 1, \"E\": 2, \"W\": 3}\n\n\n\n    def __init__(self, t, s, e, w, n, b):\n\n        # \n\n        self.t = t\n\n        self.s = s\n\n        self.e = e\n\n        self.w = w\n\n        self.n = n\n\n        self.b = b\n\n        self.rotway = {\"S\": 0, \"N\": 1, \"E\": 2, \"W\": 3}\n\n\n\n    def rot(self, way):\n\n        if way == 0:\n\n            self.t, self.s, self.e, self.w, self.n, self.b = self.n, self.t, self.e, self.w, self.b, self.s\n\n        elif way == 1:\n\n            self.t, self.s, self.e, self.w, self.n, self.b = self.s, self.b, self.e, self.w, self.t, self.n\n\n        elif way == 2:\n\n            self.t, self.s, self.e, self.w, self.n, self.b = self.w, self.s, self.t, self.b, self.n, self.e\n\n        elif way == 3:\n\n            self.t, self.s, self.e, self.w, self.n, self.b = self.e, self.s, self.b, self.t, self.n, self.w\n\n        \n\n\n\ndef main():\n\n    import random\n\n\n\n    n = int(eval(input()))\n\n    diceList = [[0 for _ in range(6)] for _ in range(n)]\n\n    for i in range(n):\n\n        diceList[i][0],diceList[i][1],diceList[i][2],diceList[i][3],diceList[i][4],diceList[i][5] = list(map(int, input().split()))\n\n\n\n    flag = 0\n\n\n\n    # 2\n\n    for i in range(1, n):\n\n        if flag == 1:\n\n            break\n\n        else:\n\n            dice_a = Dice(diceList[i][0],diceList[i][1],diceList[i][2],diceList[i][3],diceList[i][4],diceList[i][5])\n\n            for j in range(i):\n\n                dice_b = Dice(diceList[j][0],diceList[j][1],diceList[j][2],diceList[j][3],diceList[j][4],diceList[j][5])\n\n\n\n                for _ in range(100):\n\n                    if (dice_a.t, dice_a.s, dice_a.e, dice_a.w, dice_a.n, dice_a.b) == (dice_b.t, dice_b.s, dice_b.e, dice_b.w, dice_b.n, dice_b.b):\n\n                        flag = 1\n\n                        break\n\n                    else:\n\n                        seed = random.randint(0, 3)\n\n                        dice_a.rot(seed)\n\n\n\n    if flag == 0:\n\n        print(\"Yes\")\n\n    else:\n\n        print(\"No\")\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n", "output": "A", "improve_diff": 1.5938787662, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n, a, b = list(map(int, input().split()))\n\ncanditates = [i for i in range(1, n+1) \n\n              if a <= sum(list(map(int, list(str(i))))) <= b]\n\nprint((sum(canditates))) \nB. n, a, b = list(map(int, input().split()))\n\ntotal_val = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    digits = list(i_str)\n\n    sum_digit = sum([int(digit) for digit in digits])\n\n    if sum_digit >= a and sum_digit <= b:\n\n        total_val += i\n\nprint(total_val)", "output": "A", "improve_diff": 1.0518021603, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\na = [int(eval(input())) for i in range(n)]\n\nsum_a = sum(a)\n\nMOD = 998244353\n\n\n\ndp = [[0] * (sum_a + 1) for i in range(n + 1)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n\n    for j in range(sum_a + 1):\n\n        # \n\n        if j - a[i] >= 0:\n\n            dp[i + 1][j] += dp[i][j - a[i]]\n\n        # \n\n        dp[i + 1][j] += dp[i][j] * 2\n\n        dp[i + 1][j] %= MOD\n\n        \n\ndq = [[0] * (sum_a + 1) for i in range(n + 1)]\n\ndq[0][0] = 1\n\nfor i in range(n):\n\n    for j in range(sum_a + 1):\n\n        # \n\n        if j - a[i] >= 0:\n\n            dq[i + 1][j] += dq[i][j - a[i]]\n\n        # \n\n        dq[i + 1][j] += dq[i][j]\n\n        dq[i + 1][j] %= MOD\n\n\n\nans = 0\n\nfor j in range(sum_a + 1):\n\n    if sum_a <= j * 2:\n\n        ans += dp[-1][j] * 3\n\n        ans %= MOD\n\n\n\nif sum_a % 2 == 0:\n\n    ans -= dq[-1][sum_a // 2] * 3\n\n\n\nprint(((3 ** n - ans) % MOD)) \nB. n = int(eval(input()))\n\na = [int(eval(input())) for i in range(n)]\n\nsum_a = sum(a)\n\nMOD = 998244353\n\n\n\ndp = [0] * (sum_a + 1)\n\ndp[0] = 1\n\nfor i in range(n):\n\n    for j in range(sum_a + 1)[::-1]:\n\n        # \n\n        dp[j] += dp[j]\n\n        if j - a[i] >= 0:\n\n            dp[j] += dp[j - a[i]]\n\n        dp[j] %= MOD\n\n        \n\ndq = [0] * (sum_a + 1)\n\ndq[0] = 1\n\nfor i in range(n):\n\n    for j in range(sum_a + 1)[::-1]:\n\n        # \n\n        if j - a[i] >= 0:\n\n            dq[j] += dq[j - a[i]]\n\n            dq[j] %= MOD\n\n        else:\n\n            break\n\n\n\nans = 0\n\nfor j in range(sum_a + 1):\n\n    if sum_a <= j * 2:\n\n        ans += dp[j] * 3\n\n        ans %= MOD\n\n\n\nif sum_a % 2 == 0:\n\n    ans -= dq[sum_a // 2] * 3\n\n\n\nprint(((3 ** n - ans) % MOD))", "output": "B", "improve_diff": 1.0188379598, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = eval(input())\n\na = list(map(int, input().split()))\n\n\n\nb = []\n\nfor i in range(1, n):\n\n    if a[i] - a[i-1] != 0:\n\n        b.append(a[i] - a[i-1])\n\ndont_mind = True\n\nc = 1\n\ni = 1\n\nwhile i < len(b):\n\n    prev = b[i-1]\n\n    t = prev * b[i]\n\n    if t >= 0:\n\n        i += 1\n\n        continue\n\n    if t < 0:\n\n        c += 1\n\n        i += 2\n\n        continue\n\n    i += 1\n\nprint(c) \nB. # coding: utf-8\n\n# AGC 013 a \n\n# Here your code !\n\nn = eval(input())\n\nif n <= 2:\n\n    print(1)\n\n    exit()\n\n    \n\na = list(map(int, input().split()))\n\n\n\nc = 1\n\n\n\nstatus = \"n\"\n\ni = 1\n\nwhile i < n:\n\n    if status == \"n\":\n\n        if a[i-1] < a[i]:\n\n            status = \"i\"\n\n        elif a[i-1] > a[i]:\n\n            status = \"d\"\n\n        i += 1\n\n        \n\n    elif status == \"i\":\n\n        if a[i-1] <= a[i]:\n\n            i += 1\n\n        elif a[i-1] > a[i]:\n\n            status = \"n\"\n\n            c += 1\n\n            i += 1\n\n        \n\n    elif status == \"d\":\n\n        if a[i-1] < a[i]:\n\n            status = \"n\"\n\n            c += 1\n\n            i += 1\n\n        elif a[i-1] >= a[i]:\n\n            i += 1\n\nprint(c)", "output": "A", "improve_diff": 1.0273958789, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. d, n = list(map(int, input().split()))\n\nstart = 100 ** d\n\ncounter = 0\n\nwhile True:\n\n    if start % (100 ** d) == 0 and start % (100 ** (d + 1)) != 0:\n\n        counter += 1\n\n    if counter == n:\n\n        print(start)\n\n        break\n\n    start += 1\n \nB. d, n = list(map(int, input().split()))\n\nstart = 100 ** d\n\ncounter = 0\n\nwhile True:\n\n    if start % (100 ** d) == 0 and start % (100 ** (d + 1)) != 0:\n\n        counter += 1\n\n    if counter == n:\n\n        print(start)\n\n        break\n\n    start += 100 ** d\n", "output": "B", "improve_diff": 3.6460892507, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # C - Average Length\n\n\n\nN = int(eval(input()))\n\nP = [tuple(map(int, input().split())) for _ in range(N)]\n\n\n\ndef calcDist(Y):\n\n    dist = 0\n\n    for i in range(1, len(Y)):\n\n        dist += pow(pow(P[Y[i]][0] - P[Y[i-1]][0], 2) + pow(P[Y[i]][1] - P[Y[i-1]][1], 2), 0.5)\n\n    return dist\n\n\n\ndef dfs(X):\n\n    global ans\n\n    if len(X)==N:\n\n        ans.append(calcDist(X))\n\n        return\n\n    for i in range(N):\n\n        if i not in X:\n\n            X.append(i)\n\n            dfs(X)\n\n            X.pop()\n\n\n\nans = []\n\nX = []\n\ndfs(X)\n\n\n\nprint((sum(ans)/len(ans)))\n\n\n \nB. # C - Average Length\n\n\n\nimport itertools\n\n\n\nN = int(eval(input()))\n\nP = [tuple(map(int, input().split())) for _ in range(N)]\n\n\n\ndef calcDist(Y):\n\n    dist = 0\n\n    for i in range(1, len(Y)):\n\n        dist += pow(pow(P[Y[i]][0] - P[Y[i-1]][0], 2) + pow(P[Y[i]][1] - P[Y[i-1]][1], 2), 0.5)\n\n    return dist\n\n\n\ndef dfs(X):\n\n    global ans\n\n    if len(X)==N:\n\n        ans.append(calcDist(X))\n\n        return\n\n    for i in range(N):\n\n        if i not in X:\n\n            X.append(i)\n\n            dfs(X)\n\n            X.pop()\n\n\n\nans = []\n\nX = []\n\n#dfs(X)\n\n\n\nfor X in itertools.permutations(list(range(N)),N):\n\n    ans.append(calcDist(X))\n\n\n\nprint((sum(ans)/len(ans)))\n\n\n", "output": "A", "improve_diff": 1.0141442485, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\n\n\nN = int(sys.stdin.readline())\n\nA = list(map(int, sys.stdin.readline().rstrip().split()))\n\nA = sorted(A)\n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n    \n\n    return divisors\n\n\n\ndef main():\n\n    if len(A) <= 2:\n\n        print((max(A)))\n\n        exit()\n\n    else:\n\n        all_divisors = list(set(make_divisors(A[0]) + make_divisors(A[1])))\n\n\n\n    ans = 1\n\n    for divisor in all_divisors:\n\n        cnt = 0\n\n        for a in A:\n\n            if a % divisor != 0:\n\n                cnt += 1\n\n            if cnt == 2:\n\n                break\n\n        if cnt < 2:\n\n            ans = max(ans, divisor)\n\n\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main() \nB. N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = sorted(A)\n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n // i:\n\n                divisors.append(n//i)\n\n    \n\n    return divisors\n\n\n\nif len(A) <= 2:\n\n    print((max(A)))\n\n    exit()\n\nelse:\n\n    all_divisors = list(set(make_divisors(A[0]) + make_divisors(A[1])))\n\n\n\nans = 1\n\nfor divisor in all_divisors:\n\n    cnt = 0\n\n    for a in A:\n\n        if a % divisor != 0:\n\n            cnt += 1\n\n        if cnt == 2:\n\n            break\n\n    if cnt < 2:\n\n        ans = max(ans, divisor)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.0321164788, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. print(('A' + input().split()[1][0] +'C')) \nB. a,b,c = input().split()\n\nprint('A',b[0],'C',sep='')\n", "output": "A", "improve_diff": 1.005316807, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # ABC067D - Fennec VS. Snuke (ARC078D)\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\n\n\ndef dfs(v: int, x: int, d: \"List[int]\") -> None:\n\n    d[v] = x\n\n    for u in G[v]:\n\n        if not d[u]:\n\n            dfs(u, x + 1, d)\n\n\n\n\n\ndef main():\n\n    global G, DB, DW\n\n    N = int(eval(input()))\n\n    E = tuple(tuple(map(int, input().split())) for _ in range(N - 1))\n\n    G = [[] for _ in range(N + 1)]\n\n    for v, u in E:\n\n        G[v] += [u]\n\n        G[u] += [v]\n\n    DB, DW = [0] * (N + 1), [0] * (N + 1)\n\n    dfs(1, 1, DB), dfs(N, 1, DW)\n\n    b, w = 0, 0\n\n    for i, j in zip(DB[1:], DW[1:]):\n\n        if i <= j:\n\n            b += 1\n\n        else:\n\n            w += 1\n\n    flg = b > w\n\n    print((\"Fennec\" if flg else \"Snuke\"))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main() \nB. # ABC067D - Fennec VS. Snuke (ARC078D)\n\nfrom collections import deque\n\n\n\n\n\ndef bfs(s: int, d: \"List[int]\") -> None:\n\n    q = deque([s])\n\n    while q:\n\n        v = q.popleft()\n\n        for u in G[v]:\n\n            if not d[u]:\n\n                q.append(u)\n\n                d[u] = d[v] + 1\n\n\n\n\n\ndef main():\n\n    global G, DB, DW\n\n    N, *E = list(map(int, open(0).read().split()))\n\n    G = [[] for _ in range(N + 1)]\n\n    for i in range(0, (N - 1) * 2, 2):\n\n        v, u = E[i : i + 2]\n\n        G[v] += [u]\n\n        G[u] += [v]\n\n    DB, DW = [0] * (N + 1), [0] * (N + 1)\n\n    bfs(1, DB), bfs(N, DW)\n\n    b, w = 0, 0\n\n    for i, j in zip(DB[1:], DW[1:]):\n\n        if i <= j:\n\n            b += 1\n\n        else:\n\n            w += 1\n\n    flg = b > w\n\n    print((\"Fennec\" if flg else \"Snuke\"))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "A", "improve_diff": 1.4893652452, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. H, W, K = list(map(int, input().split()))\n\nMOD, p, cnt = 10**9+7, [0]*W, 0\n\nfor bit in range(1<<(W-1)):\n\n    s0 = bit&1\n\n    flg=True\n\n    for w in range(1, W-1):\n\n        if (bit>>w)&1 and s0 == 1:flg=False; break\n\n        s0 = (bit>>w)&1\n\n    if flg:\n\n        cnt += 1\n\n        for w in range(W - 1):\n\n            if (bit >> w)&1:p[w] += 1\n\ndp = [[0]*W for _ in range(H+1)]\n\ndp[0][0] = 1\n\nfor h in range(H):\n\n    for w in range(W):\n\n        if w:\n\n            dp[h+1][w-1] += dp[h][w]*p[w-1]\n\n            dp[h+1][w-1] %= MOD\n\n        if w-(W - 1):\n\n            dp[h+1][w+1] += dp[h][w]*p[w]\n\n            dp[h+1][w+1] %= MOD\n\n        dp[h+1][w]+=dp[h][w]*(cnt-p[w-1]-p[w])\n\n        dp[h+1][w]%=MOD\n\nprint((dp[H][K-1])) \nB. H, W, K = list(map(int, input().split()))\n\nW2 = W-1\n\nc = [0] * (W2+1)\n\ncnt = 0\n\nMOD = 10**9 + 7\n\nfor bit in range(1 << W2):\n\n    s0 = bit&1\n\n    flg=True\n\n    for i in range(1, W2):\n\n        if (bit>>i)&1 and s0 == 1:\n\n            flg = False\n\n            break\n\n        s0 = (bit>>i)&1\n\n    if flg:\n\n        cnt += 1\n\n        for i in range(W2):\n\n            if (bit >> i)&1:\n\n                c[i] += 1\n\ndp = [[0]*W for _ in range(H+1)]\n\ndp[0][0] = 1\n\nfor h in range(H):\n\n    for i in range(W):\n\n        if i != 0:\n\n            dp[h+1][i-1] += dp[h][i]*c[i-1]\n\n            dp[h+1][i-1] %= MOD\n\n        if i != W-1:\n\n            dp[h+1][i+1] += dp[h][i]*c[i]\n\n            dp[h+1][i+1] %= MOD\n\n        dp[h+1][i] += dp[h][i]*(cnt-c[i-1]-c[i])\n\n        dp[h+1][i] %= MOD\n\nprint((dp[H][K-1]))", "output": "B", "improve_diff": 1.0331497687, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\na,b=list(map(int,input().split()))\n\nx=max(a,b)\n\ny=min(a,b)\n\np=abs(x-y)\n\n\n\nP = 10**9 + 7\n\nN = 1000000\n\ninv_t = [0]+[1]\n\nfor i in range(2,N):\n\n  inv_t += [inv_t[P % i] * (P - int(P / i)) % P]\n\n\n\nif (x+y)%3!=0:\n\n    print((0))\n\nelif x>y*2:\n\n    print((0))\n\nelse:\n\n    n=(x+y)//3\n\n    q=(2*x-y)//3\n\n    r=(2*y-x)//3\n\n    \n\n    #print(math.factorial(q+r)//math.factorial(q)//math.factorial(r)%(10**9+7))\n\n    ans=1\n\n    qq=1\n\n    rr=1\n\n    for i in range(1,q+r+1):\n\n        ans*=i\n\n        ans%=10**9+7\n\n    for i in range(1,q+1):\n\n        ans*=inv_t[i]\n\n        ans%=10**9+7\n\n\n\n    P = 10**9 + 7\n\n    N = r+2\n\n    inv_t = [0]+[1]\n\n    for i in range(2,N):\n\n        inv_t += [inv_t[P % i] * (P - int(P / i)) % P]\n\n\n\n    for i in range(1,r+1):\n\n        ans*=inv_t[i]\n\n        ans%=10**9+7\n\n            \n\n            \n\n    print(ans)\n \nB. import math\n\na,b=list(map(int,input().split()))\n\nx=max(a,b)\n\ny=min(a,b)\n\np=abs(x-y)\n\n\n\nif (x+y)%3!=0:\n\n    print((0))\n\nelif x>y*2:\n\n    print((0))\n\nelse:\n\n    n=(x+y)//3\n\n    q=(2*x-y)//3\n\n    r=(2*y-x)//3\n\n    \n\n    #print(math.factorial(q+r)//math.factorial(q)//math.factorial(r)%(10**9+7))\n\n    ans=1\n\n    qq=1\n\n    rr=1\n\n    P = 10**9 + 7\n\n    N = max(q,r)+2\n\n    inv_t = [0]+[1]\n\n    for i in range(2,N):\n\n        inv_t += [inv_t[P % i] * (P - int(P / i)) % P]\n\n    for i in range(1,q+r+1):\n\n        ans*=i\n\n        ans%=10**9+7\n\n    for i in range(1,q+1):\n\n        ans*=inv_t[i]\n\n        ans%=10**9+7\n\n    for i in range(1,r+1):\n\n        ans*=inv_t[i]\n\n        ans%=10**9+7\n\n            \n\n            \n\n    print(ans)\n", "output": "B", "improve_diff": 5.244596124, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import ceil\n\ndef check(x,hp):\n\n    hp=[hh-(b*x) for hh in hp]\n\n    cnt=0\n\n    for p in hp:\n\n        if p<=0:continue\n\n        cnt+=ceil(p/(a-b))\n\n    return cnt<=x\n\n\n\nn,a,b=list(map(int,input().split()))\n\nh=[int(eval(input())) for i in range(n)]\n\nlo=0\n\nhi=10**9\n\nwhile hi-lo>1:\n\n    mid=(hi+lo)//2\n\n    if check(mid,h):\n\n        hi=mid\n\n    else:\n\n        lo=mid\n\nans=hi\n\n# htlo\uff1f\n\n# print(lo)\n\nprint(hi) \nB. # ABC063 D - Widespread\n\ndef check(x,hp):\n\n    hp=[hh-(b*x) for hh in hp]\n\n    explosion=0\n\n    for hhh in hp:\n\n        if hhh<=0:continue\n\n        if hhh%(a-b)==0:\n\n            explosion+=hhh//(a-b)\n\n        else:\n\n            explosion+=hhh//(a-b)+1\n\n    return explosion<=x\n\n\n\nn,a,b=list(map(int,input().split()))\n\nh=[int(eval(input())) for i in range(n)]\n\nlo=0\n\nhi=10**9\n\nwhile hi-lo>1:\n\n    mid=(hi+lo)//2\n\n    if check(mid,h):\n\n        hi=mid\n\n    else:\n\n        lo=mid\n\nprint((lo+1))", "output": "B", "improve_diff": 1.2976320003, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from math import ceil\n\nn = int(eval(input()))\n\na = []\n\nfor i in range(5):\n\n    a.append(int(eval(input())))\n\n\n\nans = ceil(n / min(a)) + 4\n\nprint(ans) \nB. # C\n\nimport math\n\nn = int(eval(input()))\n\na = []\n\nfor i in range(5):\n\n    a.append(int(eval(input())))\n\nans = math.ceil((n/min(a) + 5) - 1)\n\nprint(ans)", "output": "B", "improve_diff": 1.0096555083, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def gcd(a, b):\n\n    while b != 0 :\n\n        t = a % b\n\n        a = b\n\n        b = t\n\n    return a\n\n        \n\nsum = 0\n\nN=int(eval(input(\"\")))\n\nfor a in range(1, N + 1):\n\n    for b in range(1, N + 1):\n\n        x = gcd(a, b)\n\n        if x == 1:\n\n            sum = sum + N\n\n        elif x == 2:\n\n            sum = sum + (N + 1) // 2 + N // 2 * 2\n\n        else:\n\n            for c in range(1, N + 1):\n\n                sum = sum + gcd(x, c)\n\nprint(sum) \nB. def gcd(a, b):\n\n    while b != 0 :\n\n        t = a % b\n\n        a = b\n\n        b = t\n\n    return a\n\n        \n\nsum = 0\n\nN=int(eval(input(\"\")))\n\nfor a in range(1, N + 1):\n\n    for b in range(1, N + 1):\n\n        x = gcd(a, b)\n\n        if x == 1:\n\n            sum = sum + N\n\n        elif x == 2:\n\n            sum = sum + (N + 1) // 2 + N // 2 * 2\n\n        elif x == 3:\n\n            sum = sum + N // 3 * 3 + (N - N // 3)\n\n        else:\n\n            for c in range(1, N + 1):\n\n                sum = sum + gcd(x, c)\n\nprint(sum)", "output": "B", "improve_diff": 1.0180752721, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nimport sys\n\nif sys.version[0] == '2':\n\n    range, input = xrange, raw_input\n\n\n\n\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n\n        # 0-indexed\n\n        self.N = len(a_list)\n\n        self.bit = a_list[:]\n\n        self.f = f\n\n        self.default = default\n\n        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):\n\n            self.bit.append(self.default)\n\n        for i in range(self.N - 1):\n\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n\n\n    def update(self, i, val):\n\n        while i < self.N:\n\n            self.bit[i] = self.f(self.bit[i], val)\n\n            i |= i + 1\n\n\n\n    def query(self, n):\n\n        # [0, n]\n\n        ret = 0\n\n        while n >= 0:\n\n            ret = self.f(ret, self.bit[n])\n\n            n = (n & (n + 1)) - 1\n\n        return ret\n\n\n\n\n\nN = int(eval(input()))\n\nX = [int(x) for x in input().split()]\n\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\n\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n\n    dp.update(i, dp.query(i) + x)\n\nprint((N * (N + 1) // 2 - dp.query(N - 1))) \nB. import math\n\n\n\n\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n\n        # 0-indexed\n\n        self.N = len(a_list)\n\n        self.bit = a_list[:]\n\n        self.f = f\n\n        self.default = default\n\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n\n            self.bit.append(self.default)\n\n        for i in range(self.N - 1):\n\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n\n\n    def update(self, i, val):\n\n        while i < self.N:\n\n            self.bit[i] = self.f(self.bit[i], val)\n\n            i |= i + 1\n\n\n\n    def query(self, n):\n\n        # [0, n]\n\n        ret = 0\n\n        while n >= 0:\n\n            ret = self.f(ret, self.bit[n])\n\n            n = (n & (n + 1)) - 1\n\n        return ret\n\n\n\n\n\nN = int(eval(input()))\n\nX = [int(x) for x in input().split()]\n\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\n\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n\n    dp.update(i, dp.query(i) + x)\n\nprint((N * (N + 1) // 2 - dp.query(N - 1)))", "output": "A", "improve_diff": 1.01402784, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. A,B,C,X,Y=list(map(int,input().split()))\n\nans= min(A+B,2*C)*min(X,Y)\n\nif X>Y:\n\n  ans+=min(A,2*C)*(X-Y)\n\nelse:\n\n  ans+=min(B,2*C)*(Y-X)\n\nprint(ans)\n \nB. a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nans=min(ans,c*x*2 +max(0,y-x)*b,c*y*2+max(0,x-y)*a)\n\nprint(ans)", "output": "B", "improve_diff": 1.0212673732, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # test\n\nclass fenwick_tree:\n\n  def __init__(s, n):\n\n    s._n = n\n\n    s.data = [0] * n\n\n\n\n  def add(s, p, x):\n\n    p += 1\n\n    while p <= s._n:\n\n      s.data[p - 1] += x\n\n      p += p & -p\n\n\n\n  def sumlr(s, l, r):\n\n    return s.sum(r) - s.sum(l)\n\n\n\n  def sum(self, r):\n\n    s = 0\n\n    while r > 0:\n\n      s += self.data[r - 1]\n\n      r -= r & -r\n\n    return s\n\n\n\n\n\nN, Q = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nQuery = [list(map(int, input().split())) for _ in range(Q)]\n\n  \n\nbit = fenwick_tree(N)\n\nfor i in range(N):\n\n  bit.add(i, a[i])\n\n\n\nfor q in Query:\n\n  if q[0] == 0:\n\n    _, p, x = q\n\n    bit.add(p, x)\n\n  else:\n\n    _, l, r = q\n\n    print((bit.sumlr(l, r)))\n \nB. class BIT:\n\n  def __init__(s, n):\n\n    s._n = n\n\n    s.data = [0] * n\n\n  def add(s, p, x):\n\n    p += 1\n\n    while p <= s._n:\n\n      s.data[p - 1] += x\n\n      p += p & -p\n\n  def sum(s, l, r):\n\n    return s.zum(r) - s.zum(l)\n\n  def zum(s, r):\n\n    ans = 0\n\n    while r > 0:\n\n      ans += s.data[r - 1]\n\n      r -= r & -r\n\n    return ans\n\n\n\nN, Q = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nQuery = [list(map(int, input().split())) for _ in range(Q)]\n\n  \n\nbit = BIT(N)\n\nfor i in range(N):\n\n  bit.add(i, a[i])\n\n \n\nfor q in Query:\n\n  if q[0] == 0:\n\n    _, p, x = q\n\n    bit.add(p, x)\n\n  else:\n\n    _, l, r = q\n\n    print((bit.sum(l, r)))", "output": "B", "improve_diff": 1.0043044624, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def inpl():\n\n    return input().split()\n\n\n\nn = int(eval(input()))\n\na = list(map(int, inpl()))\n\nd = {}\n\nfor i in range(n):\n\n    d[a[i]] = d.get(a[i], 0) + 1\n\n\n\nans = 0\n\nfor k in list(d.keys()):\n\n    b = 0\n\n    b += d.get(k - 1, 0)\n\n    b += d.get(k, 0)\n\n    b += d.get(k + 1, 0)\n\n    ans = max(ans, b)\n\nprint(ans) \nB. def main():\n\n    from collections import deque\n\n\n\n    N = int(eval(input()))\n\n    *a, = list(map(int, input().split()))\n\n\n\n    b = [0] * (10 ** 5 + 10)\n\n    for x in a:\n\n        b[x] += 1\n\n\n\n    dq = deque()\n\n    b_iter = iter(b)\n\n    dq.append(next(b_iter))\n\n    dq.append(next(b_iter))\n\n    dq.append(next(b_iter))\n\n    t = sum(dq)\n\n    ans = t\n\n    for x in b:\n\n        dq.append(x)\n\n        y = dq.popleft()\n\n        t = t + x - y\n\n        if ans < t:\n\n            ans = t\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "A", "improve_diff": 2.077744751, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N,x = list(map(int,input().split()))\n\nA = sorted(list(map(int,input().split())))\n\nif x>=2*sum(A):\n\n    print((0))\n\nelse:\n\n    ind = N\n\n    for i in range(N):\n\n        x -= A[i]\n\n        if x<0:\n\n            ind = i\n\n            break\n\n    if ind==N and x>0:\n\n        A = sorted(A,reverse=True)\n\n        for i in range(N):\n\n            x -= A[i]\n\n            if x<0:\n\n                ind -= 1\n\n                break\n\n    print(ind) \nB. N,x = list(map(int,input().split()))\n\nA = sorted(list(map(int,input().split())))\n\ncnt = 0\n\ntot = A[0]\n\nwhile cnt<N and tot<=x:\n\n    cnt += 1\n\n    if cnt<N:\n\n        tot += A[cnt]\n\nif cnt==N and tot<x:\n\n    cnt -= 1\n\nprint(cnt)", "output": "A", "improve_diff": 1.0170720151, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. #\n\nn=int(eval(input()))\n\nt=[int(i) for i in input().split()]\n\nv=[int(i) for i in input().split()]\n\n\n\n#n\n\ndt=[0 for i in range(n)] #\n\nv0=[0 for i in range(n)] #\n\nve=[0 for i in range(n)] #\n\nS=[0 for i in range(n)] #\uff08v-t\uff09\n\nok=0 #ok\n\n\n\n#dt, v0, ve(v0, ve\uff09----------\n\n\n\nfor i in range(n):\n\n    if n ==1:\n\n        dt[0]=t[0]\n\n    elif i==n-1:\n\n        v0[i]=ve[i-1]\n\n        ve[i]=0\n\n        dt[i]=t[i]\n\n    else:\n\n        v0[i]=ve[i-1]\n\n        dt[i]=t[i]\n\n        ve[i]=min(v[i+1],v[i],v0[i]+dt[i])\n\n\n\n#\u03b1=(ve-v0)/dt\u00b11-----------------------------------------\n\n\n\nwhile ok==0:\n\n    for i in range(n-1):\n\n        if  abs((ve[i+1]-v0[i+1])/dt[i+1]) >1:\n\n                ve[i]=ve[i]-1\n\n                v0[i+1]=v0[i+1]-1\n\n\n\n                break\n\n    else:\n\n        ok=1\n\n#------------------------------------------------------------------------------------------------\n\n\n\n#\uff08v-t\uff09---------------------\n\nfor i in range(n):\n\n\n\n    ttt=0.5*(ve[i]+dt[i]-v0[i])\n\n    vvv=ttt+v0[i]\n\n    if vvv-v[i]>=0:\n\n        S[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt) - (ttt-v[i]+v0[i])*(vvv-v[i]) \n\n\n\n    else:\n\n        S[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt)\n\n\n\n#------------------------------------------------------------------------------------------------\n\nprint((sum(S))) #\uff08\uff09 \nB. n=int(eval(input()))\n\nt=[int(i) for i in input().split()]\n\nv=[int(i) for i in input().split()]\n\nS=[0 for i in range(n)]\n\nS1=[0 for i in range(n)]\n\nS2=[0 for i in range(n)]\n\nvel=[0 for i in range(n)]\n\n\n\ndt=[0 for i in range(n)]\n\nv0=[0 for i in range(n)]\n\nve=[0 for i in range(n)]\n\nok=0\n\n\n\n\n\n\n\nfor i in range(n):\n\n    if n ==1:\n\n        dt[0]=t[0]\n\n    elif i==n-1:\n\n        v0[i]=ve[i-1]\n\n        ve[i]=0\n\n        dt[i]=t[i]\n\n    else:\n\n        v0[i]=ve[i-1]\n\n        dt[i]=t[i]\n\n        ve[i]=min(v[i+1],v[i],v0[i]+dt[i])\n\n\n\n#print(dt)\n\n#print(v0)\n\n#print(ve)\n\n\n\nwhile ok==0:\n\n    for i in range(n-1):\n\n#        if  abs((ve[i]-ve[i+1])/dt[i+1]) >1:\n\n        if  abs((ve[i+1]-v0[i+1])/dt[i+1]) >1:\n\n                ve[i]=ve[i]-1\n\n                v0[i+1]=v0[i+1]-1\n\n#                v0[i]=v0[i]-1\n\n#                print(\"dt\",dt)\n\n#                print(\"v0\",v0)\n\n#                print(\"ve\",ve)\n\n                break\n\n    else:\n\n        ok=1\n\n\n\n\n\n#print(dt)\n\n#print(v0)\n\n#print(ve)\n\n\n\n\n\nfor i in range(n):\n\n\n\n    ttt=0.5*(ve[i]+dt[i]-v0[i])\n\n    vvv=ttt+v0[i]\n\n    if vvv-v[i]>=0:\n\n        S[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt) - (ttt-v[i]+v0[i])*(vvv-v[i]) \n\n        S1[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt)\n\n        S2[i]=(ttt-v[i]+v0[i])*(vvv-v[i]) \n\n    else:\n\n        S[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt)\n\n        S1[i]=0.5*(v0[i]+vvv)*ttt + 0.5*(ve[i]+vvv)*(dt[i]-ttt)\n\n        S2[i]=0\n\n\n\nprint((sum(S)))\n\n\n", "output": "B", "improve_diff": 1.0116863735, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\nans = 0\n\nfor i in range(1,10):\n\n  if i <= n:\n\n    ans += 1\n\n  else:\n\n    break\n\nif n > 99:\n\n  for i in range(100,1000):\n\n    if i <= n:\n\n      ans += 1\n\n    else:\n\n      break\n\nif n > 9999:\n\n  for i in range(10000,100000):\n\n    if i <= n:\n\n      ans += 1\n\n    else:\n\n      break\n\nprint(ans) \nB. n = int(eval(input()))\n\n\n\nif n < 100:\n\n  print((min(n,9)))\n\nelif n < 10000:\n\n  print((min(n-90,909)))\n\nelif n <= 100000:\n\n  print((min(n-9090,90909)))", "output": "B", "improve_diff": 1.2077683593, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import queue\n\n\n\nk = int(eval(input()))\n\nq = queue.Queue()\n\n\n\nfor i in range(1,10):\n\n    q.put(i)\n\n\n\nfor i in range(1,k):\n\n    l = q.get()\n\n    m = l % 10\n\n    if (m != 0):\n\n        q.put(l * 10 + m - 1)\n\n    q.put(l * 10 + m)\n\n    if (m != 9):\n\n        q.put(l * 10 + m + 1)\n\n\n\nprint((q.get()))  \nB. from collections import deque\n\n\n\nk = int(eval(input()))\n\nq = deque([1,2,3,4,5,6,7,8,9])\n\n\n\nfor i in range(1,k):\n\n    l = q.popleft()\n\n    if (len(q) < k):\n\n        m = l % 10\n\n        if (m != 0):\n\n            q.append(l * 10 + m - 1)\n\n        q.append(l * 10 + m)\n\n        if (m != 9):\n\n            q.append(l * 10 + m + 1)\n\n\n\nprint((q.popleft()))", "output": "B", "improve_diff": 3.2342004474, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import Counter\n\nn,m = list(map(int,input().split()))\n\nmany  =[]\n\nfor i in range(n):\n\n    a = list(map(int,input().split()))\n\n    for j in range(1,a[0]+1):\n\n        many.append(a[j])\n\n\n\nans = Counter(many).most_common()\n\ncount = 0\n\nfor i in range(len(ans)):\n\n    if ans[i][1] == n:\n\n        count += 1\n\n\n\nprint(count) \nB. n,m = list(map(int,input().split()))\n\ndata = [0 for i in range(m)]\n\nfor i in range(n):\n\n    k,*a = list(map(int,input().split()))\n\n    for x in a:\n\n        data[x-1] += 1\n\nans = 0\n\nfor i in range(m):\n\n    if data[i] == n:\n\n        ans += 1\n\n\n\nprint(ans)", "output": "B", "improve_diff": 1.4824559949, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. k = int(eval(input()))\n\n\n\nnumset = {i for i in range(1,10)}\n\nflag = False\n\ncount = len(numset)\n\nif count >= k:\n\n    flag = True\n\narr = [numset]\n\nindex = 0\n\n\n\nwhile not flag:\n\n    beforeset = arr[index]\n\n    tmpset = set()\n\n    for i in beforeset:\n\n        tail = str(i)[-1]\n\n        if tail == \"0\":\n\n            tmpset.add(int(str(i)+str(0)))\n\n            tmpset.add(int(str(i)+str(1)))\n\n        elif tail == \"9\":\n\n            tmpset.add(int(str(i)+str(8)))\n\n            tmpset.add(int(str(i)+str(9)))\n\n        else:\n\n            tmpset.add(int(str(i)+str(int(tail))))\n\n            tmpset.add(int(str(i)+str(int(tail)+1)))\n\n            tmpset.add(int(str(i)+str(int(tail)-1)))\n\n    count += len(tmpset)\n\n    if count >= k:\n\n        flag = True\n\n    arr.append(tmpset)\n\n    index += 1\n\n    \n\ntotalarr = []\n\nfor tmpset in arr:\n\n    totalarr += list(tmpset)\n\n    \n\ntotalarr.sort()\n\nprint((totalarr[k-1])) \nB. k = int(eval(input()))\n\n\n\nfrom collections import deque\n\nqueue = deque(list(range(1,10)))\n\ncount = 0\n\n\n\nwhile count < k:\n\n    tmp = queue.popleft()\n\n    tail = tmp%10\n\n    if tail != 0:\n\n        queue.append(tmp*10+tail-1)\n\n    queue.append(tmp*10+tail)\n\n    if tail != 9:\n\n        queue.append(tmp*10+tail+1)\n\n    count += 1\n\n    \n\nprint(tmp)\n", "output": "B", "improve_diff": 1.3848135939, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. k = int(eval(input()))\n\n\n\nlun_list = [1,2,3,4,5,6,7,8,9]\n\n\n\nfor i in lun_list:\n\n    if str(i)[-1] == '0':\n\n        for j in range(2):\n\n            lun_list.append(int(str(i)+str(j)))\n\n    elif str(i)[-1] == '9':\n\n        for j in range(8,10):\n\n            lun_list.append(int(str(i)+str(j)))\n\n    else:\n\n        for j in range(int(str(i)[-1])-1,int(str(i)[-1])+2):\n\n            lun_list.append(int(str(i)+str(j)))\n\n    if len(lun_list) > k:\n\n        break\n\n\n\nprint((lun_list[k-1])) \nB. k = int(eval(input()))\n\n\n\nnum_list = [1,2,3,4,5,6,7,8,9]\n\nnum_a = ['0', '1']\n\nnum_b = ['8', '9']\n\n\n\nfor i in num_list:\n\n    if str(i)[-1] == '0':\n\n        for j in num_a:\n\n            num_list.append(int(str(i)+j))\n\n    elif str(i)[-1] == '9':\n\n        for j in num_b:\n\n            num_list.append(int(str(i)+j))\n\n    else:\n\n        num = int(str(i)[-1])\n\n        for j in range(num-1, num+2):\n\n            num_list.append(int(str(i)+str(j)))\n\n    if len(num_list) > k:\n\n        break\n\n\n\nprint((num_list[k-1]))", "output": "B", "improve_diff": 1.0469287961, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n = int(eval(input()))\n\n\n\ndef tobase4(num):\n\n    ans = ''\n\n    while num>0:\n\n        ans += str(num%4)\n\n        num //= 4\n\n    return ans[::-1]\n\n\n\ndef check(s):\n\n    if '1' in s and '2' in s and '3' in s and '0' not in s:\n\n        return True\n\n    return False\n\n\n\ndef conv(s):\n\n    s = s.replace('2','5')\n\n    s = s.replace('3','7')\n\n    s = s.replace('1','3')\n\n    return s\n\n\n\nres = 0\n\nfor i in range(10**9):\n\n    s = tobase4(i)\n\n    if not check(s):\n\n        continue\n\n    s = conv(s)\n\n    s = int(s)\n\n    #print(s)\n\n    if n < s:\n\n        break\n\n    #print(s)\n\n    res += 1\n\nprint(res)\n \nB. def dfs(N,s,a,b,c):\n\n    if int(s)>N:\n\n        return 0\n\n    ret  = dfs(N,s+'3',True,b,c)\n\n    ret += dfs(N,s+'5',a,True,c)\n\n    ret += dfs(N,s+'7',a,b,True)\n\n    return ret + (a and b and c)\n\n\n\nprint((dfs(int(eval(input())),'0',False,False,False)))\n", "output": "B", "improve_diff": 8.6340702494, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. class Factorial():\n\n    def __init__(self, n, mod):\n\n        self.mod = mod\n\n        self.fct = [0 for _ in range(n + 1)]\n\n        self.inv = [0 for _ in range(n + 1)]\n\n        self.fct[0] = 1\n\n        self.inv[0] = 1\n\n        for i in range(n):\n\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n\n        for i in range(n)[::-1]:\n\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n\n\n\n    def comb(self, m, k):\n\n        if m < k: return 0\n\n        return self.fct[m] * self.inv[k] * self.inv[m - k] % self.mod\n\n\n\nMOD = 998244353\n\nN, A, B, K =list(map(int,input().split()))\n\n\n\nf = Factorial(N, MOD)\n\n\n\nres = 0\n\n\n\nfor i in range(N + 1):\n\n    if (K - A * i) % B == 0:\n\n        j = (K - A * i) // B\n\n        if 0 <= j <= N:\n\n            res += f.comb(N, i) * f.comb(N, j)\n\n            res %= MOD\n\n\n\nprint(res) \nB. class Factorial():\n\n    def __init__(self, n, mod):\n\n        self.mod = mod\n\n        self.fct = [0 for _ in range(n + 1)]\n\n        self.inv = [0 for _ in range(n + 1)]\n\n        self.fct[0] = 1\n\n        self.inv[0] = 1\n\n        for i in range(n):\n\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n\n        for i in range(n)[::-1]:\n\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n\n\n\n    def comb(self, m, k):\n\n        if m < k: return 0\n\n        return self.fct[m] * self.inv[k] * self.inv[m - k] % self.mod\n\n\n\ndef ex_euclid(x, y):\n\n    c0, c1 = x, y\n\n    a0, a1 = 1, 0\n\n    b0, b1 = 0, 1\n\n    while c1:\n\n        a0, a1 = a1, a0 - c0 // c1 * a1\n\n        b0, b1 = b1, b0 - c0 // c1 * b1\n\n        c0, c1 = c1, c0 % c1\n\n    return c0, a0, b0\n\n\n\nMOD = 998244353\n\nN, A, B, K =list(map(int,input().split()))\n\n\n\nf = Factorial(N, MOD)\n\nc, a, b = ex_euclid(A, B)\n\n\n\nif K == 0:\n\n    print((1))\n\n\n\nelif K % c != 0:\n\n    print((0))\n\n\n\nelse:\n\n    lo = -10**18\n\n    hi = 10**18\n\n    while hi - lo > 1:\n\n        mid = (hi + lo) // 2\n\n        if a * K // c + mid * B // c >= 0:\n\n            hi = mid\n\n        else:\n\n            lo = mid\n\n    x0 = a * K // c + hi * B // c\n\n\n\n    lo = -10**18\n\n    hi = 10**18\n\n    while hi - lo > 1:\n\n        mid = (hi + lo) // 2\n\n        if b * K // c - mid * A // c >= 0:\n\n            lo = mid\n\n        else:\n\n            hi = mid\n\n    y0 = b * K // c - lo * A // c\n\n\n\n    res = 0\n\n    x = x0\n\n    y = (K - A * x0) // B\n\n\n\n    while True:\n\n        res += f.comb(N, x) * f.comb(N, y)\n\n        res %= MOD\n\n        if y == y0:\n\n            break\n\n        x += B // c\n\n        y -= A // c\n\n\n\n    print(res)", "output": "B", "improve_diff": 1.2059159416, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\nfrom collections import deque\n\nfrom collections import defaultdict\n\nimport math\n\nsys.setrecursionlimit(20000000)\n\ninput = sys.stdin.readline\n\nn,m = list(map(int,input().split()))\n\na = [int(eval(input())) for i in range(m)]\n\na = set(a)\n\nmod = 10**9+7\n\ndp = [0]*(n+5)\n\ndp[0] = 1\n\nfor i in range(1,n+1):\n\n        if i in a:\n\n                continue\n\n        dp[i] = dp[i-1] + dp[i-2]\n\n        dp[i] %= mod\n\nprint((dp[n]%mod))\n \nB. #import sys\n\n#from collections import deque\n\n#from collections import defaultdict\n\n#import math\n\n#sys.setrecursionlimit(20000000)\n\n#input = sys.stdin.readline\n\nn,m = list(map(int,input().split()))\n\na = [int(eval(input())) for i in range(m)]\n\na = set(a)\n\nmod = 10**9+7\n\ndp = [0]*(n+1)\n\ndp[0] = 1\n\nfor i in range(1,n+1):\n\n        if i in a:\n\n                continue\n\n        if i == 1:\n\n                dp[i] = 1\n\n                continue\n\n        dp[i] = dp[i-1] + dp[i-2]\n\n        dp[i] %= mod\n\nprint((dp[n]%mod))", "output": "B", "improve_diff": 1.4962950071, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def route_num(stairs):\n\n    if stairs <= 1:\n\n        return 1\n\n    else:\n\n        return route_num(stairs - 1) + route_num(stairs - 2)\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\n\n\nbroken = {i:False for i in range(n + 1)}\n\nfor a_i in a:\n\n    broken[a_i] = True\n\n\n\nroute_num = {}\n\nfor i in range(n + 1):\n\n    if broken[i]:\n\n        route_num[i] = 0\n\n    elif i <= 1:\n\n        route_num[i] = 1\n\n    else:\n\n        route_num[i] = (route_num[i-1] + route_num[i-2]) % 1000000007\n\n\n\nprint((route_num[n]))\n \nB. def route_num(stairs):\n\n    if stairs <= 1:\n\n        return 1\n\n    else:\n\n        return route_num(stairs - 1) + route_num(stairs - 2)\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\n\n\nbroken = {i:False for i in range(n + 1)}\n\nfor a_i in a:\n\n    broken[a_i] = True\n\n\n\nroute_num = {}\n\nfor i in range(n + 1):\n\n    if broken[i]:\n\n        route_num[i] = 0\n\n    elif i <= 1:\n\n        route_num[i] = 1\n\n    else:\n\n        route_num[i] = route_num[i-1] + route_num[i-2]\n\n\n\nprint((route_num[n] % 1000000007))\n", "output": "A", "improve_diff": 1.0459700063, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. X, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nD = []\n\nfor a in A:\n\n    for b in B:\n\n        D.append(a + b)\n\nD.sort(reverse=True)\n\nif len(D) > K:\n\n    D = D[:K]\n\nE = []\n\nfor d in D:\n\n    for c in C:\n\n        E.append(c + d)\n\n\n\nE.sort(reverse=True)\n\nfor i, e in enumerate(E):\n\n    if i >= K:\n\n        break\n\n    print(e) \nB. X, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\nD = []\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        for k in range(Z):\n\n            if i * j * k > K:\n\n                break\n\n            D.append(A[i] + B[j] + C[k])\n\nD.sort(reverse=True)\n\nfor d in D[:K]:\n\n    print(d)\n", "output": "B", "improve_diff": 1.0226078734, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef ceil(a, b):\n\n    if a%b == 0:\n\n        return a//b\n\n    else:\n\n        return a//b + 1\n\n\n\ndef main():\n\n    D, G = list(map(int, input().split()))\n\n    G //= 100\n\n    pc = [list(map(int, input().split())) for i in range(D)]\n\n\n\n    ans = int(1e9)\n\n    for i in range(2**D):\n\n        tmp = 0\n\n        rest = []\n\n        count = 0\n\n        for j in range(D):\n\n            if i&1:# \n\n                tmp += (j+1) * pc[j][0] + pc[j][1]//100\n\n                count += pc[j][0]\n\n            else:\n\n                rest.append((j+1, pc[j][0]))\n\n            i >>= 1\n\n        rest = sorted(rest, reverse=True)\n\n        rest_point = G - tmp\n\n        if rest_point <= 0:# \n\n            ans = min(ans, count)\n\n        elif len(rest) > 0:# \n\n            plus = ceil(rest_point, rest[0][0])\n\n            if plus < rest[0][1]:# p-1\n\n                ans = min(ans, count + plus)\n\n        else:# \n\n            pass\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n \nB. import sys\n\ninput = sys.stdin.readline\n\n\n\ndef ceil(a, b):\n\n    if a%b == 0:\n\n        return a//b\n\n    else:\n\n        return (a//b) + 1\n\n\n\ndef main():\n\n    D, G = list(map(int, input().split()))\n\n    pc = [list(map(int, input().split())) for i in range(D)]\n\n\n\n    ans = int(1e9)\n\n    for i in range(2**D):\n\n        score = 0\n\n        count = 0\n\n        check = [False] * D\n\n        for j in range(D):\n\n            p, c = pc[j]\n\n            if i&1:# j\n\n                score += 100 * (j+1) * p + c\n\n                count += p\n\n                check[j] = True\n\n            i >>= 1\n\n        if score < G:\n\n            for j in range(D):\n\n                if not check[D-1-j]:\n\n                    check[D-1-j] = True\n\n                    p, c = pc[D-1-j]\n\n                    tmp = ceil(G - score, (D-j) * 100)\n\n                    if tmp < p:\n\n                        count += tmp\n\n                        score += tmp * (D-j) * 100\n\n                    break\n\n        if score >= G:\n\n            # print(score, check, count)\n\n            ans = min(ans, count)\n\n    \n\n    print(ans)\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "B", "improve_diff": 1.0318590716, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n  n,m=list(map(int,input().split()))\n\n  inf=10**9\n\n  dp=[inf]*(1<<n)\n\n  dp[0]=0\n\n  \n\n  #cost=[inf for i in range(m)]\n\n  for i in range(m):\n\n    a,b=list(map(int,input().split()))\n\n    c=[1<<(int(x)-1) for x in input().split()]\n\n    t=sum(c)\n\n    #cost[i]=[s,a]\n\n    for s in range(1<<n):\n\n      dp[t|s]=min(dp[t|s], dp[s]+a)\n\n    \n\n  #print(cost)\n\n  \"\"\"\n\n  dp=[inf]*(1<<n)\n\n  dp[0]=0\n\n  for s in range(1<<n):\n\n    for bit,c in cost:\n\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n\n  #print(dp)\n\n  \"\"\"\n\n  #print(dp)\n\n  print((-1 if dp[-1]==inf else dp[-1]))\n\n\n\nif __name__=='__main__':\n\n  main() \nB. def main():\n\n  n,m=list(map(int,input().split()))\n\n  inf=10**9\n\n  dp=[inf]*(1<<n)\n\n  dp[0]=0\n\n  \n\n  #cost=[inf for i in range(m)]\n\n  for i in range(m):\n\n    a,b=list(map(int,input().split()))\n\n    c=[1<<(int(x)-1) for x in input().split()]\n\n    t=sum(c)\n\n    #cost[i]=[s,a]\n\n    for s in range(1<<n):\n\n      if dp[t|s]>dp[s]+a:\n\n        dp[t|s]=dp[s]+a\n\n      #dp[t|s]=min(dp[t|s], dp[s]+a)\n\n    \n\n  #print(cost)\n\n  \"\"\"\n\n  dp=[inf]*(1<<n)\n\n  dp[0]=0\n\n  for s in range(1<<n):\n\n    for bit,c in cost:\n\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n\n  #print(dp)\n\n  \"\"\"\n\n  #print(dp)\n\n  print((-1 if dp[-1]==inf else dp[-1]))\n\n\n\nif __name__=='__main__':\n\n  main()", "output": "B", "improve_diff": 1.04947761, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import sys\n\ninput = sys.stdin.readline\n\nclass UnionFind(object):\n\n    def __init__(self, size):\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0]*size\n\n    def find(self, x):\n\n        if self.parent[x] == x:\n\n            return x\n\n        # path compression\n\n        self.parent[x] = self.find(self.parent[x])\n\n        return self.parent[x]\n\n    \n\n    def unite(self, x, y):\n\n        x, y = self.find(x), self.find(y)\n\n        if x == y:\n\n            return\n\n        # union by rank\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n    \n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n\n\nif __name__ == \"__main__\":\n\n    N = int(eval(input()))\n\n    vs = []\n\n    for i in range(N):\n\n        x,y = list(map(int,input().split()))\n\n        vs.append((x,y,i))\n\n    vs.sort()\n\n    edges = []\n\n    for k in range(1, N):\n\n        x,y,i = vs[k]\n\n        a,b,j = vs[k-1]\n\n        edges.append((i, j, min(abs(x-a),abs(y-b))))\n\n    vs.sort(key=lambda x:x[1])\n\n    for k in range(1, N):\n\n        x,y,i = vs[k]\n\n        a,b,j = vs[k-1]\n\n        edges.append((i, j, min(abs(x-a),abs(y-b))))\n\n    uf = UnionFind(N)\n\n    edges.sort(key=lambda x:x[2])\n\n    ans = 0\n\n    for i,j,w in edges:\n\n        if not uf.same(i,j):\n\n            uf.unite(i,j)\n\n            ans += w\n\n    print(ans) \nB. import heapq as hq\n\nclass UnionFind(object):\n\n    def __init__(self, size):\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0]*size\n\n    def find(self, x):\n\n        if self.parent[x] == x:\n\n            return x\n\n        self.parent[x] = self.find(self.parent[x])\n\n        return self.parent[x]\n\n    def unite(self, x, y):\n\n        x, y = self.find(x), self.find(y)\n\n        if x == y:\n\n            return\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\nN = int(eval(input()))\n\nls = []\n\nrs = []\n\nind = 0\n\ninds = dict()\n\nfor _ in range(N):\n\n    x,y = list(map(int,input().split()))\n\n    if (x,y) not in list(inds.keys()):\n\n        ls.append((x,y))\n\n        rs.append((y,x))\n\n        inds[(x,y)] = ind\n\n        ind += 1\n\nN = ind\n\nls.sort()\n\nrs.sort()\n\nuf = UnionFind(N)\n\n\n\nedges = []\n\nfor i in range(N-1):\n\n    x = ls[i][0]\n\n    a = ls[i+1][0]\n\n    y = ls[i][1]\n\n    b = ls[i+1][1]\n\n    d = min(abs(x-a), abs(y-b))\n\n    edges.append((d,(x,y),(a,b)))\n\n    x = rs[i][1]\n\n    a = rs[i+1][1]\n\n    y = rs[i][0]\n\n    b = rs[i+1][0]\n\n    d = min(abs(x-a), abs(y-b))\n\n    edges.append((d,(x,y),(a,b)))\n\nedges.sort(key=lambda x:x[0])\n\nans = 0\n\nfor d,i,j in edges:\n\n        # \n\n        if not uf.same(inds[i],inds[j]):\n\n            uf.unite(inds[i],inds[j])\n\n            ans += d\n\nprint(ans)", "output": "A", "improve_diff": 1.3223094008, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nB = [int(x) for x in input().split()]\n\nC = [int(x) for x in input().split()]\n\n\n\nA.sort()\n\nB.sort()\n\nC.sort()\n\nB += [10 ** 9 + 1] + [0]    # B[-1] = 0, B[N] = 10**9 + 1\n\nC += [10 ** 9 + 1] + [0]    # C[-1] = 0, C[N] = 10**9 + 1\n\n\n\n# For each j = 0, 1, ..., N-1,\n\n# find k such that B[j] < C[k] and (C[k-1] <= B[j] or k = 0)\n\n# Let K[j] = k for such k.\n\n# If such k doesn't exist, let K[j] := N\n\nK = [0] * N\n\n\n\nfor j in range(N):\n\n    ng = -1 # C[ng] <= B[j]\n\n    ok = N  # B[j] < C[ok]\n\n    while ok - ng > 1:\n\n        mid = (ok + ng) // 2\n\n        if B[j] < C[mid]:\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    K[j] = ok\n\n\n\n# Let\n\n# f[j] := B[j]C[k] + B[j + 1]C[k]\n\n#           ... + B[N-1]C[k]\n\nf = [0] * (N - 1) + [N - K[N - 1]]\n\nfor j in range(N - 2, -1, -1):\n\n    f[j] = f[j + 1] + N - K[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    # find j such that B[j - 1] <= A[i] < B[j]\n\n    ng = -1  # B[ng] <= A[i]\n\n    ok = N   # A[i] < B[ok]\n\n    while ok - ng > 1:\n\n        mid = (ok + ng) // 2\n\n        if A[i] < B[mid]:\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    if ok >= N: continue\n\n    # 0 <= ok <= N - 1\n\n    ans += f[ok]\n\n\n\nprint(ans) \nB. import bisect\n\n\n\nN = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nB = [int(x) for x in input().split()]\n\nC = [int(x) for x in input().split()]\n\n\n\nA.sort()\n\nB.sort()\n\nC.sort()\n\n\n\nans = 0\n\nfor j in range(N):\n\n    i = bisect.bisect_left(A, B[j])\n\n    k = bisect.bisect_right(C, B[j])\n\n    ans += i * (N - k)\n\n\n\nprint(ans)", "output": "A", "improve_diff": 1.3637304135, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import copy\n\n\n\nfrom typing import List, Tuple\n\n\n\n\n\ndef main():\n\n    d, g = list(map(int, input().split()))\n\n    v = []\n\n    for _ in range(d):\n\n        p, c = list(map(int, input().split()))\n\n        v.append((p, c))\n\n\n\n    print((ag(v, g)))\n\n\n\n\n\ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n\n    # ex. [(3, 500), (5, 800)] -> [(1, 3, 500), (2, 5, 800)]\n\n    v = [(i, p, c) for i, (p, c) in enumerate(v, 1)]\n\n\n\n    result = 100 ** 10\n\n    for j in range(2 ** len(v)):\n\n        cb = []\n\n        for k in range(len(v)):\n\n            if ((j >> k) & 1):\n\n                cb.append(v[k])\n\n\n\n        sc = 0\n\n        cnt = 0\n\n        # calc bonus score\n\n        for (i, p, c) in cb:\n\n            sc += i * 100 * p + c\n\n            cnt += p\n\n\n\n        for idx in reversed(list(range(len(v)))):\n\n            if sc >= g:\n\n                break\n\n            if v[idx] in cb:\n\n                continue\n\n            i, p, _ = v[idx]\n\n            for _ in range(p - 1):\n\n                if sc >= g:\n\n                    break\n\n                sc += i * 100\n\n                cnt += 1\n\n\n\n        if sc >= g:\n\n            result = min(result, cnt)\n\n    return result\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n \nB. import itertools\n\nfrom typing import List, Tuple\n\n\n\n\n\ndef main():\n\n    d, g = list(map(int, input().split()))\n\n    v = []\n\n    for _ in range(d):\n\n        p, c = list(map(int, input().split()))\n\n        v.append((p, c))\n\n\n\n    print((ag(v, g)))\n\n\n\n\n\ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n\n    # ex. [(3, 500), (5, 800)] -> [(1, 3, 500), (2, 5, 800)]\n\n    v = [(i + 1, v[i][0], v[i][1]) for i in range(len(v))]\n\n\n\n    result = 100 ** 10\n\n\n\n    for j in range(len(v) + 1):\n\n        for cb in itertools.combinations(v, j):\n\n            sc = 0\n\n            cnt = 0\n\n            # calc bonus score\n\n            for (i, p, c) in cb:\n\n                sc += i * 100 * p + c\n\n                cnt += p\n\n\n\n            for idx in reversed(list(range(len(v)))):\n\n                if sc >= g:\n\n                    break\n\n                if v[idx] in cb:\n\n                    continue\n\n                i, p, _ = v[idx]\n\n                for _ in range(p - 1):\n\n                    if sc >= g:\n\n                        break\n\n                    sc += i * 100\n\n                    cnt += 1\n\n\n\n            if sc >= g:\n\n                result = min(result, cnt)\n\n    return result\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n", "output": "B", "improve_diff": 1.0235734652, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from collections import deque\n\n\n\nN = int(input())\n\nS, T = input().split()\n\n\n\nchar = deque()\n\n\n\nfor i in range(N):\n\n    char.append(S[i])\n\n    char.append(T[i])\n\n\n\nprint(*char, sep='')\n \nB. N = int(input())\n\nS, T = input().split()\n\nchar = []\n\n\n\nfor i in range(N):\n\n    char.append(S[i])\n\n    char.append(T[i])\n\n\n\nprint(*char, sep='')\n", "output": "B", "improve_diff": 1.5419991828, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\ndef eratosthenes(limit):\n\n    A = [i for i in range(2, limit+1)]\n\n    P = []\n\n    while True:\n\n        prime = min(A)\n\n        if prime > math.sqrt(limit):\n\n            break\n\n        P.append(prime)\n\n        i = 0\n\n        while i < len(A):\n\n            if A[i] % prime == 0:\n\n                A.pop(i)\n\n                continue\n\n            i += 1\n\n    for a in A:\n\n        P.append(a)\n\n    return list(P)\n\n\n\na = eratosthenes(100000)\n\nb = set([2*i-1 for i in a])\n\na = set(a)\n\nchk = sorted(list(a&b))\n\n\n\nfrom bisect import bisect,bisect_left\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nq = int(eval(input()))\n\nfor i in range(q):\n\n  l,r = list(map(int,input().split()))\n\n  print((bisect(chk,r)-bisect_left(chk,l))) \nB. def is_prime(q):\n\n    if q == 2: return True\n\n    if q < 2 or q&1 == 0: return False\n\n    return pow(5, q-1, q)*pow(7, q-1, q) == 1\n\n    \n\ns = [561, 11041, 29341, 38081, 46657, 50737, 75361, 79381, 88831]\n\nb = [5,7]\n\nfor i in range(2,10**5):\n\n  if i in s:\n\n    continue\n\n  if is_prime(i):\n\n    b.append(i)\n\n\n\na = set([2*i-1 for i in b])\n\nb = set(b)\n\nchk = sorted(list(a&b))\n\n \n\nfrom bisect import bisect,bisect_left\n\nimport sys\n\ninput = sys.stdin.readline\n\n \n\nq = int(eval(input()))\n\nfor i in range(q):\n\n  l,r = list(map(int,input().split()))\n\n  print((bisect(chk,r)-bisect_left(chk,l)))", "output": "B", "improve_diff": 27.970762765, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import networkx as nx\n\nN = int(eval(input()))\n\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\n\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\n\nG = nx.DiGraph()\n\nfor a, b in AB:\n\n    G.add_edge(-1, a * 1000 + b, capacity=1)\n\nfor c, d in CD:\n\n    G.add_edge(c * 1000 + d, -2, capacity=1)\n\nfor a, b in AB:\n\n    for c, d in CD:\n\n        if a < c and b < d:\n\n            G.add_edge(a * 1000 + b, c * 1000 + d, capacity=1)\n\nflow_value, flow_dict = nx.maximum_flow(G, -1, -2)\n\nprint(flow_value)\n \nB. import collections, itertools\n\n\n\n\n\nclass MaximumFlow:\n\n    def __init__(self, G):\n\n        self.G = G\n\n\n\n    def ford_fulkerson(self, s, t):\n\n        def dfs(start, used):\n\n            G = self.G\n\n            if start == t:\n\n                return [start]\n\n            for end, cap in list(G[start].items()):\n\n                if cap > 0 and end not in used:\n\n                    used.add(end)\n\n                    ret = dfs(end, used)\n\n                    if ret:\n\n                        return ret + [start]\n\n            return []\n\n\n\n        fmax = 0\n\n        cnt = 0\n\n        while True:\n\n            G = self.G\n\n            cnt += 1\n\n            root = dfs(s, set([s]))\n\n            if root:\n\n                root = root[::-1]\n\n                residue = min([G[a][b] for a, b in zip(root, root[1:])])\n\n                fmax += residue\n\n                for a, b in zip(root, root[1:]):\n\n                    G[a][b] -= residue\n\n                    G[b][a] += residue\n\n            else:\n\n                return (fmax, G)\n\n\n\n\n\nN = int(eval(input()))\n\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\n\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\n\nG = collections.defaultdict(lambda: collections.defaultdict(int))\n\nfor a, b in AB:\n\n    G[-1][1000 * a + b] = 1\n\nfor c, d in CD:\n\n    G[1000 * c + d][-2] = 1\n\nfor ab, cd in itertools.product(AB, CD):\n\n    a, b = ab\n\n    c, d = cd\n\n    if a < c and b < d:\n\n        G[1000 * a + b][1000 * c + d] = 1\n\nflow = MaximumFlow(G)\n\nfmax, Gres = flow.ford_fulkerson(-1, -2)\n\nprint(fmax)\n", "output": "B", "improve_diff": 11.2746160212, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n=int(eval(input()))\n\nes=[[] for _ in range(n)]\n\n\n\nfor _ in range(n-1):\n\n    a,b,c=list(map(int,input().split()))\n\n    es[a-1].append((b-1,c))\n\n    es[b-1].append((a-1,c))\n\n\n\nq,k=list(map(int,input().split()))\n\nk-=1\n\ndist=[float('inf')]*n\n\n\n\ndist[k]=0\n\nstack=[k]\n\nwhile stack:\n\n    now=stack.pop()\n\n    for e,w in es[now]:\n\n        if dist[e]==float('inf'):\n\n            dist[e]=dist[now]+w\n\n            stack.append(e)\n\n\n\nfor _ in range(q):\n\n    x,y=list(map(int,input().split()))\n\n    x-=1\n\n    y-=1\n\n    print((dist[x]+dist[y])) \nB. n=int(eval(input()))\n\nes=[[] for _ in range(n)]\n\n\n\nfor _ in range(n-1):\n\n    a,b,c=list(map(int,input().split()))\n\n    es[a-1].append((b-1,c))\n\n    es[b-1].append((a-1,c))\n\n\n\nfrom heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n\n    distance = [float('inf')] * size\n\n    distance[source] = 0\n\n    visited = [False] * size\n\n    pq = []\n\n    heappush(pq, (0, source))\n\n    while pq:\n\n        dist_v, v = heappop(pq)\n\n        visited[v] = True\n\n        for u, weight in edges[v]:\n\n            if not visited[u]:\n\n                new_dist = dist_v + weight\n\n                if distance[u] > new_dist:\n\n                    distance[u] = new_dist\n\n                    heappush(pq, (new_dist, u))\n\n    return distance\n\n\n\n\n\nq,k=list(map(int,input().split()))\n\nk-=1\n\ndist=dijkstra(es,n,k)\n\nfor _ in range(q):\n\n    x,y=list(map(int,input().split()))\n\n    x-=1\n\n    y-=1\n\n    print((dist[x]+dist[y]))", "output": "A", "improve_diff": 1.442470141, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. import math\n\nq=int(eval(input()))\n\nnum=[0]*(10**5+5)\n\nans=[0]*(10**5+5)\n\nnum[2]=1\n\nfor i in range(3,10**5+2,2):\n\n    yn=0\n\n    for j in range(2,int(math.sqrt(i))+1):\n\n        if i%j==0:\n\n            yn=1\n\n            break\n\n    if yn==0:\n\n        num[i]=1\n\n        if num[(i+1)//2]==1:\n\n            ans[i]=1\n\nfor i in range(1,len(num)):\n\n    ans[i]=ans[i-1]+ans[i]\n\nfor i in range(q):\n\n    l,r=list(map(int,input().split()))\n\n    print((ans[r]-ans[l-1]))\n \nB. def sb(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5//1))+1):\n\n        if temp%i==0:\n\n            cnt=0\n\n            while temp%i==0:\n\n                cnt+=1\n\n                temp //= i\n\n            arr.append([i, cnt])\n\n    if temp!=1:\n\n        arr.append([temp, 1])\n\n    if arr==[]:\n\n        arr.append([n, 1])\n\n    return arr\n\nnum=[0]*(10**5+1)\n\nnum2=[0]*(10**5+1)\n\ncnt=[0]*(10**5+1)\n\nnum[2]+=1\n\nfor i in range(2,10**5+1):\n\n    if i%2==1:\n\n        n=sb(i)\n\n        if len(n)==1 and n[0][1]==1:\n\n            num[i]+=1\n\n        if num[i]==1 and num[(i+1)//2]==1:\n\n            num2[i]+=1\n\nfor i in range(1,len(num2)):\n\n    cnt[i]=cnt[i-1]+num2[i]\n\nq=int(eval(input()))\n\nfor i in range(q):\n\n    l,r=list(map(int,input().split()))\n\n    print((cnt[r]-cnt[l-1]))\n", "output": "A", "improve_diff": 3.0909586886, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from operator import mul\n\nfrom functools import reduce\n\nMOD = 10 ** 9 + 7\n\n\n\nN, K = list(map(int, input().split()))\n\n\n\ndef cmb(n, r):\n\n    if n < r:\n\n        return 0\n\n    r = min(r, n-r)\n\n    if r == 0:\n\n        return 1\n\n    nume = reduce(mul, list(range(n, n-r, -1)))\n\n    deno = reduce(mul, list(range(1, r+1)))\n\n    \n\n    return nume // deno % MOD\n\n\n\n# \uff08N-K+1\uff09i\n\nfor i in range(1, K+1):\n\n    print((cmb((N-K+1), i) * cmb((K-1), i-1) % MOD)) \nB. import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\ndef cmb(n, k):\n\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\n\n\ndef cumprod(arr, MOD):\n\n    L = len(arr); Lsq = int(L**.5+1)\n\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n\n    for n in range(1, Lsq):\n\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n\n    for n in range(1, Lsq):\n\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n\n    return arr.ravel()[:L]\n\n\n\ndef make_fact(U, MOD):\n\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n\n    fact = cumprod(x, MOD)\n\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n\n    fact_inv = cumprod(x, MOD)[::-1]\n\n    return fact, fact_inv\n\n\n\nN, K = lr()\n\nMOD = 10 ** 9 + 7\n\nU = 2010 # \n\nfact, fact_inv = make_fact(U, MOD)\n\nred = N-K\n\nfor i in range(1, K+1):\n\n    # (red+1)Ci\n\n    answer = 0 if red+1 < i else cmb(red+1, i)\n\n    #print(answer)\n\n    remain = K - i\n\n    # remainii-1\n\n    # (remain+(i-1)) C remain\n\n    answer *= cmb(remain+i-1, remain)\n\n    print((answer%MOD))\n\n\n\n# 15\n", "output": "A", "improve_diff": 6.3486934256, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def f(n):\n\n  p=[]\n\n  if n%2==0:\n\n    c=0\n\n    while n%2==0:\n\n      c+=1\n\n      n/=2\n\n    p.append(c)\n\n  for i in range(3,int(n**0.5)+1,2):\n\n    if n%i==0:\n\n      c=0\n\n      while n%i==0:\n\n        c+=1\n\n        n/=i\n\n      p.append(c)\n\n  if n!=1:\n\n    p.append(1)\n\n  return p\n\n  \n\nN=int(eval(input()))\n\np=f(N)\n\nr=0\n\nwhile p:\n\n  r+=int(((8*p.pop()+1)**0.5-1)/2)\n\nprint(r) \nB. N=int(eval(input()))\n\np=[]\n\nr=0\n\n\n\nif N%2==0:\n\n  c=0\n\n  while N%2==0:\n\n    N=N//2\n\n    c+=1\n\n  p.append(c)\n\nfor i in range(3,int(N**0.5)+1,2):\n\n  if N%i==0:\n\n    c=0\n\n    while N%i==0:\n\n      N=N//i\n\n      c+=1\n\n    p.append(c)\n\nif N!=1:\n\n  p.append(1)\n\n  \n\nwhile p:\n\n  r+=int(((8*p.pop()+1)**0.5-1)/2)\n\n  \n\nprint(r)", "output": "A", "improve_diff": 1.0866803907, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby, product\n\n    from bisect import bisect_left,bisect_right\n\n    from heapq import heapify, heappop, heappush\n\n    from math import floor, ceil,pi,factorial\n\n    from operator import itemgetter\n\n    def I(): return int(eval(input()))\n\n    def MI(): return list(map(int, input().split()))\n\n    def LI(): return list(map(int, input().split()))\n\n    def LI2(): return [int(eval(input())) for i in range(n)]\n\n    def MXI(): return [[LI()]for i in range(n)]\n\n    def SI(): return input().rstrip()\n\n    def printns(x): print(('\\n'.join(x)))\n\n    def printni(x): print(('\\n'.join(list(map(str,x)))))\n\n    inf = 10**17\n\n    mod = 10**9 + 7\n\n#main code here!\n\n    r=I()\n\n    print((3*r**2))\n\n            \n\n            \n\n            \n\n    \n\n\n\n        \n\n    \n\n            \n\n        \n\n\n\n        \n\nif __name__==\"__main__\":\n\n    main()\n \nB. import sys\n\ninput = sys.stdin.readline\n\nimport math\n\nimport collections\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\nr=I()\n\nprint((3*r*r))", "output": "B", "improve_diff": 1.0700009639, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. n,x = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\nres = float('inf')\n\nfor b in (a,a[::-1]):\n\n    tmp = 0\n\n    for i in range(n-1):\n\n        if b[i]+b[i+1]>x:\n\n            tmp += b[i] + b[i+1] - x\n\n            if b[i]>x:\n\n                b[i],b[i+1] = x,0\n\n            else:\n\n                b[i+1] = x - b[i]\n\n    res = min(res,tmp)\n\n\n\nprint(res)\n \nB. n,x = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\nres = 0\n\nif a[0]>x:\n\n    res += a[0] - x\n\n    a[0] = x\n\nif a[-1]>x:\n\n    res += a[-1] - x\n\n    a[-1] = x\n\nfor i in range(n-1):\n\n    if a[i]+a[i+1]>x:\n\n        res += a[i] + a[i+1] - x\n\n        a[i+1] -= a[i] + a[i+1] - x\n\nprint(res)\n", "output": "A", "improve_diff": 1.0058267478, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. # -*- coding: utf-8 -*-\n\nimport sys\n\n# sys.setrecursionlimit(10**6)\n\n# buff_readline = sys.stdin.buffer.readline\n\nbuff_readline = sys.stdin.readline\n\nreadline = sys.stdin.readline\n\n\n\nINF = 2**62-1\n\n\n\n\n\ndef read_int():\n\n    return int(buff_readline())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, buff_readline().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(buff_readline())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, buff_readline().split()))\n\n\n\n\n\ndef read_str():\n\n    return readline().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return readline().strip().split()\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\n\n\nclass Combination:\n\n    def __init__(self, n, mod):\n\n\n\n        g1 = [1, 1]\n\n        g2 = [1, 1]\n\n        inverse = [0, 1]\n\n        for i in range(2, n + 1):\n\n            g1.append((g1[-1] * i) % mod)\n\n            inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n            g2.append((g2[-1] * inverse[-1]) % mod)\n\n        self.MOD = mod\n\n        self.N = n\n\n        self.g1 = g1\n\n        self.g2 = g2\n\n        self.inverse = inverse\n\n\n\n    def __call__(self, n, r):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return self.g1[n] * self.g2[r] * self.g2[n-r] % self.MOD\n\n\n\n\n\n@mt\n\ndef slv(N, M, K):\n\n    mod = 10**9+7\n\n    C = Combination(N*M, mod)\n\n    b = C(N*M-2, K-2)\n\n    ans = 0\n\n    m = M**2\n\n    for d in range(1, N):\n\n        ans += (N-d) * b * d * m\n\n        ans %= mod\n\n    m = N**2\n\n    for d in range(1, M):\n\n        ans += (M-d) * b * d * m\n\n        ans %= mod\n\n\n\n\n\n\n\n    return ans\n\n\n\n\n\n\n \nB. # -*- coding: utf-8 -*-\n\nimport bisect\n\nimport heapq\n\nimport math\n\nimport random\n\nimport sys\n\nfrom collections import Counter, defaultdict, deque\n\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\n\nfrom functools import lru_cache, reduce\n\nfrom itertools import combinations, combinations_with_replacement, product, permutations\n\nfrom operator import add, mul, sub\n\n\n\nsys.setrecursionlimit(100000)\n\n\n\n\n\ndef read_int():\n\n    return int(input())\n\n\n\n\n\ndef read_int_n():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef read_float():\n\n    return float(input())\n\n\n\n\n\ndef read_float_n():\n\n    return list(map(float, input().split()))\n\n\n\n\n\ndef read_str():\n\n    return input().strip()\n\n\n\n\n\ndef read_str_n():\n\n    return list(map(str, input().split()))\n\n\n\n\n\ndef error_print(*args):\n\n    print(*args, file=sys.stderr)\n\n\n\n\n\ndef mt(f):\n\n    import time\n\n\n\n    def wrap(*args, **kwargs):\n\n        s = time.time()\n\n        ret = f(*args, **kwargs)\n\n        e = time.time()\n\n\n\n        error_print(e - s, 'sec')\n\n        return ret\n\n\n\n    return wrap\n\n\n\n\n\nclass Mod:\n\n    def __init__(self, m):\n\n        self.m = m\n\n\n\n    def add(self, a, b):\n\n        return (a + b) % self.m\n\n\n\n    def sub(self, a, b):\n\n        return (a - b) % self.m\n\n\n\n    def mul(self, a, b):\n\n        return ((a % self.m) * (b % self.m)) % self.m\n\n\n\n    def div(self, a, b):\n\n        return self.mul(a, self.pow(b, self.m-2))\n\n\n\n    def pow(self, x, y):\n\n        if y == 0:\n\n            return 1\n\n        elif y == 1:\n\n            return x % self.m\n\n        elif y % 2 == 0:\n\n            return self.pow(x, y//2)**2 % self.m\n\n        else:\n\n            return self.pow(x, y//2)**2 * x % self.m\n\n\n\n\n\nclass Combination:\n\n    def __init__(self, n, mod):\n\n\n\n        g1 = [1, 1]\n\n        g2 = [1, 1]\n\n        inverse = [0, 1]\n\n        for i in range(2, n + 1):\n\n            g1.append((g1[-1] * i) % mod)\n\n            inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n\n            g2.append((g2[-1] * inverse[-1]) % mod)\n\n        self.MOD = mod\n\n        self.N = n\n\n        self.g1 = g1\n\n        self.g2 = g2\n\n        self.inverse = inverse\n\n\n\n    def __call__(self, n, r):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return self.g1[n] * self.g2[r] * self.g2[n-r] % self.MOD\n\n\n\n\n\n@mt\n\ndef slv(N, M, K):\n\n    m = Mod(10**9+7)\n\n    b = Combination(N*M, 10**9+7)(N*M-2, K-2)\n\n\n\n    MM = m.mul(M, M)\n\n    NN = m.mul(N, N)\n\n    ans = 0\n\n    for d in range(1, N):\n\n        ans = m.add(ans, m.mul(m.mul(m.mul(d, N-d), MM), b))\n\n\n\n    for d in range(1, M):\n\n        ans = m.add(ans, m.mul(m.mul(m.mul(d, M-d), NN), b))\n\n\n\n    return ans\n\n\n\n\n", "output": "A", "improve_diff": 1.9803654307, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. d,g = list(map(int,input().split()))\n\nPC = [list(map(int,input().split())) for _ in range(d)]\n\ncost = 10000000\n\n\n\nfor j in range(2**d):\n\n    temp = 0\n\n    score = 0\n\n    bit = format(j,\"0\"+str(d)+\"b\")\n\n    for i in range(d):\n\n        if bit[i] == \"1\":\n\n            score += PC[i][0]*(i+1)*100 + PC[i][1]\n\n            temp += PC[i][0]\n\n    if score >= g:\n\n        if temp < cost:\n\n            cost = temp\n\n    else:\n\n        for i in range(d-1,-1,-1):\n\n            if bit[i] == \"0\":\n\n                p,c = PC[i]\n\n                point = 100*(i+1)\n\n                for v in range(p):\n\n                    score += point\n\n                    temp += 1\n\n                    if score >= g:\n\n                        break\n\n                break\n\n        if score >= g and temp < cost:\n\n            cost = temp\n\nprint(cost) \nB. from sys import setrecursionlimit\n\nfrom operator import itemgetter\n\nfrom math import ceil\n\ndef main():\n\n    D,G = list(map(int,input().split()))\n\n    PC = [list(map(int,input().split())) for _ in range(D)]\n\n    ans = float(\"inf\")\n\n    for i in range(2**D):\n\n        done = [False]*D\n\n        tmp = 0\n\n        q = 0\n\n        cnt = i\n\n        point = 0\n\n        while cnt > 0:\n\n            if cnt%2 == 1:\n\n                done[point] = True\n\n                tmp += PC[point][0]*(100*(point + 1)) + PC[point][1]\n\n                q += PC[point][0]\n\n            point += 1\n\n            cnt //= 2\n\n        if tmp < G:\n\n            for j in range(D):\n\n                if not(done[D - j - 1]):\n\n                    score = 100*(D - j)\n\n                    num = min(ceil((G - tmp) / score),PC[D - j - 1][0])\n\n                    tmp += num*score\n\n                    q += num\n\n                    if tmp < G:\n\n                        q = float(\"inf\")\n\n                    break\n\n                \n\n        ans = min(q,ans)\n\n    print(ans)\n\n    return\n\n\n\nif __name__ == \"__main__\":\n\n    main()", "output": "A", "improve_diff": 1.3929787488, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. N = int(eval(input()))\n\nH = list(map(int, input().split()))\n\n\n\n# H1.\n\n#  (left, right) 1.\n\n\n\nans = 0\n\nwhile sum(H) > 0:\n\n    left = right = 0\n\n    prev = 0\n\n    segment = []\n\n    for i, h in enumerate(H):\n\n        if h == 0 and prev != 0: # H = {..., 0, *(left), *, ..., *, 0(right), ...} (*: )\n\n            right = i\n\n            segment.append((left, right))\n\n        elif h != 0 and prev == 0:\n\n            left = i\n\n            if i == N-1: # H = {..., 0, *(left)} (*: )\n\n                right = i + 1\n\n                segment.append((left, right))\n\n        elif h != 0 and i == N-1: #(prev != 0) H = {..., 0, *(left), ..., *, *} (*: )\n\n            right = i + 1\n\n            segment.append((left, right))\n\n        prev = h\n\n    ans += len(segment)\n\n    #  H1.\n\n    for l, r in segment:\n\n        for i in range(l, r):\n\n            H[i] -= 1\n\nprint(ans) \nB. N = int(eval(input()))\n\nH = list(map(int, input().split()))\n\n\n\nstack = [H]\n\ncount = 0\n\nwhile stack:\n\n    lst = stack.pop()\n\n    m = min(lst)\n\n    count += m\n\n    lst = [l-m for l in lst]\n\n    prev = 0\n\n    left = 0\n\n    for i, h in enumerate(lst):\n\n        if h == 0 and prev != 0: # H = {..., 0, *(left), *, ..., *, 0(right), ...} (*: )\n\n            stack.append(lst[left:i])\n\n        elif h != 0 and prev == 0:\n\n            left = i\n\n            if i == len(lst)-1: # H = {..., 0, *(left)} (*: )\n\n                stack.append(lst[left:i+1])\n\n        elif h != 0 and i == len(lst)-1: #(prev != 0) H = {..., 0, *(left), ..., *, *} (*: )\n\n            stack.append(lst[left:i+1])\n\n        prev = h\n\nprint(count)", "output": "A", "improve_diff": 1.0390963926, "is_improve": false}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from functools import reduce\n\nfrom operator import mul\n\n\n\nn = int(eval(input()))\n\na_list = [int(x) for x in input().split()]\n\n\n\ntemp_mul = reduce(mul, a_list)\n\n\n\ntemp_add = 0\n\nfor a in a_list:\n\n    temp_add += temp_mul // a\n\n\n\nans = temp_mul / temp_add\n\nprint(ans) \nB. n = int(eval(input()))\n\na_list = [int(x) for x in input().split()]\n\n\n\ntemp = 0\n\nfor a in a_list:\n\n    temp += 1 / a\n\nans = 1 / temp\n\nprint(ans)", "output": "B", "improve_diff": 1.6104296881, "is_improve": true}
{"instruction": "Given a selection of code, determine which one is the most efficient in computing. \nA. from bisect import bisect_left\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nL = list(map(int, input().split()))\n\nL.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    for j in range(i+1, N):\n\n        l = L[i] + L[j]\n\n        k = bisect_left(L, l)\n\n        ans += max(0, k - j - 1)\n\nprint(ans) \nB. from bisect import bisect_left\n\n\n\nN = int(eval(input()))\n\nL = list(map(int, input().split()))\n\nL.sort()\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(i+1, N):\n\n        max_len = L[i] + L[j]\n\n        count += bisect_left(L, max_len) - j - 1\n\nprint(count)\n", "output": "A", "improve_diff": 1.0681095485, "is_improve": true}
